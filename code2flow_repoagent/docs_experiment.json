{
    "setup.py": [],
    "code2flowlib/dotgenerator.py": [],
    "code2flowlib/engine.py": [
        {
            "type": "class",
            "name": "Node",
            "methods": []
        },
        {
            "type": "class",
            "name": "Edge",
            "methods": []
        },
        {
            "type": "class",
            "name": "Group",
            "methods": []
        },
        {
            "type": "class",
            "name": "SourceCode",
            "methods": []
        },
        {
            "type": "class",
            "name": "Mapper",
            "methods": []
        }
    ],
    "code2flowlib/nesting.py": [
        {
            "type": "class",
            "name": "SourceFile",
            "methods": []
        }
    ],
    "code2flowlib/mutablestring.py": [
        {
            "type": "class",
            "name": "MString",
            "methods": []
        }
    ],
    "code2flowlib/languages/python.py": [
        {
            "type": "class",
            "name": "Node",
            "methods": []
        },
        {
            "type": "class",
            "name": "Edge",
            "methods": []
        },
        {
            "type": "class",
            "name": "Group",
            "methods": []
        },
        {
            "type": "class",
            "name": "SourceCode",
            "methods": []
        },
        {
            "type": "class",
            "name": "Mapper",
            "methods": []
        }
    ],
    "code2flowlib/languages/javascript.py": [
        {
            "type": "class",
            "name": "Node",
            "methods": []
        },
        {
            "type": "class",
            "name": "Edge",
            "methods": []
        },
        {
            "type": "class",
            "name": "Group",
            "methods": []
        },
        {
            "type": "class",
            "name": "SourceCode",
            "methods": []
        },
        {
            "type": "class",
            "name": "Mapper",
            "methods": []
        }
    ],
    "testscripts/pysimple2.py": [
        {
            "type": "class",
            "name": "h",
            "methods": []
        }
    ],
    "testscripts/pysimple.py": [
        {
            "type": "class",
            "name": "e",
            "methods": []
        }
    ],
    "testscripts/urllib2.py": [
        {
            "type": "class",
            "name": "URLError",
            "methods": [
                {
                    "method_name": "__init__",
                    "source_code": "def __init__(self, reason):\n    self.reason = reason",
                    "first_doc": "**__init__**: The function of __init__ is to initialize a new instance of the URLError class with a specified reason.\n\n**parameters**: The parameters of this Function.\n· reason: The reason for the URL error, typically an exception or a descriptive string explaining why the error occurred.\n\n**Code Description**:  \nThis constructor method sets up a new URLError object by assigning the provided reason to the instance's reason attribute. The reason parameter is stored directly, allowing users of the URLError class to access the specific cause of the error through the reason attribute. This design enables clear and direct reporting of error causes when handling URL-related exceptions.\n\n**Note**:  \nThe reason parameter should provide meaningful information about the error, as it will be used to describe the cause of the URLError instance. There is no type restriction enforced in this method, so it is important to ensure that the reason supplied is appropriate for error reporting and debugging purposes."
                },
                {
                    "method_name": "__str__",
                    "source_code": "def __str__(self):\n    return '<urlopen error %s>' % self.reason",
                    "first_doc": "**__str__**: The function of __str__ is to provide a human-readable string representation of the URLError instance.\n\n**parameters**: The parameters of this Function.\n· self: Refers to the instance of the URLError class.\n\n**Code Description**:  \nThis method returns a string that describes the URLError instance in a standardized format. Specifically, it constructs a string in the format \"<urlopen error %s>\", where %s is replaced by the value of the instance's reason attribute. The reason attribute typically contains information about the underlying cause of the URL error, such as a network issue or an invalid URL. This string representation is useful for debugging and logging, as it concisely conveys the nature of the error encountered during a URL open operation.\n\n**Note**:  \n- The reason attribute must be set on the URLError instance for the string representation to be meaningful.\n- This method is automatically called when the instance is converted to a string, such as when passed to print() or str().\n\n**Output Example**:  \n<urlopen error Connection refused>  \n<urlopen error timed out>  \n<urlopen error Invalid URL>"
                }
            ]
        },
        {
            "type": "class",
            "name": "HTTPError",
            "methods": [
                {
                    "method_name": "__init__",
                    "source_code": "def __init__(self, url, code, msg, hdrs, fp):\n    self.__super_init(fp, hdrs, url)\n    self.code = code\n    self.msg = msg\n    self.hdrs = hdrs\n    self.fp = fp\n    # XXX\n    self.filename = url",
                    "first_doc": "**__init__**: The function of __init__ is to initialize an instance of the HTTPError class with relevant HTTP error information.\n\n**parameters**: The parameters of this Function.\n· url: The URL that caused the HTTP error.\n· code: The HTTP status code associated with the error.\n· msg: The error message describing the HTTP error.\n· hdrs: The headers returned with the HTTP error response.\n· fp: The file-like object representing the response body or data stream.\n\n**Code Description**:  \nThis initializer method sets up an HTTPError instance by assigning the provided arguments to instance attributes. It first calls a superclass initialization method, __super_init, passing fp, hdrs, and url to ensure proper base class setup. The HTTP status code is stored in self.code, the error message in self.msg, the response headers in self.hdrs, and the file-like response object in self.fp. Additionally, the URL is stored in self.filename, which may be used for compatibility or reference purposes.\n\n**Note**:  \n- The method assumes the existence of a __super_init method for proper superclass initialization.\n- The filename attribute is set to the URL, which may be relevant for certain use cases or compatibility with other interfaces.\n- All parameters are required for correct initialization of the HTTPError instance."
                },
                {
                    "method_name": "__str__",
                    "source_code": "def __str__(self):\n    return 'HTTP Error %s: %s' % (self.code, self.msg)",
                    "first_doc": "**__str__**: The function of __str__ is to return a human-readable string representation of the HTTPError instance.\n\n**parameters**: The parameters of this Function.\n· self: Refers to the instance of the HTTPError class.\n\n**Code Description**:  \nThis method provides a string representation for the HTTPError object. When the __str__ method is called, it returns a formatted string that includes the HTTP error code and the associated message. Specifically, it constructs a string in the format \"HTTP Error <code>: <msg>\", where <code> is the HTTP status code (such as 404, 500, etc.) and <msg> is the descriptive message associated with the error. This makes it easier to understand the nature of the HTTP error when the object is printed or converted to a string.\n\n**Note**:  \n- This method is automatically invoked when the HTTPError object is printed or converted to a string using str().\n- Both self.code and self.msg must be set on the HTTPError instance for the output to be meaningful.\n\n**Output Example**:  \nHTTP Error 404: Not Found"
                },
                {
                    "method_name": "__del__",
                    "source_code": "def __del__(self):\n    # XXX is this safe? what if user catches exception, then\n    # extracts fp and discards exception?\n    if self.fp:\n        self.fp.close()",
                    "first_doc": "**__del__**: The function of __del__ is to ensure that the file pointer (fp) associated with the HTTPError instance is properly closed when the object is destroyed.\n\n**parameters**: The parameters of this Function.\n· self: Refers to the instance of the HTTPError class.\n\n**Code Description**:  \nThis method is a destructor, which is automatically called when the HTTPError object is about to be destroyed (i.e., when there are no more references to it). Within this method, it checks if the instance has an attribute named fp (typically a file-like object). If fp exists and is not None, the method calls fp.close() to release any resources associated with the file pointer. This helps prevent resource leaks by ensuring that open file handles are closed when the HTTPError object is no longer needed.\n\n**Note**:  \nCare should be taken when using this destructor. If the user retrieves the fp attribute from the HTTPError object and continues to use it after the HTTPError object has been destroyed, the file pointer may already be closed, potentially leading to errors. It is important to manage the lifecycle of the fp attribute carefully to avoid such issues."
                }
            ]
        },
        {
            "type": "class",
            "name": "GopherError",
            "methods": []
        },
        {
            "type": "class",
            "name": "Request",
            "methods": [
                {
                    "method_name": "__init__",
                    "source_code": "def __init__(self, url, data=None, headers={}):\n    # unwrap('<URL:type://host/path>') --> 'type://host/path'\n    self.__original = unwrap(url)\n    self.type = None\n    # self.__r_type is what's left after doing the splittype\n    self.host = None\n    self.port = None\n    self.data = data\n    self.headers = {}\n    self.headers.update(headers)",
                    "first_doc": "**__init__**: The function of __init__ is to initialize a new Request object with the specified URL, optional data, and headers.\n\n**parameters**: The parameters of this Function.\n· url: The target URL for the request. This value is processed by the unwrap function to extract the actual URL string.\n· data: Optional parameter representing the data to be sent with the request. Defaults to None if not provided.\n· headers: Optional dictionary containing HTTP headers to include with the request. Defaults to an empty dictionary if not provided.\n\n**Code Description**:  \nThis constructor initializes a Request object by first unwrapping the provided url using the unwrap function, storing the result in the __original attribute. It sets up several attributes for the request:  \n- type: Initially set to None, intended to represent the protocol type (e.g., 'http', 'https').  \n- host: Initially set to None, intended to represent the host portion of the URL.  \n- port: Initially set to None, intended to represent the port number if specified in the URL.  \n- data: Stores any data provided for the request, which can be used for POST or PUT requests.  \n- headers: Initializes an empty dictionary and updates it with any headers provided in the headers parameter, ensuring that the Request object contains all specified HTTP headers.\n\n**Note**:  \n- The headers parameter uses a mutable default value (an empty dictionary). This can lead to unexpected behavior if the default dictionary is modified across multiple instances. It is generally recommended to use None as the default and initialize the dictionary within the function.\n- The unwrap function is assumed to process the url and extract the actual URL string, but its implementation is not shown here.\n- The attributes type, host, and port are initialized but not set in this constructor; they may be set or used elsewhere in the class."
                },
                {
                    "method_name": "__getattr__",
                    "source_code": "def __getattr__(self, attr):\n    # XXX this is a fallback mechanism to guard against these\n    # methods getting called in a non-standard order.  this may be\n    # too complicated and/or unnecessary.\n    # XXX should the __r_XXX attributes be public?\n    if attr[:12] == '_Request__r_':\n        name = attr[12:]\n        if hasattr(Request, 'get_' + name):\n            getattr(self, 'get_' + name)()\n            return getattr(self, attr)\n    raise(AttributeError, attr)",
                    "first_doc": "**__getattr__**: The function of __getattr__ is to provide a fallback mechanism for attribute access, specifically handling special internal attributes related to the Request object.\n\n**parameters**: The parameters of this Function.\n· attr: The name of the attribute being accessed.\n\n**Code Description**:  \nThis method is invoked when an attribute lookup on a Request instance fails to find the attribute in the usual places. It checks if the requested attribute name starts with the prefix '_Request__r_'. If so, it extracts the remainder of the attribute name and checks if the Request class has a corresponding 'get_' method for that attribute (for example, if attr is '_Request__r_header', it looks for 'get_header'). If such a method exists, it calls this getter method on the instance, which may initialize or compute the attribute. After the getter is called, it attempts to retrieve the attribute again. If the attribute still does not exist, or if the original attribute name does not match the expected pattern, an AttributeError is raised with the attribute name.\n\nThis mechanism is designed to handle cases where certain internal attributes (with names like '_Request__r_XXX') may not have been initialized yet, and ensures they are properly set up before being accessed. It also serves as a safeguard against non-standard method call orders.\n\n**Note**:  \n- This method only handles attribute names that start with '_Request__r_'. Any other attribute names will immediately result in an AttributeError.\n- The fallback mechanism relies on the presence of corresponding 'get_' methods in the Request class.\n- The internal attributes handled by this method are intended for internal use and may not be part of the public API.\n- If the getter method does not properly initialize the attribute, or if the attribute is still missing after the getter is called, an AttributeError will be raised.\n\n**Output Example**:  \nIf an attribute '_Request__r_header' is accessed and not present, but the Request class has a 'get_header' method, this method will be called, and then '_Request__r_header' will be returned if it exists. If not, an AttributeError will be raised with the attribute name:\n\nAttributeError: '_Request__r_header'"
                },
                {
                    "method_name": "add_data",
                    "source_code": "def add_data(self, data):\n    self.data = data",
                    "first_doc": "**add_data**: The function of add_data is to assign new data to the data attribute of the Request object.\n\n**parameters**: The parameters of this Function.\n· data: The value to be assigned to the data attribute of the Request object.\n\n**Code Description**:  \nThis function is a method of the Request class. Its primary purpose is to update or set the data attribute of a Request instance with the provided data argument. When called, it simply assigns the input value to self.data, effectively storing or replacing any existing data associated with the request.\n\nWithin the project, add_data is used by the open method of the OpenerDirector class. In this context, when the open method receives a Request object and a non-None data argument, it calls add_data to attach or update the data payload of the request before proceeding with further processing. This ensures that any additional data required for the HTTP request (such as POST data) is properly included in the Request object.\n\n**Note**:  \n- The function does not perform any validation or transformation on the input data; it directly assigns the value.\n- It is important to ensure that the data provided is in the correct format expected by the rest of the request-handling logic.\n- This method is typically used internally and is not intended for direct use unless you are manipulating Request objects at a low level."
                },
                {
                    "method_name": "has_data",
                    "source_code": "def has_data(self):\n    return self.data is not None",
                    "first_doc": "**has_data**: The function of has_data is to determine whether the Request object contains any data.\n\n**parameters**: The parameters of this Function.\n· self: Refers to the instance of the Request class on which this method is called.\n\n**Code Description**:  \nThe has_data method checks if the data attribute of the Request object is not None. It returns True if the data attribute contains any value (i.e., is not None), and returns False if the data attribute is None. This method is typically used to verify whether the Request object has been provided with data, which is often relevant for HTTP methods like POST or PUT where data is sent in the request body.\n\n**Note**:  \n- This method only checks if the data attribute is not None. It does not verify the content or type of the data.\n- If the data attribute is an empty value (such as an empty string or empty bytes), but not None, has_data will still return True.\n\n**Output Example**:  \nIf the data attribute is set (e.g., self.data = \"example\"), has_data() returns:\nTrue\n\nIf the data attribute is not set (i.e., self.data = None), has_data() returns:\nFalse"
                },
                {
                    "method_name": "get_data",
                    "source_code": "def get_data(self):\n    return self.data",
                    "first_doc": "**get_data**: The function of get_data is to retrieve and return the value stored in the instance's data attribute.\n\n**parameters**: The parameters of this Function.\n· self: Refers to the instance of the class from which this method is called.\n\n**Code Description**:  \nThis method is designed to provide access to the data attribute of an instance. When called, it simply returns the current value of self.data. This is a typical getter method, used to encapsulate access to an internal variable, allowing other parts of the code to obtain the value of data without directly accessing the attribute. This approach supports the principles of encapsulation and data hiding in object-oriented programming.\n\n**Note**:  \n- The method assumes that the instance has a data attribute already set. If self.data is not defined, calling this method will result in an AttributeError.\n- No modification or processing is performed on the data; it is returned exactly as stored.\n- The type and content of the returned value depend entirely on what has been assigned to self.data elsewhere in the code.\n\n**Output Example**:  \nIf self.data contains the string \"example_data\", calling get_data() will return:\n\"example_data\"\n\nIf self.data contains a dictionary like {\"key\": \"value\"}, calling get_data() will return:\n{\"key\": \"value\"}"
                },
                {
                    "method_name": "get_full_url",
                    "source_code": "def get_full_url(self):\n    return self.__original",
                    "first_doc": "**get_full_url**: The function of get_full_url is to return the original URL associated with the Request object.\n\n**parameters**: The parameters of this Function.\n· self: Refers to the instance of the Request object from which the method is called.\n\n**Code Description**:  \nThis method retrieves the value stored in the private attribute __original of the Request object. The __original attribute is intended to hold the original URL that was used when the Request object was created. By calling get_full_url, users can access this original URL in its entirety, regardless of any modifications that may have occurred to the Request object after its initialization. The method does not perform any processing or validation; it simply returns the stored URL value.\n\n**Note**:  \n- The returned value is exactly what was stored in the __original attribute at the time of the Request object's creation.\n- This method does not accept any arguments other than self.\n- The method assumes that the __original attribute exists and contains a valid URL string.\n\n**Output Example**:  \nIf the original URL was \"http://example.com/resource\", calling get_full_url() will return:\n\"http://example.com/resource\""
                },
                {
                    "method_name": "get_type",
                    "source_code": "def get_type(self):\n    if self.type is None:\n        self.type, self.__r_type = splittype(self.__original)\n        if self.type is None:\n            raise(ValueError, \"unknown url type: %s\" % self.__original)\n    return self.type",
                    "first_doc": "**get_type**: The function of get_type is to determine and return the URL scheme (type) of the associated request.\n\n**parameters**: The parameters of this Function.\n· self: Refers to the instance of the Request object on which this method is called.\n\n**Code Description**:  \nThis method is responsible for extracting and returning the URL scheme (such as \"http\", \"https\", \"ftp\", etc.) from the original URL associated with the Request object. When called, it first checks if the type attribute of the instance is already set. If not, it uses the splittype function to parse the original URL (stored in self.__original) and extract the scheme part, which is then stored in self.type. If the URL does not contain a recognizable scheme, the method raises a ValueError indicating an unknown URL type.\n\nWithin the project, get_type is called by the open method of the OpenerDirector class. In this context, get_type is used to determine the protocol of the request so that the appropriate handler can be selected for opening the URL. The result of get_type directly influences which handler chain is invoked, ensuring that the request is processed according to its protocol.\n\n**Note**:  \n- If the URL does not contain a valid or recognizable scheme, a ValueError will be raised.\n- This method caches the result in self.type after the first call, improving efficiency for subsequent calls.\n- The method assumes that self.__original contains a valid URL string.\n\n**Output Example**:  \nIf the original URL is \"http://example.com\", the return value will be:\n\"http\""
                },
                {
                    "method_name": "get_host",
                    "source_code": "def get_host(self):\n    if self.host is None:\n        self.host, self.__r_host = splithost(self.__r_type)\n        if self.host:\n            self.host = unquote(self.host)\n    return self.host",
                    "first_doc": "**get_host**: The function of get_host is to retrieve and return the host component associated with the request.\n\n**parameters**: The parameters of this Function.\n· self: Refers to the instance of the class in which this method is defined.\n\n**Code Description**:  \nThis method checks whether the instance variable host is None. If it is None, it attempts to extract the host information by calling the splithost function with self.__r_type as its argument. The splithost function is expected to return a tuple, where the first element is assigned to self.host and the second to self.__r_host. If a host value is successfully extracted, it is then decoded using the unquote function to ensure any percent-encoded characters are properly converted to their standard representation. Finally, the method returns the value of self.host, which will either be the previously set host or the newly extracted and decoded host value.\n\n**Note**:  \n- This method relies on the existence and correct behavior of the splithost and unquote functions, as well as the presence of the instance variables host, __r_host, and __r_type.\n- If self.host is already set (not None), the method will return it directly without attempting to extract or decode it again.\n- The method assumes that splithost returns a tuple with at least two elements.\n\n**Output Example**:  \nIf the host is \"example.com\", the method will return:\nexample.com\n\nIf the host contains percent-encoded characters, such as \"example%2Ecom\", the method will return:\nexample.com"
                },
                {
                    "method_name": "get_selector",
                    "source_code": "def get_selector(self):\n    return self.__r_host",
                    "first_doc": "**get_selector**: The function of get_selector is to retrieve the value of the private attribute __r_host from the instance.\n\n**parameters**: The parameters of this Function.\n· None: This method does not accept any parameters.\n\n**Code Description**:  \nThe get_selector method is an instance method that returns the value stored in the private attribute __r_host of the object. This attribute is likely intended to represent a host or selector value associated with the instance, and the method provides controlled, read-only access to it. The use of double underscores before r_host indicates that the attribute is private and should not be accessed directly from outside the class. Instead, get_selector acts as a getter method, adhering to encapsulation principles.\n\n**Note**:  \n- This method does not modify any data; it only returns the value of __r_host.\n- The returned value depends on how __r_host was set during the object's initialization or through other internal methods.\n- Direct access to __r_host from outside the class is not recommended; always use get_selector for retrieval.\n\n**Output Example**:  \nIf __r_host was set to \"example.com\" during object creation, calling get_selector() will return:\n\"example.com\""
                },
                {
                    "method_name": "set_proxy",
                    "source_code": "def set_proxy(self, host, type):\n    self.host, self.type = host, type\n    self.__r_host = self.__original",
                    "first_doc": "**set_proxy**: The function of set_proxy is to configure the proxy settings for the Request object by specifying the proxy host and type.\n\n**parameters**: The parameters of this Function.\n· host: The address of the proxy server to be used for the request.\n· type: The type of the proxy (for example, \"http\", \"https\", etc.).\n\n**Code Description**:  \nThis function assigns the provided host and type values to the instance variables self.host and self.type, effectively setting the proxy server and its protocol type for the Request object. Additionally, it sets the instance variable self.__r_host to the value of self.__original. This likely serves to preserve or restore the original host information, ensuring that the original request host can be referenced or reverted to if needed after proxy settings are applied.\n\n**Note**:  \n- The function directly modifies instance variables, so it should be used with caution to avoid unintended side effects.\n- The variable self.__original must be defined elsewhere in the class for self.__r_host to be set correctly; otherwise, this may result in an AttributeError.\n- The function does not perform any validation on the host or type parameters, so it is the caller’s responsibility to ensure valid values are provided."
                },
                {
                    "method_name": "add_header",
                    "source_code": "def add_header(self, key, val):\n    # useful for something like authentication\n    self.headers[key] = val",
                    "first_doc": "**add_header**: The function of add_header is to add or update a header field in the request's headers dictionary.\n\n**parameters**: The parameters of this Function.\n· key: The name of the HTTP header to be added or updated.\n· val: The value to assign to the specified HTTP header.\n\n**Code Description**:  \nThis function allows the user to add a new HTTP header or update the value of an existing header in the request object. It takes two arguments: key, which specifies the header name, and val, which specifies the header value. The function assigns the value val to the headers dictionary at the position specified by key. This is particularly useful for scenarios such as setting authentication headers or customizing request metadata before sending an HTTP request.\n\n**Note**:  \n- If the specified header key already exists in the headers dictionary, its value will be overwritten with the new value provided.\n- The function does not perform any validation on the key or value; it assumes that both are valid and appropriate for use as HTTP header fields.\n- Proper use of this function is important for ensuring that HTTP requests contain all necessary headers, such as those required for authentication or content negotiation."
                }
            ]
        },
        {
            "type": "class",
            "name": "OpenerDirector",
            "methods": [
                {
                    "method_name": "__init__",
                    "source_code": "def __init__(self):\n    server_version = \"Python-urllib/%s\" % __version__\n    self.addheaders = [('User-agent', server_version)]\n    # manage the individual handlers\n    self.handlers = []\n    self.handle_open = {}\n    self.handle_error = {}",
                    "first_doc": "**__init__**: The function of __init__ is to initialize a new instance of the OpenerDirector class, setting up default headers and internal handler management structures.\n\n**parameters**: The parameters of this Function.\n· None\n\n**Code Description**:  \nThis method initializes the OpenerDirector object with default values and structures required for its operation. It sets up a default HTTP header, specifically the 'User-agent', which is constructed using the current Python urllib version. This header is stored in the addheaders attribute as a list of tuples, allowing for easy extension or modification of headers in future requests.\n\nThe method also initializes three important attributes for managing request handlers:\n- handlers: An empty list intended to store handler objects that will process different aspects of HTTP requests and responses.\n- handle_open: An empty dictionary that will be used to map protocol types to their corresponding open handlers.\n- handle_error: An empty dictionary that will be used to map protocol types to their corresponding error handlers.\n\nThese structures provide the foundation for the OpenerDirector to manage and delegate HTTP request and response handling to the appropriate handler objects.\n\n**Note**:  \n- This method does not accept any parameters and is intended to be called automatically when an OpenerDirector object is instantiated.\n- The addheaders attribute is initialized with a default 'User-agent' header, which can be modified as needed for custom user agent strings.\n- The handlers, handle_open, and handle_error attributes are essential for the extensibility and flexibility of the OpenerDirector, allowing it to support various protocols and error handling mechanisms through registered handler objects."
                },
                {
                    "method_name": "add_handler",
                    "source_code": "def add_handler(self, handler):\n    added = 0\n    for meth in dir(handler):\n        if meth[-5:] == '_open':\n            protocol = meth[:-5]\n            if self.handle_open.has_key(protocol):\n                self.handle_open[protocol].append(handler)\n            else:\n                self.handle_open[protocol] = [handler]\n            added = 1\n            continue\n        i = meth.find('_')\n        j = meth[i+1:].find('_') + i + 1\n        if j != -1 and meth[i+1:j] == 'error':\n            proto = meth[:i]\n            kind = meth[j+1:]\n            try:\n                kind = int(kind)\n            except ValueError:\n                pass\n            dict = self.handle_error.get(proto, {})\n            if dict.has_key(kind):\n                dict[kind].append(handler)\n            else:\n                dict[kind] = [handler]\n            self.handle_error[proto] = dict\n            added = 1\n            continue\n    if added:\n        self.handlers.append(handler)\n        handler.add_parent(self)",
                    "first_doc": "**add_handler**: The function of add_handler is to register a handler object with the OpenerDirector, enabling it to process specific protocols and error types during URL opening operations.\n\n**parameters**: The parameters of this Function.\n· handler: The handler object to be added to the OpenerDirector. This object should define methods for handling specific protocols or errors, following a naming convention.\n\n**Code Description**:  \nThe add_handler function is responsible for integrating a handler into the OpenerDirector's internal management system. It examines the handler object for methods that follow certain naming patterns, which indicate the handler's capabilities:\n\n- Methods ending with '_open' are interpreted as protocol handlers (e.g., 'http_open' for HTTP protocol). For each such method, the function extracts the protocol name and registers the handler under that protocol in the handle_open dictionary. If handlers for the protocol already exist, the new handler is appended to the list; otherwise, a new list is created.\n- Methods containing '_error_' are interpreted as error handlers for a specific protocol and error kind (e.g., 'http_error_404' for HTTP 404 errors). The function parses the protocol and error kind from the method name. It then updates the handle_error dictionary, ensuring that the handler is registered for the appropriate protocol and error kind. If the error kind can be converted to an integer, it is stored as such; otherwise, it remains a string.\n\nIf any handler methods are successfully registered (i.e., at least one protocol or error handler is found), the handler is appended to the handlers list maintained by the OpenerDirector. Additionally, the handler's add_parent method is called, passing the OpenerDirector instance as the parent. This establishes a reference from the handler back to its managing OpenerDirector, facilitating coordination and access to shared resources.\n\nWithin the project, add_handler is invoked by functions such as build_opener and OpenerFactory.build_opener. These functions construct an OpenerDirector and populate it with default and user-supplied handlers by calling add_handler for each handler. This modular approach allows the OpenerDirector to flexibly support various protocols and error handling strategies, depending on the registered handlers.\n\n**Note**:  \n- Handlers must follow the naming conventions for their methods ('<protocol>_open' for protocol handlers and '<protocol>_error_<kind>' for error handlers) to be recognized and registered correctly.\n- The handler is only added to the handlers list and assigned a parent if it provides at least one recognized handler method.\n- The add_parent method of the handler is called without validation, so the handler must implement this method to avoid errors.\n- The function does not remove or replace existing handlers for a protocol or error kind; it simply appends the new handler, allowing multiple handlers for the same protocol or error.\n- The dictionaries handle_open and handle_error are updated in place, ensuring that all registered handlers are available for protocol and error processing during URL operations."
                },
                {
                    "method_name": "__del__",
                    "source_code": "def __del__(self):\n    self.close()",
                    "first_doc": "**__del__**: The function of __del__ is to ensure that all resources managed by the OpenerDirector instance are properly released when the object is about to be destroyed.\n\n**parameters**: The parameters of this Function.\n· (none): This function does not take any parameters.\n\n**Code Description**:  \nThe __del__ method is a special method in Python that is automatically invoked when an instance of the OpenerDirector class is about to be garbage collected. In this implementation, __del__ calls the close method of the OpenerDirector instance. The close method is responsible for iterating through all handler objects managed by the OpenerDirector and invoking their close methods to release any resources or connections they may hold. After all handlers have been closed, the handlers list is cleared to remove references to these objects. By calling close within __del__, the class ensures that all associated handlers are properly cleaned up and that no resource leaks occur when the OpenerDirector instance is destroyed.\n\n**Note**:  \n- The __del__ method is automatically called by Python's garbage collector and should not be invoked directly.\n- Explicitly calling the close method is recommended if early cleanup of resources is required, as __del__ is only triggered when the object is about to be destroyed.\n- After __del__ (and thus close) has been executed, the handlers list will be empty, and further operations depending on handlers will not function as expected."
                },
                {
                    "method_name": "close",
                    "source_code": "def close(self):\n    for handler in self.handlers:\n        handler.close()\n    self.handlers = []",
                    "first_doc": "**close**: The function of close is to properly close and clean up all handler objects managed by the OpenerDirector instance.\n\n**parameters**: The parameters of this Function.\n· (none): This function does not take any parameters.\n\n**Code Description**:  \nThe close function iterates through all handler objects stored in the handlers attribute of the OpenerDirector instance and calls each handler's close method. This ensures that any resources or connections held by the handlers are released appropriately. After all handlers have been closed, the handlers list is cleared by assigning it to an empty list, effectively removing all references to the handler objects from the OpenerDirector.\n\nThis function is also invoked by the __del__ method of OpenerDirector, which means that when an OpenerDirector instance is about to be destroyed (garbage collected), close is automatically called to ensure that all handlers are closed and cleaned up. This helps prevent resource leaks and ensures proper management of system resources.\n\n**Note**:  \n- The close function should be called when the OpenerDirector instance is no longer needed to ensure all associated handlers are properly closed.\n- After calling close, the handlers list is emptied, so further operations that rely on the handlers may not function as expected.\n- Since close is also called during object destruction via __del__, explicit calls to close are generally only necessary if early cleanup is required."
                },
                {
                    "method_name": "_call_chain",
                    "source_code": "def _call_chain(self, chain, kind, meth_name, *args):\n    # XXX raise an exception if no one else should try to handle\n    # this url.  return None if you can't but someone else could.\n    handlers = chain.get(kind, ())\n    for handler in handlers:\n        func = getattr(handler, meth_name)\n\n        result = func(*args)\n        if result is not None:\n            return result",
                    "first_doc": "**_call_chain**: The function of _call_chain is to sequentially invoke a specified method on a chain of handler objects until one returns a non-None result.\n\n**parameters**: The parameters of this Function.\n· chain: A dictionary mapping handler types (such as 'default', protocol names, or error types) to sequences of handler objects.\n· kind: The key used to select the appropriate sequence of handlers from the chain dictionary.\n· meth_name: The name of the method to call on each handler in the selected sequence.\n· *args: Additional arguments to pass to the handler method being called.\n\n**Code Description**:  \nThis function is designed to facilitate the delegation of processing tasks to a series of handler objects, which are organized by type in the chain dictionary. The function retrieves the list of handlers associated with the specified kind. It then iterates through these handlers, dynamically obtaining the method named meth_name from each handler and invoking it with the provided arguments.\n\nIf a handler's method returns a non-None result, _call_chain immediately returns this result, effectively short-circuiting the chain. If all handlers return None, the function itself returns None, indicating that none of the handlers could process the request.\n\nWithin the project, _call_chain is used by higher-level methods such as open and error in the OpenerDirector class. In open, it is used to attempt to open a URL by calling the appropriate handler methods in sequence, first trying 'default', then the specific protocol, and finally 'unknown'. In error, it is used to process errors by invoking protocol-specific or default error handling methods on the handlers.\n\nThis design allows for flexible and extensible processing, where new handler types or methods can be added without modifying the core logic of the OpenerDirector.\n\n**Note**:  \n- The function expects that the handlers in the chain implement the method specified by meth_name.\n- If no handler returns a non-None result, the function returns None.\n- The function does not handle exceptions raised by handler methods; such exceptions will propagate to the caller.\n- The chain parameter must be a dictionary with handler sequences as values.\n\n**Output Example**:  \nIf a handler's method returns a value (for example, an HTTP response object or an error object), _call_chain returns that value immediately. If all handlers return None, the output will be None. For instance:\n\n- If a handler's default_open method returns a response object:  \n  <addinfourl at 0x7f1c8b2e3d60 whose fp = <socket._fileobject object at 0x7f1c8b2e3c90>>\n- If no handler can process the request:  \n  None"
                },
                {
                    "method_name": "open",
                    "source_code": "def open(self, fullurl, data=None):\n    # accept a URL or a Request object\n    if isinstance(fullurl, (types.StringType, types.UnicodeType)):\n        req = Request(fullurl, data)\n    else:\n        req = fullurl\n        if data is not None:\n            req.add_data(data)\n    assert isinstance(req, Request) # really only care about interface\n\n    result = self._call_chain(self.handle_open, 'default',\n                              'default_open', req)\n    if result:\n        return result\n\n    type_ = req.get_type()\n    result = self._call_chain(self.handle_open, type_, type_ + \\\n                              '_open', req)\n    if result:\n        return result\n\n    return self._call_chain(self.handle_open, 'unknown',\n                            'unknown_open', req)",
                    "first_doc": "**open**: The function of open is to process and open a given URL or Request object, returning the result of the appropriate handler in the OpenerDirector processing chain.\n\n**parameters**: The parameters of this Function.\n· fullurl: The URL to be opened, which can be either a string representing the URL or a Request object encapsulating all request details.\n· data: Optional data to be sent with the request, typically used for HTTP POST operations. If provided, it is attached to the Request object.\n\n**Code Description**:  \nThe open method is a central entry point for initiating network requests using the OpenerDirector. It accepts either a URL string or a pre-constructed Request object. If a string is provided, it constructs a new Request object using the provided URL and optional data. If a Request object is provided and data is not None, it updates the Request object by attaching the data payload using the add_data method.\n\nThe method ensures that the object being processed is a Request instance, which standardizes the interface for subsequent processing. It then attempts to handle the request using a chain of handler objects, following a specific order:\n\n1. It first calls _call_chain with the 'default' handler chain and the 'default_open' method, passing the Request object. If any handler in this chain returns a non-None result, that result is immediately returned.\n2. If the default chain does not handle the request, it determines the protocol type of the request (such as 'http', 'ftp', etc.) using the get_type method of the Request object. It then calls _call_chain with the protocol-specific handler chain and the corresponding open method (e.g., 'http_open', 'ftp_open').\n3. If neither the default nor the protocol-specific handlers process the request, it finally attempts to use the 'unknown' handler chain with the 'unknown_open' method.\n\nThe open method is widely used throughout the project. It is called directly by the urlopen function, which provides a simple interface for users to open URLs. It is also invoked by various handler methods (such as HTTPRedirectHandler's http_error_302, ProxyHandler's proxy_open, CustomProxyHandler's proxy_open and do_proxy, and FileHandler's file_open) to delegate or restart the request processing, often after modifying the Request object or handling specific protocol logic. This design ensures that all requests, regardless of their origin or modifications, are processed through a consistent and extensible handler chain.\n\n**Note**:  \n- The method expects either a string URL or a Request object as input. If a string is provided, it is automatically wrapped in a Request.\n- If data is provided alongside a Request object, it will overwrite any existing data in the Request.\n- The method relies on the handler chains (handle_open) being properly configured with handler objects that implement the required open methods.\n- If no handler processes the request, the method returns None.\n- Exceptions raised by handlers are not caught within open and will propagate to the caller.\n\n**Output Example**:  \nA typical return value is a response object appropriate to the protocol, such as an HTTP response object. For example:\n\n<addinfourl at 0x7f1c8b2e3d60 whose fp = <socket._fileobject object at 0x7f1c8b2e3c90>>\n\nIf no handler can process the request, the return value will be:\n\nNone"
                },
                {
                    "method_name": "error",
                    "source_code": "def error(self, proto, *args):\n    if proto in ['http', 'https']:\n        # XXX http[s] protocols are special-cased\n        dict = self.handle_error['http'] # https is not different than http\n        proto = args[2]  # YUCK!\n        meth_name = 'http_error_%d' % proto\n        http_err = 1\n        orig_args = args\n    else:\n        dict = self.handle_error\n        meth_name = proto + '_error'\n        http_err = 0\n    args = (dict, proto, meth_name) + args\n    result = self._call_chain(*args)\n    if result:\n        return result\n\n    if http_err:\n        args = (dict, 'default', 'http_error_default') + orig_args\n        return self._call_chain(*args)",
                    "first_doc": "**error**: The function of error is to delegate error handling to the appropriate handler methods based on the protocol and error context, returning the first non-None result from the handler chain.\n\n**parameters**: The parameters of this Function.\n· proto: The protocol string (such as 'http', 'https', or another protocol identifier) that indicates the context in which the error occurred.\n· *args: Additional arguments relevant to the error, typically including request and response objects, error codes, and messages.\n\n**Code Description**:  \nThe error function is responsible for managing error handling within the OpenerDirector class. When an error occurs during a protocol operation (such as an HTTP request), this function determines the correct handler method to invoke based on the protocol and error details.\n\nFor HTTP and HTTPS protocols, the function treats them as equivalent and uses the 'http' entry in the handle_error dictionary. It extracts the HTTP error code from the arguments and constructs a method name in the format http_error_<code> (for example, http_error_404). It then attempts to call this method on each handler in the relevant handler chain using the _call_chain method. The _call_chain function iterates through the handlers and invokes the specified method, returning the first non-None result.\n\nIf no handler returns a result for the specific HTTP error code, the function falls back to a default HTTP error handler (http_error_default) by calling _call_chain again with the 'default' key and the original arguments.\n\nFor other protocols, the function constructs a method name in the format <proto>_error and attempts to call this method on the handlers using _call_chain. If no handler returns a result, the function returns None.\n\nWithin the project, the error function is called by methods such as do_open in AbstractHTTPHandler. For example, if an HTTP request does not return a 200 status code, do_open calls error to process the error using the appropriate handler methods. This design allows for extensible and protocol-specific error handling, enabling new error handlers to be added without modifying the core logic.\n\n**Note**:  \n- The function relies on the handle_error dictionary to map protocol or error types to handler chains.\n- For HTTP and HTTPS, the error code is expected as the third argument in *args.\n- If no handler returns a non-None result, the function returns None, indicating that the error was not handled.\n- The function does not handle exceptions raised by handler methods; such exceptions will propagate to the caller.\n- The function is designed to be extensible, allowing new protocols or error handlers to be integrated seamlessly.\n\n**Output Example**:  \nIf an HTTP 404 error occurs and a handler's http_error_404 method returns a response object, the function returns that object, for example:\n<addinfourl at 0x7f1c8b2e3d60 whose fp = <socket._fileobject object at 0x7f1c8b2e3c90>>\n\nIf no handler processes the error, the function returns:\nNone"
                }
            ]
        },
        {
            "type": "class",
            "name": "BaseHandler",
            "methods": [
                {
                    "method_name": "add_parent",
                    "source_code": "def add_parent(self, parent):\n    self.parent = parent",
                    "first_doc": "**add_parent**: The function of add_parent is to assign a parent object to the current handler instance.\n\n**parameters**: The parameters of this Function.\n· parent: The object that will be set as the parent of the current handler instance.\n\n**Code Description**:  \nThis function sets the parent attribute of the handler instance to the provided parent object. It is used to establish a reference from the handler back to its managing or owning object, typically for coordination or access to shared resources. In the context of the project, add_parent is called by the add_handler method of the OpenerDirector class. When a handler is added to the OpenerDirector, add_parent is invoked to link the handler back to the OpenerDirector instance. This allows the handler to access its parent director if needed during its operation.\n\n**Note**:  \n- The parent attribute is overwritten each time add_parent is called, so only the most recent parent assignment is retained.\n- This method does not perform any validation or checks on the parent parameter; it simply assigns it.\n- Proper use of add_parent ensures that handlers maintain a reference to their managing OpenerDirector, which may be necessary for certain handler operations or callbacks."
                },
                {
                    "method_name": "close",
                    "source_code": "def close(self):\n    self.parent = None",
                    "first_doc": "**close**: The function of close is to disassociate the handler from its parent by setting the parent attribute to None.\n\n**parameters**: The parameters of this Function.\n· self: Refers to the instance of the BaseHandler class.\n\n**Code Description**:  \nThis function is designed to remove the reference to the parent object from the current handler instance. By assigning None to self.parent, it ensures that the handler no longer maintains a link to its parent, which can be important for cleanup operations or to prevent circular references that could interfere with garbage collection. This method does not take any arguments besides self and does not return any value.\n\n**Note**:  \nAfter calling close, the handler will not have access to its parent object. Any subsequent operations that depend on the parent attribute should be avoided or handled appropriately to prevent errors. This method is typically used as part of resource management or cleanup routines."
                }
            ]
        },
        {
            "type": "class",
            "name": "HTTPDefaultErrorHandler",
            "methods": [
                {
                    "method_name": "http_error_default",
                    "source_code": "def http_error_default(self, req, fp, code, msg, hdrs):\n    raise HTTPError(req.get_full_url(), code, msg, hdrs, fp)",
                    "first_doc": "**http_error_default**: The function of http_error_default is to handle HTTP error responses by raising an HTTPError exception with detailed information about the error.\n\n**parameters**: The parameters of this Function.\n· self: The instance of the handler class invoking this method.\n· req: The request object that triggered the HTTP error.\n· fp: A file-like object containing the body of the error response.\n· code: The HTTP status code returned by the server (e.g., 404, 500).\n· msg: The error message returned by the HTTP server.\n· hdrs: The HTTP headers included in the error response.\n\n**Code Description**:  \nThe http_error_default method is designed to be invoked when an HTTP response is received with a status code indicating an error (typically 4xx or 5xx). Its primary responsibility is to raise an HTTPError exception, providing the calling code with comprehensive details about the error encountered.\n\nWhen called, http_error_default constructs an HTTPError instance using the provided parameters:\n- The full URL of the request is obtained via req.get_full_url().\n- The HTTP status code, error message, headers, and the file-like object containing the response body are passed directly to the HTTPError constructor.\n\nThe HTTPError class, which is raised by this method, encapsulates all relevant information about the HTTP error, including the status code, message, headers, and response body. This allows higher-level code to catch the HTTPError exception and inspect its attributes for error handling, logging, or recovery purposes. The HTTPError also behaves like a response object, enabling access to the error response's headers and body if needed.\n\nThis method is typically used within HTTP handler classes to provide a consistent mechanism for propagating HTTP errors up the call stack, ensuring that all necessary context is preserved and accessible.\n\n**Note**:  \n- The method always raises an HTTPError and does not return a value.\n- The file-like object fp should be managed carefully to avoid resource leaks; the HTTPError class attempts to close fp when the exception is destroyed, but if fp is extracted and used elsewhere, it is the caller's responsibility to close it.\n- This method provides a standard way to handle unexpected HTTP status codes, ensuring that error information is not lost and can be programmatically inspected."
                }
            ]
        },
        {
            "type": "class",
            "name": "HTTPRedirectHandler",
            "methods": [
                {
                    "method_name": "http_error_302",
                    "source_code": "def http_error_302(self, req, fp, code, msg, headers):\n    if headers.has_key('location'):\n        newurl = headers['location']\n    elif headers.has_key('uri'):\n        newurl = headers['uri']\n    else:\n        return\n    newurl = urlparse.urljoin(req.get_full_url(), newurl)\n\n    # XXX Probably want to forget about the state of the current\n    # request, although that might interact poorly with other\n    # handlers that also use handler-specific request attributes\n    new = Request(newurl, req.get_data())\n    new.error_302_dict = {}\n    if hasattr(req, 'error_302_dict'):\n        if len(req.error_302_dict)>10 or \\\n           req.error_302_dict.has_key(newurl):\n            raise HTTPError(req.get_full_url(), code,\n                            self.inf_msg + msg, headers, fp)\n        new.error_302_dict.update(req.error_302_dict)\n    new.error_302_dict[newurl] = newurl\n\n    # Don't close the fp until we are sure that we won't use it\n    # with HTTPError.\n    fp.read()\n    fp.close()\n\n    return self.parent.open(new)",
                    "first_doc": "**http_error_302**: The function of http_error_302 is to handle HTTP 302 (Found) redirect responses by constructing and initiating a new HTTP request to the redirected URL, or raising an HTTPError if redirect conditions are not met.\n\n**parameters**: The parameters of this Function.\n· self: The instance of the HTTPRedirectHandler handling the redirect.\n· req: The original Request object that triggered the 302 response.\n· fp: The file-like object containing the response body from the server.\n· code: The HTTP status code (expected to be 302).\n· msg: The HTTP status message associated with the response.\n· headers: The headers returned with the HTTP 302 response.\n\n**Code Description**:  \nThe http_error_302 function is responsible for processing HTTP 302 redirect responses. When a server responds with a 302 status code, it typically includes a 'Location' or 'URI' header indicating the new URL to which the client should redirect. This function first checks for the presence of these headers in the response. If neither is found, the function returns without further action.\n\nIf a redirect URL is found, it is resolved to an absolute URL using urlparse.urljoin, combining the original request URL with the new location. A new Request object is then created for this URL, carrying over the data payload from the original request.\n\nTo prevent infinite redirect loops and excessive redirection, the function maintains an error_302_dict attribute on the Request object. If the original request already has this attribute, it checks whether the number of redirects exceeds 10 or if the new URL has already been visited in this redirect chain. If either condition is true, an HTTPError is raised, halting the redirection process. Otherwise, the redirect history is updated and attached to the new Request.\n\nBefore proceeding, the function reads and closes the original response file pointer (fp) to ensure that resources are properly released. Finally, it delegates the new request to the parent handler's open method, which processes the new request as part of the standard handler chain.\n\nThis function interacts closely with the Request class (for constructing new requests and managing redirect history), the HTTPError class (for raising errors when redirect limits are exceeded), and the parent handler's open method (for continuing the request processing chain).\n\n**Note**:  \n- The function enforces a maximum of 10 redirects to prevent infinite loops.\n- If the redirect target URL has already been visited in the current redirect chain, an HTTPError is raised to avoid cyclic redirects.\n- The response file pointer (fp) is always read and closed before initiating the new request to ensure proper resource management.\n- The function only processes redirects when a 'location' or 'uri' header is present; otherwise, it does nothing.\n- The redirect history is tracked using the error_302_dict attribute on the Request object.\n\n**Output Example**:  \nIf a redirect is successfully followed, the function returns the result of self.parent.open(new), which is typically a response object for the new URL, such as:\n\n<addinfourl at 0x7f1c8b2e3d60 whose fp = <socket._fileobject object at 0x7f1c8b2e3c90>>\n\nIf the redirect limit is exceeded or a cyclic redirect is detected, an HTTPError is raised, which can be caught and inspected by the caller. For example:\n\nHTTP Error 302: Found\n\nThe HTTPError instance will contain details such as the original URL, status code, message, headers, and the response body."
                }
            ]
        },
        {
            "type": "class",
            "name": "ProxyHandler",
            "methods": [
                {
                    "method_name": "__init__",
                    "source_code": "def __init__(self, proxies=None):\n    if proxies is None:\n        proxies = getproxies()\n    assert hasattr(proxies, 'has_key'), \"proxies must be a mapping\"\n    self.proxies = proxies\n    for type, url in proxies.items():\n        setattr(self, '%s_open' % type,\n                lambda r, proxy=url, type=type, meth=self.proxy_open: \\\n                meth(r, proxy, type))",
                    "first_doc": "**__init__**: The function of __init__ is to initialize a ProxyHandler instance by configuring proxy settings and dynamically assigning protocol-specific open methods for handling requests through proxies.\n\n**parameters**: The parameters of this Function.\n· proxies: A mapping object (such as a dictionary) that specifies proxy URLs for different protocols (e.g., {'http': 'http://proxy.example.com:8080'}). If not provided, system proxy settings are used by default.\n\n**Code Description**:  \nThis method initializes the ProxyHandler by setting up the internal proxy configuration and preparing the handler to process requests for various protocols through the specified proxies. If the proxies parameter is not provided, it retrieves the system's proxy settings using getproxies(). It then asserts that the proxies object supports the has_key method, ensuring it behaves like a mapping.\n\nThe proxies mapping is stored in the instance variable self.proxies. For each protocol type and its corresponding proxy URL in the proxies mapping, the method dynamically creates and assigns a method to the ProxyHandler instance. These methods are named in the format '{type}_open' (for example, 'http_open', 'https_open'), and each is a lambda function that, when called, invokes the proxy_open method with the appropriate request object, proxy URL, and protocol type.\n\nThe proxy_open method, which is assigned as the handler for each protocol, is responsible for configuring requests to use the specified proxy, handling proxy authentication, and delegating further processing as needed. This dynamic assignment allows the ProxyHandler to support multiple protocols and ensures that requests for each protocol are routed through the correct proxy server.\n\n**Note**:  \n- The proxies parameter must be a mapping object; otherwise, an assertion error will be raised.\n- If proxies is not provided, system proxy settings are automatically used.\n- For each protocol specified in the proxies mapping, a corresponding open method is dynamically created and attached to the ProxyHandler instance.\n- The dynamically assigned open methods delegate request handling to the proxy_open method, which manages proxy configuration and authentication.\n- This design allows the ProxyHandler to flexibly support multiple protocols and proxy configurations within the same instance."
                },
                {
                    "method_name": "proxy_open",
                    "source_code": "def proxy_open(self, req, proxy, type):\n    orig_type = req.get_type()\n    type, r_type = splittype(proxy)\n    host, XXX = splithost(r_type)\n    if '@' in host:\n        user_pass, host = host.split('@', 1)\n        user_pass = base64.encodestring(unquote(user_pass)).strip()\n        req.add_header('Proxy-Authorization', 'Basic '+user_pass)\n    host = unquote(host)\n    req.set_proxy(host, type)\n    if orig_type == type:\n        # let other handlers take care of it\n        # XXX this only makes sense if the proxy is before the\n        # other handlers\n        return None\n    else:\n        # need to start over, because the other handlers don't\n        # grok the proxy's URL type\n        return self.parent.open(req)",
                    "first_doc": "**proxy_open**: The function of proxy_open is to configure a Request object to use a specified proxy server and handle proxy authentication if necessary.\n\n**parameters**: The parameters of this Function.\n· req: The Request object that is to be processed and potentially modified to use a proxy.\n· proxy: The proxy URL string, which may include authentication credentials.\n· type: The protocol type (such as 'http', 'https', etc.) for which the proxy is being set.\n\n**Code Description**:  \nThe proxy_open method is responsible for preparing a network request to be routed through a proxy server. It is typically invoked as part of the ProxyHandler's dynamic method assignment, where protocol-specific open methods (such as http_open, https_open, etc.) are set to call proxy_open with the appropriate parameters.\n\nThe method begins by recording the original protocol type of the request using req.get_type(). It then parses the proxy URL using splittype and splithost to extract the protocol type and host information. If the host portion of the proxy URL contains user authentication information (indicated by the presence of '@'), it separates the user credentials from the host, decodes and base64-encodes them, and adds a 'Proxy-Authorization' header to the request for HTTP Basic authentication.\n\nAfter handling authentication, the host is unquoted to ensure it is in a usable format, and the request is configured to use the proxy by calling req.set_proxy with the host and protocol type.\n\nThe method then determines whether the original request type matches the proxy type. If they are the same, it returns None, allowing other handlers in the processing chain to handle the request. If the types differ, it restarts the request processing by delegating to self.parent.open(req), which re-invokes the handler chain from the beginning with the modified request. This ensures that the correct handler processes the request according to the proxy's protocol.\n\nWithin the project, proxy_open is dynamically assigned as the handler for various protocol types in the ProxyHandler's __init__ method. It is also a direct caller of the OpenerDirector's open method, which manages the overall request processing and handler delegation.\n\n**Note**:  \n- The proxy URL may include user credentials for authentication, which are automatically handled and added to the request headers.\n- If the protocol type of the proxy matches the original request, proxy_open does not process the request further and returns None, allowing other handlers to proceed.\n- If the protocol types differ, the request is restarted using the parent OpenerDirector's open method to ensure proper handling.\n- The method expects the proxy URL to be correctly formatted and may raise exceptions if parsing fails.\n- The function modifies the request in-place by adding headers and setting proxy information.\n\n**Output Example**:  \nIf the proxy type matches the original request type, the function returns:\n\nNone\n\nIf the proxy type differs, the function returns the result of self.parent.open(req), which is typically a response object such as:\n\n<addinfourl at 0x7f1c8b2e3d60 whose fp = <socket._fileobject object at 0x7f1c8b2e3c90>>\n\nThis response object represents the result of the network request processed through the proxy."
                }
            ]
        },
        {
            "type": "class",
            "name": "CustomProxy",
            "methods": [
                {
                    "method_name": "__init__",
                    "source_code": "def __init__(self, proto, func=None, proxy_addr=None):\n    self.proto = proto\n    self.func = func\n    self.addr = proxy_addr",
                    "first_doc": "**__init__**: The function of __init__ is to initialize a new instance of the CustomProxy class with specified protocol, function, and proxy address.\n\n**parameters**: The parameters of this Function.\n· proto: The protocol to be used by the proxy (for example, 'http', 'https', etc.).\n· func: An optional function associated with the proxy. Defaults to None if not provided.\n· proxy_addr: The address of the proxy server. Defaults to None if not provided.\n\n**Code Description**:  \nThis constructor method sets up the initial state of a CustomProxy object. It assigns the provided proto argument to the instance variable self.proto, which determines the protocol the proxy will use. The func argument, which is optional, is stored in self.func and can be used to associate a callable or handler with the proxy instance. The proxy_addr argument, also optional, is stored in self.addr and represents the address of the proxy server. If func or proxy_addr are not provided during instantiation, they will default to None, indicating that no function or proxy address is associated with the instance by default.\n\n**Note**:  \nAll three parameters are instance-specific and must be set appropriately when creating a new CustomProxy object. If func or proxy_addr are not needed, they can be omitted, and their values will default to None. This constructor does not perform any validation or processing of the input parameters; it simply assigns them to the instance attributes."
                },
                {
                    "method_name": "handle",
                    "source_code": "def handle(self, req):\n    if self.func and self.func(req):\n        return 1",
                    "first_doc": "**handle**: The function of handle is to process a given request object using a user-defined function and return 1 if the function evaluates the request as True.\n\n**parameters**: The parameters of this Function.\n· req: The request object that will be processed by the user-defined function.\n\n**Code Description**:  \nThe handle function checks if a user-defined function (referenced as self.func) exists. If self.func is present, it is called with the req parameter. If self.func(req) returns a truthy value, handle returns 1. If self.func is not set or self.func(req) evaluates to False, the function does not return anything (implicitly returns None). This design allows for flexible handling of requests based on custom logic provided by the user.\n\n**Note**:  \n- The self.func attribute must be set to a callable that accepts a single argument (the request object).\n- If self.func is not set, or if it returns a falsy value, handle will return None.\n- The function always returns either 1 or None, depending on the evaluation of self.func(req).\n\n**Output Example**:  \nIf self.func is a function that returns True when req is a specific value:\n- handle(\"example_request\") → 1 (if self.func(\"example_request\") returns True)\n- handle(\"other_request\") → None (if self.func(\"other_request\") returns False)"
                },
                {
                    "method_name": "get_proxy",
                    "source_code": "def get_proxy(self):\n    return self.addr",
                    "first_doc": "**get_proxy**: The function of get_proxy is to return the proxy address associated with the current instance.\n\n**parameters**: The parameters of this Function.\n· self: Refers to the instance of the class from which this method is called.\n\n**Code Description**:  \nThis method is designed to provide access to the proxy address stored within the instance. When called, it simply returns the value of the instance variable addr. This variable is expected to hold the proxy address that the instance represents or manages. The method does not perform any additional processing, validation, or transformation of the addr value; it acts as a straightforward accessor (getter) for this property.\n\n**Note**:  \n- The correctness and existence of the addr attribute must be ensured before calling this method; otherwise, an AttributeError may be raised.\n- This method does not modify any data or perform any side effects.\n- The return value is entirely dependent on the value assigned to self.addr during the instance's lifecycle.\n\n**Output Example**:  \nIf the instance's addr attribute is set to \"192.168.1.100:8080\", calling get_proxy() will return:\n\"192.168.1.100:8080\""
                }
            ]
        },
        {
            "type": "class",
            "name": "CustomProxyHandler",
            "methods": [
                {
                    "method_name": "__init__",
                    "source_code": "def __init__(self, *proxies):\n    self.proxies = {}",
                    "first_doc": "**__init__**: The function of __init__ is to initialize a new instance of the CustomProxyHandler class.\n\n**parameters**: The parameters of this Function.\n· *proxies: A variable-length argument list intended to accept proxy configurations.\n\n**Code Description**:  \nThis method serves as the constructor for the CustomProxyHandler class. When an instance of this class is created, the __init__ method is called automatically. It accepts any number of positional arguments through *proxies, but does not process or store these arguments directly. Instead, it initializes an instance attribute named proxies as an empty dictionary. This attribute is likely intended to store proxy configuration data for the handler, but at this stage, it is simply set to an empty dictionary with no further logic or assignment.\n\n**Note**:  \n- The *proxies parameter is not used within the method body, so any values passed to it will be ignored during initialization.\n- The proxies attribute is always initialized as an empty dictionary, regardless of the arguments provided.\n- Further logic for handling proxies is expected to be implemented elsewhere in the class."
                },
                {
                    "method_name": "proxy_open",
                    "source_code": "def proxy_open(self, req):\n    proto = req.get_type()\n    try:\n        proxies = self.proxies[proto]\n    except KeyError:\n        return None\n    for p in proxies:\n        if p.handle(req):\n            req.set_proxy(p.get_proxy())\n            return self.parent.open(req)\n    return None",
                    "first_doc": "**proxy_open**: The function of proxy_open is to process a network request through a list of configured proxy handlers and, if a suitable proxy is found, forward the request using that proxy.\n\n**parameters**: The parameters of this Function.\n· req: The Request object representing the network request to be processed. This object encapsulates all details of the request, including the protocol type and any associated data.\n\n**Code Description**:  \nThe proxy_open method is responsible for determining whether a given network request should be routed through a proxy server, based on the protocol type of the request. It operates as follows:\n\n1. The method retrieves the protocol type (such as 'http', 'https', etc.) from the Request object by calling req.get_type().\n2. It attempts to look up a list of proxy handler objects associated with this protocol in the self.proxies dictionary. If no proxies are configured for the protocol (KeyError), the method returns None, indicating that proxy processing is not applicable for this request.\n3. If proxies are found, the method iterates through each proxy handler object in the list. For each proxy handler:\n   - It calls the handle method of the proxy handler, passing the Request object. If handle returns True, this indicates that the proxy handler is suitable for processing the request.\n   - The method then sets the proxy for the request by calling req.set_proxy with the proxy address obtained from p.get_proxy().\n   - After configuring the request to use the proxy, the method delegates the actual network operation to its parent object's open method (self.parent.open(req)). This ensures that the request is processed through the standard handler chain, but now routed via the selected proxy.\n   - The result of self.parent.open(req) is immediately returned, which is typically a response object.\n4. If none of the proxy handlers in the list accept the request, the method returns None, indicating that no proxy processing was performed.\n\nThis method is typically used within a custom proxy handling class that manages multiple proxy configurations. It integrates with the broader request processing system by leveraging the parent object's open method, ensuring consistent handling of requests whether or not a proxy is used.\n\n**Note**:  \n- The method only processes requests for which a proxy is configured for the request's protocol type.\n- If no proxy handler accepts the request, or if no proxies are configured for the protocol, the method returns None, allowing other handlers in the processing chain to handle the request.\n- The method modifies the Request object by setting the proxy before delegating to the parent handler.\n- The parent object must implement an open method compatible with the request processing system.\n\n**Output Example**:  \nA typical return value is a response object resulting from the request being processed through the selected proxy, such as:\n\n<addinfourl at 0x7f1c8b2e3d60 whose fp = <socket._fileobject object at 0x7f1c8b2e3c90>>\n\nIf no suitable proxy is found or applicable, the return value will be:\n\nNone"
                },
                {
                    "method_name": "do_proxy",
                    "source_code": "def do_proxy(self, p, req):\n    return self.parent.open(req)",
                    "first_doc": "**do_proxy**: The function of do_proxy is to delegate the processing of a proxied request to the parent OpenerDirector's open method.\n\n**parameters**: The parameters of this Function.\n· p: Represents the proxy information or configuration, though it is not used within the function body.\n· req: The Request object that encapsulates all details of the network request to be processed.\n\n**Code Description**:  \nThe do_proxy method is designed to handle network requests that require proxy processing. It takes two parameters: p, which typically contains proxy-related information, and req, which is a Request object representing the network request. Within the method, only the req parameter is utilized. The method directly calls self.parent.open(req), passing the Request object to the parent OpenerDirector's open method for further processing.\n\nThe open method of OpenerDirector is responsible for managing the entire request handling process. It determines the appropriate handler chain based on the request type and delegates the request to the correct handler, ensuring that all protocol-specific and default handlers are considered. By calling self.parent.open(req), do_proxy ensures that the request is processed through the standard handler chain, which may include proxy handling, authentication, redirects, and protocol-specific logic.\n\nThis design allows do_proxy to act as a simple forwarding mechanism, ensuring that any modifications or requirements related to proxy handling are respected by the broader request processing infrastructure managed by OpenerDirector.\n\n**Note**:  \n- The p parameter is present for interface compatibility but is not used in the method body.\n- The req parameter must be a valid Request object.\n- The method relies on the parent attribute being correctly set to an instance of OpenerDirector.\n- Any exceptions raised during request processing by the parent open method will propagate to the caller.\n- The return value depends on the outcome of the parent open method and the handler chain configuration.\n\n**Output Example**:  \nA typical return value is a protocol-specific response object, such as:\n\n<addinfourl at 0x7f1c8b2e3d60 whose fp = <socket._fileobject object at 0x7f1c8b2e3c90>>\n\nIf no handler processes the request, the return value will be:\n\nNone"
                },
                {
                    "method_name": "add_proxy",
                    "source_code": "def add_proxy(self, cpo):\n    if self.proxies.has_key(cpo.proto):\n        self.proxies[cpo.proto].append(cpo)\n    else:\n        self.proxies[cpo.proto] = [cpo]",
                    "first_doc": "**add_proxy**: The function of add_proxy is to add a proxy object to the internal proxies dictionary, organizing proxies by their protocol type.\n\n**parameters**: The parameters of this Function.\n· cpo: A proxy object that contains at least a proto attribute, representing the protocol type (such as 'http', 'https', etc.).\n\n**Code Description**:  \nThis function manages a collection of proxy objects within the proxies dictionary, grouping them by their protocol type. When add_proxy is called with a proxy object (cpo), it checks if the protocol type (cpo.proto) already exists as a key in the proxies dictionary. If the protocol exists, the function appends the new proxy object to the existing list of proxies for that protocol. If the protocol does not exist, it creates a new list containing the proxy object and assigns it to the corresponding protocol key in the dictionary. This ensures that multiple proxies can be managed and retrieved based on their protocol type.\n\n**Note**:  \n- The function assumes that the proxies attribute is a dictionary and that each value is a list of proxy objects.\n- The cpo parameter must have a proto attribute; otherwise, the function will raise an AttributeError.\n- The use of has_key is specific to Python 2 and is not compatible with Python 3, where the in operator should be used instead."
                }
            ]
        },
        {
            "type": "class",
            "name": "HTTPPasswordMgr",
            "methods": [
                {
                    "method_name": "__init__",
                    "source_code": "def __init__(self):\n    self.passwd = {}",
                    "first_doc": "**__init__**: The function of __init__ is to initialize a new instance of the HTTPPasswordMgr class by setting up its internal password storage.\n\n**parameters**: The parameters of this Function.\n· self: Refers to the instance of the HTTPPasswordMgr class being created.\n\n**Code Description**:  \nThis function serves as the constructor for the HTTPPasswordMgr class. When an instance of this class is created, the __init__ method is automatically called. Inside this method, an instance variable named passwd is initialized as an empty dictionary. This dictionary is intended to store password information, likely mapping authentication realms or URLs to their corresponding credentials. By initializing passwd as an empty dictionary, the class is prepared to store and manage multiple sets of credentials as needed during its usage.\n\n**Note**:  \n- The passwd dictionary is empty upon initialization and will need to be populated by other methods in the class.\n- This method does not accept any arguments other than self and does not perform any validation or processing beyond setting up the empty dictionary.\n- Proper usage of this class requires understanding how credentials are added to and retrieved from the passwd dictionary in subsequent methods."
                },
                {
                    "method_name": "add_password",
                    "source_code": "def add_password(self, realm, uri, user, passwd):\n    # uri could be a single URI or a sequence\n    if isinstance(uri, (types.StringType, types.UnicodeType)):\n        uri = [uri]\n    uri = tuple(map(self.reduce_uri, uri))\n    if not self.passwd.has_key(realm):\n        self.passwd[realm] = {}\n    self.passwd[realm][uri] = (user, passwd)",
                    "first_doc": "**add_password**: The function of add_password is to store user credentials (username and password) associated with a specific authentication realm and one or more URIs for HTTP authentication management.\n\n**parameters**: The parameters of this Function.\n· realm: The authentication realm as a string, typically provided by the server to define a protected area.\n· uri: A single URI string or a sequence of URI strings that specify the protected resources to which the credentials apply.\n· user: The username as a string to be used for authentication.\n· passwd: The password as a string corresponding to the username.\n\n**Code Description**:  \nThe add_password method is responsible for registering a set of user credentials (user and passwd) for a given authentication realm and one or more URIs. If the uri parameter is a single string, it is converted into a list to ensure uniform handling. Each URI is then processed using the reduce_uri method, which extracts and normalizes the network location (netloc) and path components, returning them as tuples. This normalization ensures that credentials are stored and later retrieved in a consistent manner, regardless of the URI format provided.\n\nThe method maintains an internal dictionary, self.passwd, where credentials are organized first by realm and then by the tuple of reduced URIs. If the specified realm does not already exist in the dictionary, it is initialized as an empty dictionary. The credentials (user, passwd) are then stored under the key corresponding to the tuple of reduced URIs within the realm.\n\nWithin the project, add_password is exposed as a method of HTTPPasswordMgr and is also made available through AbstractBasicAuthHandler and AbstractDigestAuthHandler classes, allowing authentication handlers to register credentials for use in HTTP authentication workflows. The reduce_uri method, called internally, ensures that only the relevant parts of each URI are used as keys, supporting reliable credential lookup.\n\n**Note**:  \n- The uri parameter can be either a single string or a sequence of strings; the method handles both cases.\n- The reduce_uri method is used to standardize URIs before storing them, which is important for consistent credential management.\n- Credentials are organized by realm and by the reduced form of URIs, allowing for precise matching during authentication.\n- This method does not perform any validation on the credentials or URIs; it simply stores them for later retrieval."
                },
                {
                    "method_name": "find_user_password",
                    "source_code": "def find_user_password(self, realm, authuri):\n    domains = self.passwd.get(realm, {})\n    authuri = self.reduce_uri(authuri)\n    for uris, authinfo in domains.items():\n        for uri in uris:\n            if self.is_suburi(uri, authuri):\n                return authinfo\n    return None, None",
                    "first_doc": "**find_user_password**: The function of find_user_password is to retrieve the username and password associated with a given authentication realm and URI, if such credentials have been registered.\n\n**parameters**: The parameters of this Function.\n· realm: A string representing the authentication realm for which credentials are sought.\n· authuri: A string representing the URI or network location requiring authentication.\n\n**Code Description**:  \nThis function is designed to look up user credentials (username and password) for HTTP authentication based on a specified realm and URI. It operates as follows:\n\n1. It accesses the internal password storage (self.passwd), which is organized by realm. For the provided realm, it retrieves the associated domains dictionary. If the realm is not present, an empty dictionary is used.\n2. The input authuri is normalized using the reduce_uri method. This ensures that only the relevant network location and path components are considered, providing a consistent basis for comparison.\n3. The function iterates through each entry in the domains dictionary. Each entry consists of a set of URIs (uris) and the corresponding authentication information (authinfo), typically a tuple of (username, password).\n4. For each URI in uris, the function checks whether the normalized authuri is a sub-URI of the stored URI using the is_suburi method. This determines if the requested URI falls within the scope of the stored credentials.\n5. If a match is found, the corresponding authentication information (username, password) is returned immediately.\n6. If no matching credentials are found after checking all entries, the function returns (None, None).\n\nThis method is called by authentication handlers such as retry_http_basic_auth and get_authorization, which use it to retrieve the appropriate credentials for HTTP Basic and Digest authentication challenges, respectively. The function relies on reduce_uri to standardize URIs and on is_suburi to accurately determine URI hierarchy relationships.\n\n**Note**:  \n- The function returns a tuple (username, password) if credentials are found, or (None, None) if no matching credentials exist.\n- Both reduce_uri and is_suburi must be used consistently to ensure correct matching of URIs.\n- The function assumes that credentials have been previously registered and organized by realm and URI.\n\n**Output Example**:  \nIf credentials for realm \"example-realm\" and URI \"http://example.com/protected\" exist and match, the function might return:\n('user123', 'pass456')\n\nIf no credentials match the given realm and URI, the function returns:\n(None, None)"
                },
                {
                    "method_name": "reduce_uri",
                    "source_code": "def reduce_uri(self, uri):\n    \"\"\"Accept netloc or URI and extract only the netloc and path\"\"\"\n    parts = urlparse.urlparse(uri)\n    if parts[1]:\n        return parts[1], parts[2] or '/'\n    else:\n        return parts[2], '/'",
                    "first_doc": "**reduce_uri**: The function of reduce_uri is to extract and return only the network location (netloc) and path components from a given URI or netloc string.\n\n**parameters**: The parameters of this Function.\n· uri: A string representing either a full URI or just a network location (netloc).\n\n**Code Description**:  \nThis function processes the input parameter uri, which may be a complete URI or simply a netloc. It uses the urlparse.urlparse method to decompose the input into its constituent parts. The function then checks if the parsed result contains a non-empty netloc (parts[1]). If so, it returns a tuple containing the netloc and the path (parts[2]), defaulting the path to '/' if it is empty. If the netloc is empty, it returns the path as the first element and '/' as the second element.\n\nWithin the project, reduce_uri is used by the add_password and find_user_password methods of the HTTPPasswordMgr class. In add_password, reduce_uri is applied to each URI provided, ensuring that only the relevant netloc and path information are stored as keys for password management. In find_user_password, reduce_uri is used to normalize the authentication URI before searching for matching credentials, ensuring consistent comparison and retrieval.\n\n**Note**:  \n- The function always returns a tuple of two elements: (netloc, path). If the input does not contain a netloc, the first element will be the path, and the second will be '/'.\n- This function expects the input to be a string representing either a URI or a netloc.\n- The function relies on urlparse.urlparse, so the input should be formatted in a way that urlparse can interpret.\n\n**Output Example**:  \nFor input 'http://example.com/foo/bar', the function returns ('example.com', '/foo/bar').  \nFor input 'example.com', the function returns ('example.com', '/').  \nFor input '/foo/bar', the function returns ('/foo/bar', '/')."
                },
                {
                    "method_name": "is_suburi",
                    "source_code": "def is_suburi(self, base, test):\n    \"\"\"Check if test is below base in a URI tree\n\n    Both args must be URIs in reduced form.\n    \"\"\"\n    if base == test:\n        return 1\n    if base[0] != test[0]:\n        return 0\n    common = posixpath.commonprefix((base[1], test[1]))\n    if len(common) == len(base[1]):\n        return 1\n    return 0",
                    "first_doc": "**is_suburi**: The function of is_suburi is to determine whether a given URI (test) is a sub-URI of another base URI (base) within a URI hierarchy.\n\n**parameters**: The parameters of this Function.\n· base: The base URI, expected to be in reduced form (typically a tuple or similar structure).\n· test: The URI to be tested, also in reduced form.\n\n**Code Description**:  \nThis function checks if the test URI is hierarchically below the base URI. It first compares the two URIs for exact equality; if they are the same, it returns 1 (indicating a match). If the first elements of the base and test URIs differ (often representing the scheme or authority), it returns 0, indicating they are not related. Otherwise, it computes the common prefix of the second elements of both URIs using posixpath.commonprefix. If the length of this common prefix matches the length of the base URI's second element, it means the test URI is within the subtree of the base URI, and the function returns 1. Otherwise, it returns 0.\n\nWithin the project, is_suburi is used by the find_user_password method of the HTTPPasswordMgr class. In that context, is_suburi helps determine if a given authentication URI falls under any registered URI domains for a particular authentication realm, thereby assisting in the retrieval of the correct user credentials.\n\n**Note**:  \n- Both base and test must be in reduced URI form as expected by the function's logic.\n- The function returns integer values: 1 for true (test is a sub-URI of base), 0 for false.\n- The comparison is sensitive to the structure and format of the URIs provided.\n\n**Output Example**:  \nIf base = ('http', '/example/path') and test = ('http', '/example/path/subpage'), the function returns 1.  \nIf base = ('http', '/example/path') and test = ('http', '/other/path'), the function returns 0.  \nIf base = ('http', '/example/path') and test = ('https', '/example/path'), the function returns 0."
                }
            ]
        },
        {
            "type": "class",
            "name": "HTTPPasswordMgrWithDefaultRealm",
            "methods": [
                {
                    "method_name": "find_user_password",
                    "source_code": "def find_user_password(self, realm, authuri):\n    user, password = HTTPPasswordMgr.find_user_password(self,realm,authuri)\n    if user is not None:\n        return user, password\n    return HTTPPasswordMgr.find_user_password(self, None, authuri)",
                    "first_doc": "**find_user_password**: The function of find_user_password is to retrieve the username and password associated with a given authentication realm and URI, with a fallback to a default realm if no credentials are found for the specified realm.\n\n**parameters**: The parameters of this Function.\n· realm: The authentication realm as a string. This identifies the protected area on the server for which credentials are being requested.\n· authuri: The URI (Uniform Resource Identifier) as a string for which the credentials are needed.\n\n**Code Description**:  \nThis function attempts to find the appropriate user credentials for HTTP authentication by first searching for credentials that match both the provided realm and URI. It does this by calling the find_user_password method of the parent HTTPPasswordMgr class, which checks for credentials stored under the specified realm and matches the URI using normalization and sub-URI logic.\n\nIf credentials (user, password) are found for the given realm and URI, they are immediately returned. If no credentials are found (i.e., the user is None), the function performs a fallback search by calling the parent class's find_user_password method again, this time with the realm set to None. This allows the function to retrieve credentials that may have been stored without an explicit realm, effectively providing a default set of credentials for the given URI.\n\nThis approach ensures that the function first attempts to use the most specific credentials (those tied to a particular realm) and only falls back to more general credentials (those without a realm) if necessary. This behavior is particularly useful in scenarios where some servers may not specify a realm, or where a default set of credentials should be used when no realm-specific credentials are available.\n\n**Note**:  \n- The function relies on the underlying logic of HTTPPasswordMgr for URI normalization and sub-URI matching.\n- If neither a realm-specific nor a default credential is found, the function will return (None, None).\n- This method is typically used in HTTP authentication handlers that need to support both realm-specific and default credentials.\n\n**Output Example**:  \nIf credentials for the realm 'example-realm' and URI 'http://example.com/protected' exist, a call such as:\nfind_user_password('example-realm', 'http://example.com/protected/resource')\nmight return:\n('user1', 'pass1')\n\nIf no credentials are found for the specified realm but default credentials exist for the URI, the function might return:\n('default_user', 'default_pass')\n\nIf no credentials are found at all, the function will return:\n(None, None)"
                }
            ]
        },
        {
            "type": "class",
            "name": "AbstractBasicAuthHandler",
            "methods": [
                {
                    "method_name": "__init__",
                    "source_code": "def __init__(self, password_mgr=None):\n    if password_mgr is None:\n        password_mgr = HTTPPasswordMgr()\n    self.passwd = password_mgr\n    self.add_password = self.passwd.add_password",
                    "first_doc": "**__init__**: The function of __init__ is to initialize an instance of AbstractBasicAuthHandler with an optional password manager for handling HTTP authentication credentials.\n\n**parameters**: The parameters of this Function.\n· password_mgr: An optional parameter representing a password manager object responsible for storing and retrieving HTTP authentication credentials. If not provided, a new instance of HTTPPasswordMgr is created by default.\n\n**Code Description**:  \nThis constructor sets up the AbstractBasicAuthHandler by configuring its credential management system. If the password_mgr parameter is not supplied during instantiation, the constructor creates a new HTTPPasswordMgr object. This ensures that the handler always has a valid password manager for storing and retrieving authentication credentials.\n\nThe password manager instance is assigned to the self.passwd attribute, making it accessible throughout the handler for credential operations. Additionally, the add_password method from the password manager is directly exposed as self.add_password. This allows users of AbstractBasicAuthHandler to conveniently add credentials using the handler instance, which internally delegates the operation to the underlying password manager.\n\nThe HTTPPasswordMgr class, used as the default password manager, provides mechanisms for organizing credentials by authentication realm and URI, supporting efficient storage and retrieval. The add_password method of HTTPPasswordMgr, which is exposed by AbstractBasicAuthHandler, allows credentials to be registered for specific realms and URIs, ensuring that authentication challenges can be met with the appropriate user information.\n\n**Note**:  \n- If no password manager is provided, a new HTTPPasswordMgr instance is created automatically.\n- The add_password method can be used directly on the handler instance to register credentials, simplifying credential management.\n- The password manager only stores credentials in memory for the lifetime of the handler instance; it does not persist them beyond that.\n- This initialization ensures that the handler is always ready to manage HTTP authentication credentials, either with a custom or default password manager."
                },
                {
                    "method_name": "http_error_auth_reqed",
                    "source_code": "def http_error_auth_reqed(self, authreq, host, req, headers):\n    # XXX could be multiple headers\n    authreq = headers.get(authreq, None)\n    if authreq:\n        mo = AbstractBasicAuthHandler.rx.match(authreq)\n        if mo:\n            scheme, realm = mo.groups()\n            if scheme.lower() == 'basic':\n                return self.retry_http_basic_auth(host, req, realm)",
                    "first_doc": "**http_error_auth_reqed**: The function of http_error_auth_reqed is to handle HTTP authentication challenges by detecting and processing authentication headers in HTTP responses, and initiating a retry of the request with appropriate credentials if Basic authentication is required.\n\n**parameters**: The parameters of this Function.\n· authreq: The name of the authentication header to look for in the response (e.g., 'www-authenticate' or 'proxy-authenticate').\n· host: The network location (host) for which authentication is being requested.\n· req: The HTTP request object that triggered the authentication challenge.\n· headers: The headers from the HTTP response, which may contain authentication challenges.\n\n**Code Description**:  \nThis function is responsible for responding to HTTP authentication challenges, such as those indicated by HTTP 401 (Unauthorized) or 407 (Proxy Authentication Required) responses. It operates as follows:\n\n1. It retrieves the value of the specified authentication header (authreq) from the response headers. This header typically contains the authentication scheme and realm required by the server or proxy.\n2. If the authentication header is present, the function uses a regular expression (rx) defined in the AbstractBasicAuthHandler class to parse the header and extract the authentication scheme and realm.\n3. If the scheme extracted from the header is 'Basic' (case-insensitive), the function calls retry_http_basic_auth, passing the host, request object, and realm. This initiates a retry of the HTTP request with the appropriate Basic Authorization header, provided that credentials are available.\n4. If the authentication scheme is not 'Basic', or if the header is not present or does not match the expected format, the function does not attempt authentication and returns None.\n\nThis function is called by higher-level handlers such as http_error_401 in HTTPBasicAuthHandler and http_error_407 in ProxyBasicAuthHandler. These handlers are triggered when the server or proxy responds with an authentication-required status code. By delegating to http_error_auth_reqed, they centralize the logic for handling authentication challenges and retries.\n\nThe function also serves as a bridge to retry_http_basic_auth, which performs the actual credential lookup, header construction, and request retry if credentials are available for the specified realm and host.\n\n**Note**:  \n- The function only processes authentication challenges that use the 'Basic' scheme; other authentication schemes are ignored.\n- It assumes that the authentication header contains a single challenge; handling of multiple challenges is not implemented.\n- The function relies on the presence of a correctly formatted authentication header and a matching regular expression for parsing.\n- If credentials are not available or the authentication scheme is not 'Basic', the function returns None, and authentication does not proceed.\n\n**Output Example**:  \nIf a Basic authentication challenge is detected and credentials are available, the function returns the result of retry_http_basic_auth, which is typically an HTTP response object after a successful retry. If no credentials are available or the challenge is not for Basic authentication, the function returns None. For example:\n\n- When authentication is attempted and succeeds:\n  <HTTPResponse object at 0x...>\n- When no authentication is attempted or credentials are missing:\n  None"
                },
                {
                    "method_name": "retry_http_basic_auth",
                    "source_code": "def retry_http_basic_auth(self, host, req, realm):\n    user,pw = self.passwd.find_user_password(realm, host)\n    if pw:\n        raw = \"%s:%s\" % (user, pw)\n        auth = 'Basic %s' % base64.encodestring(raw).strip()\n        if req.headers.get(self.auth_header, None) == auth:\n            return None\n        req.add_header(self.auth_header, auth)\n        return self.parent.open(req)\n    else:\n        return None",
                    "first_doc": "**retry_http_basic_auth**: The function of retry_http_basic_auth is to attempt HTTP Basic authentication by retrieving stored credentials for a given host and realm, and then resending the HTTP request with the appropriate Authorization header if credentials are available.\n\n**parameters**: The parameters of this Function.\n· host: The network location (host) for which authentication is required.\n· req: The HTTP request object that needs to be authenticated.\n· realm: The authentication realm as specified by the server.\n\n**Code Description**:  \nThis function is responsible for handling HTTP Basic authentication retries when an authentication challenge is received from a server. It operates as follows:\n\n1. It calls the find_user_password method of the passwd object to retrieve the username and password associated with the specified realm and host. This method searches for credentials that have been previously registered for the given realm and host combination.\n2. If a password is found (i.e., credentials are available), the function constructs a string in the format \"username:password\".\n3. This string is then base64-encoded to comply with the HTTP Basic authentication specification.\n4. The encoded credentials are formatted into the Authorization header as \"Basic <encoded_credentials>\".\n5. Before adding the Authorization header to the request, the function checks if the request already contains the same Authorization header value. If it does, the function returns None to avoid redundant authentication attempts.\n6. If the header is not present or differs, the Authorization header is added to the request.\n7. The function then delegates the request to the parent object's open method, which resends the HTTP request with the new Authorization header.\n8. If no credentials are found for the given realm and host, the function returns None, indicating that authentication cannot proceed.\n\nThis function is typically invoked by higher-level authentication error handlers, such as http_error_auth_reqed, when a server responds with an authentication challenge (e.g., HTTP 401 Unauthorized). The retry_http_basic_auth function provides the mechanism to respond to such challenges by supplying the correct credentials if they are available.\n\n**Note**:  \n- The function only proceeds if a password is found for the specified realm and host; otherwise, it returns None.\n- It avoids sending duplicate Authorization headers by checking if the header is already set to the intended value.\n- The function assumes that credentials have been previously registered and are accessible via the passwd object.\n- The Authorization header is constructed according to the HTTP Basic authentication standard, using base64 encoding.\n\n**Output Example**:  \nIf credentials for the specified realm and host are found and the request does not already contain the correct Authorization header, the function returns the result of self.parent.open(req), which is typically an HTTP response object. If credentials are not found or the header is already set, the function returns None. For example:\n\n- When credentials are found and authentication is attempted:\n  <HTTPResponse object at 0x...>\n- When no credentials are found or the header is already present:\n  None"
                }
            ]
        },
        {
            "type": "class",
            "name": "HTTPBasicAuthHandler",
            "methods": [
                {
                    "method_name": "http_error_401",
                    "source_code": "def http_error_401(self, req, fp, code, msg, headers):\n    host = urlparse.urlparse(req.get_full_url())[1]\n    return self.http_error_auth_reqed('www-authenticate',\n                                      host, req, headers)",
                    "first_doc": "**http_error_401**: The function of http_error_401 is to handle HTTP 401 Unauthorized errors by initiating the authentication process for resources that require Basic authentication.\n\n**parameters**: The parameters of this function are as follows.\n· req: The HTTP request object that triggered the 401 Unauthorized response.\n· fp: The file-like object representing the response body (not used in this function).\n· code: The HTTP status code received (expected to be 401).\n· msg: The HTTP status message associated with the response (not used in this function).\n· headers: The headers from the HTTP response, which may contain authentication challenges.\n\n**Code Description**:  \nThis function is specifically designed to process HTTP 401 Unauthorized responses, which indicate that the requested resource requires user authentication. When invoked, the function performs the following steps:\n\n1. It extracts the host component from the URL of the original request using urlparse.urlparse and retrieves the network location (host) from the parsed result.\n2. It delegates the actual authentication handling to the http_error_auth_reqed method, passing the following arguments:\n   - The string 'www-authenticate', which specifies the HTTP header where authentication challenges are expected.\n   - The extracted host, which identifies the server requiring authentication.\n   - The original request object (req).\n   - The response headers, which may contain the authentication challenge.\n3. The http_error_auth_reqed method, as implemented in the parent class, inspects the 'www-authenticate' header in the response. If the header indicates a Basic authentication challenge and credentials are available, it retries the request with the appropriate Authorization header. If not, it returns None.\n\nBy delegating to http_error_auth_reqed, http_error_401 centralizes the logic for handling authentication challenges, ensuring consistent processing of 401 responses that require Basic authentication.\n\n**Note**:  \n- This function only initiates authentication for Basic authentication schemes as handled by http_error_auth_reqed.\n- The function does not process the response body or status message directly.\n- If the authentication challenge is not for Basic authentication, or if credentials are unavailable, the function returns None and does not retry the request.\n\n**Output Example**:  \n- If Basic authentication is required and credentials are available, the function returns a new HTTP response object after a successful retry:\n  <HTTPResponse object at 0x...>\n- If authentication is not attempted or credentials are missing, the function returns:\n  None"
                }
            ]
        },
        {
            "type": "class",
            "name": "ProxyBasicAuthHandler",
            "methods": [
                {
                    "method_name": "http_error_407",
                    "source_code": "def http_error_407(self, req, fp, code, msg, headers):\n    host = req.get_host()\n    return self.http_error_auth_reqed('proxy-authenticate',\n                                      host, req, headers)",
                    "first_doc": "**http_error_407**: The function of http_error_407 is to handle HTTP 407 Proxy Authentication Required responses by initiating the appropriate authentication process for proxy servers.\n\n**parameters**: The parameters of this Function.\n· req: The HTTP request object that triggered the 407 response.\n· fp: The file-like object representing the response body from the server.\n· code: The HTTP status code (expected to be 407 in this context).\n· msg: The HTTP status message associated with the response.\n· headers: The headers from the HTTP response, which may contain proxy authentication challenges.\n\n**Code Description**:  \nThis function is specifically designed to process HTTP 407 responses, which indicate that the client must authenticate itself with a proxy server before the request can be fulfilled. Upon receiving such a response, the function performs the following steps:\n\n1. It retrieves the host information from the original request object using req.get_host(). This host represents the proxy server that requires authentication.\n2. It delegates the handling of the authentication challenge to the http_error_auth_reqed method, passing the following arguments:\n   - The string 'proxy-authenticate', which specifies the header in the response that contains the proxy authentication challenge.\n   - The host extracted from the request.\n   - The original request object.\n   - The response headers.\n3. The http_error_auth_reqed method then processes the authentication challenge by checking for the presence of the 'proxy-authenticate' header, parsing it, and, if the challenge uses the 'Basic' authentication scheme, attempting to retry the request with the appropriate credentials.\n\nBy delegating to http_error_auth_reqed, http_error_407 centralizes the logic for handling proxy authentication challenges, ensuring consistent processing and credential management across different parts of the authentication system.\n\n**Note**:  \n- This function is specifically intended for handling HTTP 407 responses related to proxy authentication.\n- It relies on the presence and correct formatting of the 'proxy-authenticate' header in the response.\n- Only 'Basic' authentication schemes are processed; other schemes are ignored by the underlying handler.\n- If credentials are not available or the authentication scheme is not supported, the function will not attempt authentication and will return None.\n\n**Output Example**:  \n- If proxy authentication is attempted and succeeds, the function returns the result of the retried request, typically an HTTP response object:\n  <HTTPResponse object at 0x...>\n- If authentication is not attempted or fails due to missing credentials or unsupported schemes, the function returns:\n  None"
                }
            ]
        },
        {
            "type": "class",
            "name": "AbstractDigestAuthHandler",
            "methods": [
                {
                    "method_name": "__init__",
                    "source_code": "def __init__(self, passwd=None):\n    if passwd is None:\n        passwd = HTTPPasswordMgr()\n    self.passwd = passwd\n    self.add_password = self.passwd.add_password",
                    "first_doc": "**__init__**: The function of __init__ is to initialize an instance of the AbstractDigestAuthHandler class, setting up its password management system.\n\n**parameters**: The parameters of this Function.\n· passwd: An optional parameter representing a password manager object. If not provided, a new instance of HTTPPasswordMgr is created and used by default.\n\n**Code Description**:  \nThe __init__ method is responsible for setting up the password management mechanism for the AbstractDigestAuthHandler instance. If the passwd parameter is not supplied during instantiation, the method creates a new HTTPPasswordMgr object to manage HTTP authentication credentials. This ensures that the handler always has a valid password manager available for storing and retrieving authentication information.\n\nThe passwd attribute of the instance is set to the provided or newly created HTTPPasswordMgr object. Additionally, the add_password method of the password manager is directly assigned to the add_password attribute of the handler instance. This allows users of AbstractDigestAuthHandler to conveniently add credentials using the handler's add_password method, which internally delegates to the password manager's add_password implementation. The HTTPPasswordMgr class manages credentials by organizing them according to authentication realms and normalized URIs, supporting reliable credential storage and retrieval for HTTP authentication workflows.\n\n**Note**:  \n- If no password manager is provided, a new HTTPPasswordMgr instance is automatically created, ensuring the handler is always ready to manage credentials.\n- The add_password method exposed by the handler is the same as that of the underlying password manager, allowing direct addition of credentials.\n- The password manager only stores credentials in memory for the lifetime of the handler instance and does not persist them."
                },
                {
                    "method_name": "http_error_auth_reqed",
                    "source_code": "def http_error_auth_reqed(self, authreq, host, req, headers):\n    authreq = headers.get(self.auth_header, None)\n    if authreq:\n        kind = authreq.split()[0]\n        if kind == 'Digest':\n            return self.retry_http_digest_auth(req, authreq)",
                    "first_doc": "**http_error_auth_reqed**: The function of http_error_auth_reqed is to handle HTTP authentication-required errors by detecting authentication challenges in response headers and initiating the appropriate authentication retry process, specifically for HTTP Digest Authentication.\n\n**parameters**: The parameters of this Function.\n· authreq: The name of the authentication header to check (e.g., 'www-authenticate' or 'proxy-authenticate').\n· host: The host for which authentication is being requested.\n· req: The HTTP request object that triggered the authentication challenge.\n· headers: The headers returned by the server in response to the request.\n\n**Code Description**:  \nThis function is responsible for processing HTTP responses that indicate an authentication requirement, such as HTTP 401 (Unauthorized) or HTTP 407 (Proxy Authentication Required). When such a response is received, http_error_auth_reqed examines the relevant authentication header in the response headers (as specified by self.auth_header, which is typically set to either 'www-authenticate' or 'proxy-authenticate' depending on the context).\n\nIf the specified authentication header is present in the response headers, the function extracts its value and determines the authentication scheme by splitting the header value and inspecting the first word. If the scheme is 'Digest', indicating that HTTP Digest Authentication is required, the function delegates the authentication retry process to retry_http_digest_auth. This delegated function constructs a new request with the appropriate Digest Authorization header and attempts to resend the request to the server.\n\nWithin the project, http_error_auth_reqed is called by methods handling specific HTTP error codes:\n- HTTPDigestAuthHandler.http_error_401 calls http_error_auth_reqed when a 401 Unauthorized response is received, passing 'www-authenticate' as the authreq parameter.\n- ProxyDigestAuthHandler.http_error_407 calls http_error_auth_reqed when a 407 Proxy Authentication Required response is received, passing 'proxy-authenticate' as the authreq parameter.\n\nBy centralizing the logic for handling authentication-required errors, http_error_auth_reqed ensures that the correct authentication mechanism is triggered based on the server's challenge, and that the retry process is handled consistently.\n\n**Note**:  \n- This function only processes Digest authentication challenges; other authentication schemes are ignored.\n- The function relies on the presence and correct naming of the authentication header in the response headers.\n- It does not handle the actual construction of the Authorization header or the resending of the request; these tasks are delegated to retry_http_digest_auth.\n- If the authentication header is not present or does not indicate Digest authentication, the function does not perform any further action.\n\n**Output Example**:  \nIf a Digest authentication challenge is present and processed, the function returns the result of retry_http_digest_auth, which is typically an HTTP response object if authentication is retried successfully, or None if no retry is performed. For example:\n- On successful authentication retry: `<HTTPResponse object at 0x...>`\n- If no Digest challenge is present or no retry occurs: `None`"
                },
                {
                    "method_name": "retry_http_digest_auth",
                    "source_code": "def retry_http_digest_auth(self, req, auth):\n    token, challenge = auth.split(' ', 1)\n    chal = parse_keqv_list(parse_http_list(challenge))\n    auth = self.get_authorization(req, chal)\n    if auth:\n        auth_val = 'Digest %s' % auth\n        if req.headers.get(self.auth_header, None) == auth_val:\n            return None\n        req.add_header(self.auth_header, auth_val)\n        resp = self.parent.open(req)\n        return resp",
                    "first_doc": "**retry_http_digest_auth**: The function of retry_http_digest_auth is to handle HTTP Digest Authentication retries by constructing and sending a new request with the appropriate Authorization header when a Digest authentication challenge is received.\n\n**parameters**: The parameters of this Function.\n· req: The HTTP request object that requires authentication.\n· auth: The authentication challenge string received from the server, typically starting with \"Digest\" followed by challenge parameters.\n\n**Code Description**:  \nThis function is responsible for responding to HTTP Digest Authentication challenges encountered during HTTP requests. When a server responds with a 401 Unauthorized status and a Digest authentication challenge, this function is invoked (for example, by the http_error_auth_reqed method) to attempt authentication using the provided challenge.\n\nThe process begins by splitting the auth string into a token and a challenge. The challenge portion is parsed using parse_http_list to handle comma-separated values and quoted strings according to HTTP standards. The resulting list is then converted into a dictionary of key-value pairs using parse_keqv_list, making it easy to access individual challenge parameters such as realm, nonce, and algorithm.\n\nWith the parsed challenge, the function calls get_authorization, which constructs the value for the HTTP Digest Authorization header based on the request and challenge details. If get_authorization returns a valid header value, the function prepares the full Authorization header by prefixing it with \"Digest \" and checks if this value is already present in the request headers to avoid redundant authentication attempts.\n\nIf the header is not already set, the function adds the Authorization header to the request and re-sends the request using the parent handler's open method. The response from this retried request is then returned. If the Authorization header is already present and matches the one that would be generated, the function returns None, indicating that no further authentication attempt should be made.\n\nThis function is a critical part of the HTTP Digest Authentication workflow, ensuring that authentication retries are handled transparently and securely by constructing and sending requests with the correct credentials and cryptographic responses.\n\n**Note**:  \n- The function only proceeds if a valid Authorization header can be generated; otherwise, it does not retry authentication.\n- It avoids infinite authentication loops by checking if the Authorization header is already present and matches the one that would be generated.\n- The function relies on helper methods (parse_http_list, parse_keqv_list, get_authorization) to correctly interpret the server's challenge and construct the appropriate header.\n- It is typically called internally by error-handling routines when a Digest authentication challenge is encountered.\n\n**Output Example**:  \nIf the authentication is successful, the function returns the HTTP response object resulting from the retried request with the Authorization header set. If the header is already present or cannot be generated, it returns None. For example:\n\n- On successful retry: `<HTTPResponse object at 0x...>`\n- If no retry is performed: `None`"
                },
                {
                    "method_name": "get_authorization",
                    "source_code": "def get_authorization(self, req, chal):\n    try:\n        realm = chal['realm']\n        nonce = chal['nonce']\n        algorithm = chal.get('algorithm', 'MD5')\n        # mod_digest doesn't send an opaque, even though it isn't\n        # supposed to be optional\n        opaque = chal.get('opaque', None)\n    except KeyError:\n        return None\n\n    H, KD = self.get_algorithm_impls(algorithm)\n    if H is None:\n        return None\n\n    user, pw = self.passwd.find_user_password(realm,\n                                              req.get_full_url())\n    if user is None:\n        return None\n\n    # XXX not implemented yet\n    if req.has_data():\n        entdig = self.get_entity_digest(req.get_data(), chal)\n    else:\n        entdig = None\n\n    A1 = \"%s:%s:%s\" % (user, realm, pw)\n    A2 = \"%s:%s\" % (req.has_data() and 'POST' or 'GET',\n                    # XXX selector: what about proxies and full urls\n                    req.get_selector())\n    respdig = KD(H(A1), \"%s:%s\" % (nonce, H(A2)))\n    # XXX should the partial digests be encoded too?\n\n    base = 'username=\"%s\", realm=\"%s\", nonce=\"%s\", uri=\"%s\", ' \\\n           'response=\"%s\"' % (user, realm, nonce, req.get_selector(),\n                              respdig)\n    if opaque:\n        base = base + ', opaque=\"%s\"' % opaque\n    if entdig:\n        base = base + ', digest=\"%s\"' % entdig\n    if algorithm != 'MD5':\n        base = base + ', algorithm=\"%s\"' % algorithm\n    return base",
                    "first_doc": "**get_authorization**: The function of get_authorization is to construct the HTTP Digest Authentication header value for a given request and server challenge.\n\n**parameters**: The parameters of this Function.\n· req: The HTTP request object for which the Authorization header is being generated.\n· chal: A dictionary representing the server's authentication challenge, typically containing keys such as 'realm', 'nonce', 'algorithm', and optionally 'opaque'.\n\n**Code Description**:  \nThis function generates the value for the HTTP Digest Authorization header in response to a server's authentication challenge. It is a core component of the Digest Authentication process, ensuring that the client provides the correct credentials and cryptographic response as specified by the HTTP Digest Access Authentication protocol.\n\nThe function proceeds as follows:\n\n1. It extracts required fields from the challenge dictionary: 'realm' (the authentication realm), 'nonce' (a server-supplied unique value), and 'algorithm' (the hash algorithm, defaulting to 'MD5' if not specified). The optional 'opaque' field is also retrieved if present.\n2. If any of the required fields ('realm' or 'nonce') are missing, the function returns None, indicating that it cannot generate the header.\n3. It calls get_algorithm_impls with the specified algorithm to obtain two functions: H (the hash function) and KD (the key derivation function). If the algorithm is unsupported, the function returns None.\n4. The function retrieves the username and password for the specified realm and request URL by calling find_user_password on the internal password manager. If no credentials are found, it returns None.\n5. If the request contains entity data (such as in a POST request), get_entity_digest is called to compute the digest of the entity body. Currently, this always returns None, as entity digest support is not implemented.\n6. The function constructs the A1 and A2 strings as specified by the Digest Authentication protocol:\n   - A1 is a concatenation of the username, realm, and password.\n   - A2 is a concatenation of the HTTP method ('POST' or 'GET', depending on whether the request has data) and the request selector (the path component of the URL).\n7. The response digest (respdig) is computed using the KD and H functions, combining the hashed A1, the nonce, and the hashed A2.\n8. The base Authorization header value is assembled, including the username, realm, nonce, URI, and response digest. If the 'opaque' value is present in the challenge, it is included. If an entity digest is available, it is also included. If the algorithm is not 'MD5', it is explicitly stated in the header.\n9. The constructed header value is returned as a string.\n\nThis function is called by retry_http_digest_auth, which handles HTTP Digest Authentication retries. It is also dependent on helper methods such as get_algorithm_impls (for cryptographic operations), find_user_password (for credential lookup), and get_entity_digest (for entity body digest, though not currently implemented).\n\n**Note**:  \n- The function returns None if any required challenge fields are missing, the algorithm is unsupported, or credentials are not found.\n- Only 'MD5' and 'SHA' algorithms are supported for digest computation.\n- Entity digest support is not implemented; the digest field will be omitted from the header.\n- The function assumes that the request object provides methods such as get_full_url(), get_selector(), has_data(), and get_data().\n- The output is a string suitable for use in the HTTP Authorization header, but does not include the 'Digest ' prefix.\n\n**Output Example**:  \nA typical return value might look like:\nusername=\"user123\", realm=\"example-realm\", nonce=\"abc123\", uri=\"/protected\", response=\"098f6bcd4621d373cade4e832627b4f6\", opaque=\"xyz789\", algorithm=\"MD5\"\n\nIf the 'opaque' or 'algorithm' fields are not present, they will be omitted. If the function cannot generate the header, it returns None."
                },
                {
                    "method_name": "get_algorithm_impls",
                    "source_code": "def get_algorithm_impls(self, algorithm):\n    # lambdas assume digest modules are imported at the top level\n    if algorithm == 'MD5':\n        H = lambda x, e=encode_digest:e(md5.new(x).digest())\n    elif algorithm == 'SHA':\n        H = lambda x, e=encode_digest:e(sha.new(x).digest())\n    # XXX MD5-sess\n    KD = lambda s, d, H=H: H(\"%s:%s\" % (s, d))\n    return H, KD",
                    "first_doc": "**get_algorithm_impls**: The function of get_algorithm_impls is to provide hash and key derivation functions tailored to the specified digest algorithm for HTTP Digest Authentication.\n\n**parameters**: The parameters of this Function.\n· algorithm: A string indicating the name of the digest algorithm to use (e.g., 'MD5' or 'SHA').\n\n**Code Description**:  \nThis function returns two callable objects, H and KD, that implement the core cryptographic operations required for HTTP Digest Authentication, based on the specified algorithm.\n\n- When the algorithm parameter is 'MD5', H is defined as a lambda function that takes an input string x, computes its MD5 hash using md5.new(x).digest(), and then encodes the resulting binary digest into a lowercase hexadecimal string using the encode_digest function.\n- When the algorithm parameter is 'SHA', H is similarly defined, but it uses the SHA hash function (sha.new(x).digest()) before encoding the digest with encode_digest.\n- The KD function is always defined as a lambda that takes two strings, s and d, and applies H to the string \"%s:%s\" % (s, d), effectively producing a keyed digest as required by the HTTP Digest Authentication protocol.\n\nThe encode_digest function, which is used internally, converts the binary output of the hash functions into a hexadecimal string, ensuring compatibility with HTTP authentication headers.\n\nWithin the project, get_algorithm_impls is called by the get_authorization method of AbstractDigestAuthHandler. In that context, it provides the necessary hash and key derivation functions to compute the response digest for HTTP Digest Authentication, based on the algorithm specified in the server challenge.\n\n**Note**:  \n- Only 'MD5' and 'SHA' algorithms are explicitly supported. If another algorithm is provided, the function will not define H, which may lead to errors in the calling code.\n- The function assumes that the md5 and sha modules are imported and available at the top level.\n- The encode_digest function expects the digest to be a string of bytes, which is typical for Python 2.x. Adaptation may be necessary for Python 3.x environments.\n- The function does not currently handle the 'MD5-sess' algorithm or other advanced digest algorithms.\n\n**Output Example**:  \nIf called with algorithm='MD5', the function returns two functions:\n- H: a function such that H('input') returns the hexadecimal MD5 digest of 'input'.\n- KD: a function such that KD('a', 'b') returns the hexadecimal MD5 digest of the string 'a:b'.\n\nFor example:\nH, KD = get_algorithm_impls('MD5')\nH('test') might return '098f6bcd4621d373cade4e832627b4f6'\nKD('foo', 'bar') might return the MD5 hex digest of 'foo:bar', such as '327b6f07435811239bc47e1544353273'"
                },
                {
                    "method_name": "get_entity_digest",
                    "source_code": "def get_entity_digest(self, data, chal):\n    # XXX not implemented yet\n    return None",
                    "first_doc": "**get_entity_digest**: The function of get_entity_digest is to compute and return the digest value for a given entity body and authentication challenge, as part of the HTTP Digest Authentication process.\n\n**parameters**: The parameters of this Function.\n· data: The entity body data for which the digest is to be computed.  \n· chal: The authentication challenge dictionary, typically containing parameters such as realm, nonce, and algorithm.\n\n**Code Description**:  \nThis function is intended to generate a digest (hash) of the entity body (data) in the context of HTTP Digest Authentication, using information provided in the authentication challenge (chal). The digest is typically used to ensure the integrity and authenticity of the entity body during authentication exchanges.\n\nCurrently, the function is not implemented and always returns None. This means that, at present, no entity digest is computed or included in the authentication process. The function is called by get_authorization, which is responsible for constructing the Authorization header for HTTP requests requiring Digest Authentication. In get_authorization, if the request contains data (such as in a POST request), get_entity_digest is called to attempt to compute the digest for that data. Since get_entity_digest returns None, the entity digest is not included in the resulting Authorization header.\n\n**Note**:  \n- This function is a placeholder and does not perform any computation. It always returns None.\n- If entity body digest support is required for your application, this function will need to be properly implemented.\n- The absence of an entity digest may affect compliance with certain Digest Authentication schemes that require it.\n\n**Output Example**:  \nNone"
                }
            ]
        },
        {
            "type": "class",
            "name": "HTTPDigestAuthHandler",
            "methods": [
                {
                    "method_name": "http_error_401",
                    "source_code": "def http_error_401(self, req, fp, code, msg, headers):\n    host = urlparse.urlparse(req.get_full_url())[1]\n    self.http_error_auth_reqed('www-authenticate', host, req, headers)",
                    "first_doc": "**http_error_401**: The function of http_error_401 is to handle HTTP 401 Unauthorized errors by initiating the appropriate authentication process, specifically for HTTP Digest Authentication.\n\n**parameters**: The parameters of this Function.\n· req: The HTTP request object that resulted in a 401 Unauthorized response.\n· fp: The file-like object containing the server's response body (not used in this function).\n· code: The HTTP status code received from the server (expected to be 401).\n· msg: The HTTP status message returned by the server (not used in this function).\n· headers: The headers returned by the server in response to the request.\n\n**Code Description**:  \nThis function is designed to process HTTP 401 Unauthorized responses encountered during HTTP requests. When a 401 error is received, it indicates that the server requires authentication before granting access to the requested resource. The function extracts the host component from the request's URL using urlparse, which is necessary for the authentication process.\n\nAfter obtaining the host, http_error_401 delegates the handling of the authentication challenge to the http_error_auth_reqed method. It passes the following arguments to http_error_auth_reqed: the string 'www-authenticate' (which specifies the relevant authentication header to check), the extracted host, the original request object, and the response headers. The http_error_auth_reqed method then inspects the response headers for a Digest authentication challenge and, if present, initiates the retry process with the appropriate credentials.\n\nBy delegating the authentication logic to http_error_auth_reqed, http_error_401 ensures that the handling of authentication-required errors is centralized and consistent, specifically supporting HTTP Digest Authentication as implemented in the broader authentication handler.\n\n**Note**:  \n- This function is specifically tailored to handle HTTP 401 Unauthorized errors and is intended for use within an HTTP Digest Authentication handler.\n- The function does not process the response body or status message; it focuses solely on initiating the authentication process.\n- It relies on the http_error_auth_reqed method to detect and handle Digest authentication challenges. If the server does not require Digest authentication, no further action is taken.\n- The function assumes that the request object provides a get_full_url method and that the urlparse module is available for extracting the host."
                }
            ]
        },
        {
            "type": "class",
            "name": "ProxyDigestAuthHandler",
            "methods": [
                {
                    "method_name": "http_error_407",
                    "source_code": "def http_error_407(self, req, fp, code, msg, headers):\n    host = req.get_host()\n    self.http_error_auth_reqed('proxy-authenticate', host, req, headers)",
                    "first_doc": "**http_error_407**: The function of http_error_407 is to handle HTTP 407 (Proxy Authentication Required) errors by initiating the appropriate proxy authentication process.\n\n**parameters**: The parameters of this Function.\n· req: The HTTP request object that triggered the 407 error.\n· fp: The file-like object containing the HTTP response body (not used in this function).\n· code: The HTTP status code (expected to be 407).\n· msg: The HTTP status message (not used in this function).\n· headers: The headers returned by the proxy server in response to the request.\n\n**Code Description**:  \nThis function is specifically designed to process HTTP 407 errors, which indicate that the proxy server requires authentication before forwarding the request. When such an error is encountered, http_error_407 retrieves the host information from the request object using req.get_host(). It then delegates the handling of the authentication challenge to the http_error_auth_reqed method, passing the following arguments:\n\n- 'proxy-authenticate' as the authentication header to check in the response,\n- the host requiring authentication,\n- the original request object,\n- and the response headers.\n\nThe delegated method, http_error_auth_reqed, is responsible for examining the response headers for a proxy authentication challenge (specifically looking for a Digest authentication scheme). If a Digest challenge is found, http_error_auth_reqed initiates the retry process with the appropriate authentication headers. If no suitable challenge is present, no further action is taken.\n\nThis design ensures that the logic for handling proxy authentication is centralized and consistent, leveraging shared authentication handling mechanisms for both server and proxy authentication scenarios.\n\n**Note**:  \n- This function does not directly process the authentication challenge or modify the request; it relies on http_error_auth_reqed to perform these tasks.\n- Only Digest authentication challenges are handled by the underlying logic; other authentication schemes are ignored.\n- The function assumes that the request object provides a get_host() method and that the headers parameter contains the proxy's response headers.\n- The fp and msg parameters are present for interface compatibility but are not used in this function."
                }
            ]
        },
        {
            "type": "class",
            "name": "AbstractHTTPHandler",
            "methods": [
                {
                    "method_name": "do_open",
                    "source_code": "def do_open(self, http_class, req):\n    host = req.get_host()\n    if not host:\n        raise URLError('no host given')\n\n    try:\n        h = http_class(host) # will parse host:port\n        if req.has_data():\n            data = req.get_data()\n            h.putrequest('POST', req.get_selector())\n            if not req.headers.has_key('Content-type'):\n                h.putheader('Content-type',\n                            'application/x-www-form-urlencoded')\n            if not req.headers.has_key('Content-length'):\n                h.putheader('Content-length', '%d' % len(data))\n        else:\n            h.putrequest('GET', req.get_selector())\n    except socket.error as err:\n        raise URLError(err)\n\n    h.putheader('Host', host)\n    for args in self.parent.addheaders:\n        h.putheader(*args)\n    for k, v in req.headers.items():\n        h.putheader(k, v)\n    h.endheaders()\n    if req.has_data():\n        h.send(data)\n\n    code, msg, hdrs = h.getreply()\n    fp = h.getfile()\n    if code == 200:\n        return addinfourl(fp, hdrs, req.get_full_url())\n    else:\n        return self.parent.error('http', req, fp, code, msg, hdrs)",
                    "first_doc": "**do_open**: The function of do_open is to perform a low-level HTTP or HTTPS request using a specified HTTP class and a request object, handling both GET and POST methods, and returning the appropriate response or error.\n\n**parameters**: The parameters of this Function.\n· http_class: The HTTP connection class to use for the request (such as httplib.HTTP or httplib.HTTPS).\n· req: The request object containing all necessary information for the HTTP transaction, including the target URL, headers, and optional data payload.\n\n**Code Description**:  \nThe do_open function is responsible for establishing an HTTP or HTTPS connection to a remote server, sending a request, and processing the response. It is a core method used by protocol handlers such as HTTPHandler and HTTPSHandler, which call do_open to implement their http_open and https_open methods, respectively.\n\nThe function begins by extracting the host from the request object using req.get_host(). If the host is missing, it raises a URLError with the message 'no host given', ensuring that all requests have a valid destination.\n\nNext, it attempts to create a connection to the host using the provided http_class. This class is responsible for handling the underlying socket connection and HTTP protocol details. If the request object contains data (indicating a POST request), do_open prepares a POST request by calling putrequest('POST', ...) and ensures that the appropriate 'Content-type' and 'Content-length' headers are set. If the request does not contain data, a GET request is prepared instead.\n\nIf a socket error occurs during connection setup, the function raises a URLError with the underlying socket error as the reason, providing clear feedback on network-related failures.\n\nThe function then sets the 'Host' header and adds any additional headers specified by the parent object's addheaders attribute and the request's headers. After all headers are sent using endheaders(), the function sends the request body if present.\n\nUpon receiving the server's response, do_open retrieves the status code, message, and headers. If the response code is 200 (OK), it wraps the response file pointer and headers in an addinfourl object and returns it, providing a file-like interface to the response data. For any other response code, do_open delegates error handling to the parent object's error method, which selects the appropriate error handler based on the protocol and status code.\n\nThis design allows do_open to serve as a reusable, protocol-agnostic method for performing HTTP transactions, while delegating protocol-specific and error-handling logic to higher-level components.\n\n**Note**:  \n- The function expects the request object to provide methods such as get_host(), has_data(), get_data(), get_selector(), and get_full_url(), as well as a headers attribute.\n- Proper error handling is implemented via URLError for missing hosts and socket errors.\n- The function supports both GET and POST methods, automatically managing relevant headers.\n- Error responses (non-200 status codes) are not handled directly but are passed to the parent error handler for further processing.\n- The function is intended for internal use by HTTP and HTTPS handlers and is not typically called directly by user code.\n\n**Output Example**:  \nIf a GET request to a valid HTTP URL is successful, the function returns an addinfourl object representing the response, such as:\n<addinfourl at 0x7f1c8b2e3d60 whose fp = <socket._fileobject object at 0x7f1c8b2e3c90>>\n\nIf the host is missing or a socket error occurs, a URLError is raised with a message like:\n<urlopen error no host given>\nor\n<urlopen error [Errno 11001] getaddrinfo failed>\n\nIf the server responds with a non-200 status code, the function returns the result of the parent error handler, which may be a custom error response object or None, depending on the handler's implementation."
                }
            ]
        },
        {
            "type": "class",
            "name": "HTTPHandler",
            "methods": [
                {
                    "method_name": "http_open",
                    "source_code": "def http_open(self, req):\n    return self.do_open(httplib.HTTP, req)",
                    "first_doc": "**http_open**: The function of http_open is to initiate and handle an HTTP request using the provided request object.\n\n**parameters**: The parameters of this Function.\n· req: The request object containing all necessary information for the HTTP transaction, such as the target URL, headers, and optional data payload.\n\n**Code Description**:  \nThe http_open function serves as the entry point for processing HTTP requests within the HTTPHandler class. It takes a request object (req) as its sole parameter and delegates the actual network operation to the do_open method, specifying httplib.HTTP as the HTTP connection class to use.\n\nWhen http_open is called, it passes the httplib.HTTP class and the request object to do_open. The do_open method is responsible for establishing the HTTP connection, preparing the request (including handling GET and POST methods), sending headers and any data, and processing the server's response. The result from do_open, which is typically an addinfourl object representing the server's response or an error handler's result, is then returned directly by http_open.\n\nThis design allows http_open to provide a clean and simple interface for initiating HTTP requests, while delegating the protocol-specific and error-handling logic to the underlying do_open method. The separation of concerns ensures that http_open remains concise and focused on its role as a protocol handler entry point.\n\n**Note**:  \n- The request object passed to http_open must be properly constructed and provide all required methods and attributes expected by do_open.\n- http_open does not perform any additional processing or error handling itself; all such logic is managed by do_open.\n- This function is typically used internally by the urllib2 framework and is not intended for direct use by end users.\n\n**Output Example**:  \nIf the HTTP request is successful and the server responds with a 200 status code, http_open returns an addinfourl object, such as:\n<addinfourl at 0x7f1c8b2e3d60 whose fp = <socket._fileobject object at 0x7f1c8b2e3c90>>\n\nIf the request encounters an error (such as a missing host or network failure), a URLError is raised with an appropriate message, for example:\n<urlopen error no host given>\nor\n<urlopen error [Errno 11001] getaddrinfo failed>\n\nIf the server responds with a non-200 status code, the result of the parent error handler is returned, which may be a custom error response object or None, depending on the handler's implementation."
                }
            ]
        },
        {
            "type": "class",
            "name": "UnknownHandler",
            "methods": [
                {
                    "method_name": "unknown_open",
                    "source_code": "def unknown_open(self, req):\n    type = req.get_type()\n    raise URLError('unknown url type: %s' % type)",
                    "first_doc": "**unknown_open**: The function of unknown_open is to handle requests for unknown or unsupported URL types by raising an error.\n\n**parameters**: The parameters of this Function.\n· req: The request object, which is expected to provide a get_type() method that returns the type or scheme of the URL being processed.\n\n**Code Description**:  \nThe unknown_open function is designed to be invoked when a URL request is made using a handler that does not recognize or support the scheme of the requested URL. It takes a single parameter, req, which represents the request object. The function retrieves the type of the URL from the request by calling req.get_type(). It then raises a URLError, passing a message that includes the unknown URL type. The URLError class, which is specifically used for signaling URL handling errors, will encapsulate this message and provide a clear indication that the requested URL type is not supported.\n\nThis mechanism ensures that any attempt to open a URL with an unrecognized scheme is promptly halted, and a descriptive error is provided to the caller. The use of URLError allows for consistent error handling throughout the URL handling subsystem, making it easier for developers to catch and respond to such errors in a uniform way.\n\n**Note**:  \n- This function should only be called for URL types that are not explicitly handled by other registered handlers.\n- The error message will include the specific URL type that was not recognized, aiding in debugging and error reporting.\n- The req parameter must implement a get_type() method; otherwise, an AttributeError will occur.\n- The function does not attempt any fallback or recovery; it immediately raises an error to signal the unsupported operation."
                }
            ]
        },
        {
            "type": "class",
            "name": "FileHandler",
            "methods": [
                {
                    "method_name": "file_open",
                    "source_code": "def file_open(self, req):\n    url = req.get_selector()\n    if url[:2] == '//' and url[2:3] != '/':\n        req.type = 'ftp'\n        return self.parent.open(req)\n    else:\n        return self.open_local_file(req)",
                    "first_doc": "**file_open**: The function of file_open is to determine how to handle a file URL request, delegating either to FTP handling or to local file access based on the URL format.\n\n**parameters**: The parameters of this Function.\n· self: The instance of the FileHandler class.\n· req: The request object representing the file URL to be opened.\n\n**Code Description**:  \nThe file_open method is responsible for processing file URL requests and deciding the appropriate handling mechanism. It first retrieves the selector portion of the URL from the request object using req.get_selector(). The method then examines the beginning of the selector string:\n\n- If the selector starts with two slashes ('//') and the third character is not another slash, the URL is interpreted as referencing a file on a remote host, typically indicating an FTP resource. In this case, the method sets the type attribute of the request object to 'ftp' and delegates the request to its parent object's open method. This parent.open call ensures that the request is processed through the OpenerDirector's handler chain, which will route it to the appropriate FTP handler.\n- If the selector does not match the above pattern, the method assumes the file is local. It then calls open_local_file with the request object. The open_local_file method is responsible for validating that the file resides on the local host, opening the file, and returning a file-like object with HTTP-style headers.\n\nThis design allows file_open to transparently support both local and remote (FTP) file URLs, delegating the actual file access or FTP handling to specialized methods or handler chains as appropriate.\n\n**Note**:  \n- The method distinguishes between local and remote file URLs based solely on the structure of the selector string.\n- For remote file URLs (FTP), the method modifies the request type and delegates to the parent handler chain, ensuring consistent processing with other network protocols.\n- For local files, all security and file access checks are performed by open_local_file.\n- The method assumes that the parent attribute is properly set to an object (such as an OpenerDirector) that implements the open method.\n\n**Output Example**:  \nIf the request is for a local file, the return value is typically an addinfourl object wrapping the opened file and HTTP-style headers, for example:\n\n<addinfourl at 0x7f1c8b2e3d60 whose fp = <_io.BufferedReader name='/path/to/file.txt'>>\n\nIf the request is for a remote file (FTP), the return value is determined by the FTP handler in the parent handler chain, which may return an FTP response object or similar. If the file is not on the local host, open_local_file will raise a URLError."
                },
                {
                    "method_name": "get_names",
                    "source_code": "def get_names(self):\n    if FileHandler.names is None:\n        FileHandler.names = (socket.gethostbyname('localhost'),\n                             socket.gethostbyname(socket.gethostname()))\n    return FileHandler.names",
                    "first_doc": "**get_names**: The function of get_names is to retrieve and cache the local machine's network addresses for use in file access validation.\n\n**parameters**: The parameters of this Function.\n· self: The instance of the FileHandler class. (Note: self is required for method signature but is not used directly in the logic.)\n\n**Code Description**:  \nThis function checks if the class variable FileHandler.names is None. If it is, the function resolves and stores a tuple containing two network addresses:\n- The IP address of 'localhost' (typically 127.0.0.1).\n- The IP address of the current machine's hostname (as returned by socket.gethostname()).\n\nThese addresses are obtained using socket.gethostbyname and are cached in FileHandler.names to avoid repeated lookups on subsequent calls. The function then returns this tuple of addresses.\n\nWithin the project, get_names is used by the open_local_file method of the FileHandler class. In that context, it helps determine whether a requested file URL refers to a file on the local host by checking if the host's IP address matches one of the local addresses returned by get_names. This ensures that only files residing on the local machine can be accessed, providing a security check before opening the file.\n\n**Note**:  \n- The function uses class-level caching, so the address resolution occurs only once per program run.\n- The returned tuple always contains two addresses: one for 'localhost' and one for the machine's hostname.\n- If the machine's hostname does not resolve to a local address, the result may not match all possible local network configurations.\n- This function is intended for internal use within the FileHandler class and its methods.\n\n**Output Example**:  \n('127.0.0.1', '192.168.1.5')  \nThis tuple indicates that 'localhost' resolves to 127.0.0.1 and the machine's hostname resolves to 192.168.1.5."
                },
                {
                    "method_name": "open_local_file",
                    "source_code": "def open_local_file(self, req):\n    host = req.get_host()\n    file = req.get_selector()\n    localfile = url2pathname(file)\n    stats = os.stat(localfile)\n    size = stats[stat.ST_SIZE]\n    modified = rfc822.formatdate(stats[stat.ST_MTIME])\n    mtype = mimetypes.guess_type(file)[0]\n    stats = os.stat(localfile)\n    headers = mimetools.Message(StringIO(\n        'Content-Type: %s\\nContent-Length: %d\\nLast-modified: %s\\n' %\n        (mtype or 'text/plain', size, modified)))\n    if host:\n        host, port = splitport(host)\n    if not host or \\\n       (not port and socket.gethostbyname(host) in self.get_names()):\n        return addinfourl(open(localfile, 'rb'),\n                          headers, 'file:'+file)\n    raise URLError('file not on local host')",
                    "first_doc": "**open_local_file**: The function of open_local_file is to open a local file specified by a file URL request, validate that the file resides on the local host, and return a file-like object with appropriate HTTP-style headers.\n\n**parameters**: The parameters of this Function.\n· self: The instance of the FileHandler class.\n· req: The request object containing information about the file URL to be accessed.\n\n**Code Description**:  \nThe open_local_file function is responsible for handling file URLs that refer to local files. It begins by extracting the host and file path from the request object using req.get_host() and req.get_selector(), respectively. The file path is converted from URL format to a local filesystem path using url2pathname.\n\nThe function retrieves the file's metadata using os.stat, obtaining its size and last modification time. The modification time is formatted as an HTTP date using rfc822.formatdate. The file's MIME type is determined using mimetypes.guess_type.\n\nHTTP-style headers are constructed using mimetools.Message, including Content-Type, Content-Length, and Last-modified, which describe the file's type, size, and modification date.\n\nTo ensure security, the function verifies that the requested file is on the local host. It does this by checking if the host is empty or if the host's IP address matches one of the local addresses returned by self.get_names(). The get_names function provides a tuple of the local machine's network addresses, including 'localhost' and the machine's hostname.\n\nIf the file is confirmed to be local, open_local_file opens the file in binary read mode and returns an addinfourl object, which wraps the file object along with the constructed headers and the file URL. If the file is not on the local host, the function raises a URLError with the message 'file not on local host'.\n\nWithin the project, open_local_file is called by the file_open method of the FileHandler class. file_open determines whether a file URL should be handled as a local file or redirected to FTP, and delegates to open_local_file for local file access.\n\n**Note**:  \n- This function only allows access to files that are confirmed to be on the local host, providing a security check against unauthorized remote file access.\n- If the file does not exist or is not accessible, os.stat or open may raise an exception.\n- If the host is specified and does not match the local machine, a URLError is raised.\n- The returned object is suitable for use in contexts expecting a file-like object with HTTP-style headers.\n\n**Output Example**:  \nAn example return value is an addinfourl object wrapping an open file, with headers such as:\n\nContent-Type: text/plain  \nContent-Length: 1024  \nLast-modified: Tue, 11 Jun 2024 10:00:00 GMT\n\nIf the file is not on the local host, the function raises URLError('file not on local host')."
                }
            ]
        },
        {
            "type": "class",
            "name": "FTPHandler",
            "methods": [
                {
                    "method_name": "ftp_open",
                    "source_code": "def ftp_open(self, req):\n    host = req.get_host()\n    if not host:\n        raise(IOError, ('ftp error', 'no host given'))\n    # XXX handle custom username & password\n    try:\n        host = socket.gethostbyname(host)\n    except socket.error as msg:\n        raise URLError(msg)\n    host, port = splitport(host)\n    if port is None:\n        port = ftplib.FTP_PORT\n    path, attrs = splitattr(req.get_selector())\n    path = unquote(path)\n    dirs = path.split('/')\n    dirs, file = dirs[:-1], dirs[-1]\n    if dirs and not dirs[0]:\n        dirs = dirs[1:]\n    user = passwd = '' # XXX\n    try:\n        fw = self.connect_ftp(user, passwd, host, port, dirs)\n        type = file and 'I' or 'D'\n        for attr in attrs:\n            attr, value = splitattr(attr)\n            if attr.lower() == 'type' and \\\n               value in ('a', 'A', 'i', 'I', 'd', 'D'):\n                type = value.upper()\n        fp, retrlen = fw.retrfile(file, type)\n        headers = \"\"\n        mtype = mimetypes.guess_type(req.get_full_url())[0]\n        if mtype:\n            headers += \"Content-Type: %s\\n\" % mtype\n        if retrlen is not None and retrlen >= 0:\n            headers += \"Content-Length: %d\\n\" % retrlen\n        sf = StringIO(headers)\n        headers = mimetools.Message(sf)\n        return addinfourl(fp, headers, req.get_full_url())\n    except ftplib.all_errors as msg:\n        raise(IOError, ('ftp error', msg), sys.exc_info()[2])",
                    "first_doc": "**ftp_open**: The function of ftp_open is to handle FTP URL requests by establishing an FTP connection, retrieving the requested file or directory, and returning a response object compatible with URL handling interfaces.\n\n**parameters**: The parameters of this Function.\n· req: The request object containing the FTP URL and associated request information.\n\n**Code Description**:  \nThe ftp_open function processes an FTP request by performing the following steps:\n\n1. It extracts the host from the request object using req.get_host(). If the host is missing, it raises an IOError indicating that no host was provided.\n2. The function attempts to resolve the host to an IP address using socket.gethostbyname. If DNS resolution fails, it raises a URLError with the underlying socket error as the reason.\n3. The host and port are separated using splitport. If no port is specified, the default FTP port (ftplib.FTP_PORT) is used.\n4. The path and any attributes are extracted from the request selector using splitattr and unquote. The path is split into directory components and the target file.\n5. The user and password are set to empty strings (default anonymous access), as custom authentication is not handled in this implementation.\n6. The function calls connect_ftp (a method of the same class) with the user, password, host, port, and directory list to establish an FTP connection. The connect_ftp method returns an ftpwrapper object, which manages the FTP session.\n7. The type of transfer is determined based on the presence of a file and any 'type' attributes in the URL. Supported types include ASCII ('A'), binary ('I'), and directory ('D').\n8. The ftpwrapper's retrfile method is called to retrieve the file or directory listing, returning a file-like object (fp) and the length of the retrieved data (retrlen).\n9. HTTP-like headers are constructed, including Content-Type (guessed from the URL) and Content-Length (if available).\n10. These headers are wrapped in a mimetools.Message object, and an addinfourl object is returned, encapsulating the file-like object, headers, and the full URL.\n11. If any FTP-related errors occur (as defined by ftplib.all_errors), an IOError is raised with the error message and traceback.\n\nThe function relies on connect_ftp to establish the FTP connection and on the ftpwrapper object to perform file retrieval. It also uses URLError to signal DNS resolution failures.\n\n**Note**:  \n- The function does not currently support custom usernames or passwords for FTP authentication; it defaults to anonymous access.\n- Only basic FTP URL attributes are supported, and only specific transfer types ('A', 'I', 'D') are recognized.\n- Errors during DNS resolution or FTP operations are raised as URLError or IOError, respectively.\n- The headers returned are minimal and may not include all possible HTTP headers.\n\n**Output Example**:  \nA typical return value is an addinfourl object that behaves like a file-like object for reading the retrieved FTP resource, with associated headers and the original URL. For example:\n\n<addinfourl at 0x7f8c2b4e5e50 whose fp = <_io.BytesIO object at 0x7f8c2b4e5e00>>"
                },
                {
                    "method_name": "connect_ftp",
                    "source_code": "    def connect_ftp(self, user, passwd, host, port, dirs):\n        fw = ftpwrapper(user, passwd, host, port, dirs)\n##        fw.ftp.set_debuglevel(1)\n        return fw",
                    "first_doc": "**connect_ftp**: The function of connect_ftp is to establish and return an FTP connection wrapper object configured with the provided user credentials, host, port, and directory path.\n\n**parameters**: The parameters of this Function.\n· user: The username to authenticate with the FTP server.\n· passwd: The password to authenticate with the FTP server.\n· host: The hostname or IP address of the FTP server.\n· port: The port number to connect to on the FTP server.\n· dirs: A list representing the directory path on the FTP server to be accessed.\n\n**Code Description**:  \nThis function creates an instance of the ftpwrapper class using the supplied user credentials, host, port, and directory path. The ftpwrapper object encapsulates the logic for managing an FTP connection and performing operations such as file retrieval. The function then returns this ftpwrapper instance to the caller.\n\nWithin the project, connect_ftp is called by the ftp_open method of the FTPHandler class. In that context, ftp_open prepares the necessary connection parameters (such as resolving the host, determining the port, and splitting the path into directories) and then calls connect_ftp to establish the FTP connection. The returned ftpwrapper object is subsequently used to retrieve files or directory listings from the FTP server as part of handling FTP requests.\n\n**Note**:  \n- The function assumes that the ftpwrapper class is properly implemented and available in the environment.\n- The function does not handle exceptions internally; any connection errors or authentication failures will need to be managed by the caller.\n- The function does not perform any input validation on the parameters.\n- Debugging output is available but commented out in the code (fw.ftp.set_debuglevel(1)), which can be enabled for troubleshooting if necessary.\n\n**Output Example**:  \nA typical return value from this function would be an instance of the ftpwrapper class, for example:\n<ftpwrapper instance at 0x7f8c2b4e5e50>\nThis object can then be used to perform FTP operations such as retrieving files or listing directories."
                }
            ]
        },
        {
            "type": "class",
            "name": "CacheFTPHandler",
            "methods": [
                {
                    "method_name": "__init__",
                    "source_code": "def __init__(self):\n    self.cache = {}\n    self.timeout = {}\n    self.soonest = 0\n    self.delay = 60\n    self.max_conns = 16",
                    "first_doc": "**__init__**: The function of __init__ is to initialize a new instance of the CacheFTPHandler class, setting up its internal state and default configuration.\n\n**parameters**: The parameters of this Function.\n· None: This constructor does not take any parameters.\n\n**Code Description**:  \nThis constructor method sets up the initial state for a CacheFTPHandler object. It creates several instance attributes:\n- self.cache: An empty dictionary intended to store cached FTP connections or related data.\n- self.timeout: An empty dictionary likely used to track timeout information for each cached connection.\n- self.soonest: An integer initialized to 0, which may be used to track the earliest expiration or next available time for a cached connection.\n- self.delay: An integer set to 60, representing a default delay value, possibly in seconds, for cache expiration or connection reuse.\n- self.max_conns: An integer set to 16, specifying the maximum number of concurrent FTP connections that can be managed or cached by this handler.\n\n**Note**:  \n- This constructor does not accept any arguments and relies entirely on default values for its configuration.\n- The attributes initialized here are essential for managing FTP connection caching, timeouts, and concurrency limits within the handler.\n- Modifying these attributes after initialization may affect the behavior of the cache and connection management logic elsewhere in the class."
                },
                {
                    "method_name": "setTimeout",
                    "source_code": "def setTimeout(self, t):\n    self.delay = t",
                    "first_doc": "**setTimeout**: The function of setTimeout is to set the delay time for the CacheFTPHandler instance.\n\n**parameters**: The parameters of this Function.\n· t: The value to set as the delay time. This parameter determines how long the handler should wait, and its value is assigned directly to the instance's delay attribute.\n\n**Code Description**:  \nThis function assigns the value provided in the parameter t to the instance variable delay. By calling setTimeout with a specific value, users can control the delay behavior of the CacheFTPHandler object. The delay attribute is likely used elsewhere in the class to manage timing-related operations, such as caching or connection timeouts.\n\n**Note**:  \n- The parameter t should be provided in the appropriate format and unit expected by the rest of the CacheFTPHandler class (for example, seconds or milliseconds), as this function does not perform any validation or conversion.\n- This function simply sets the delay value; it does not trigger any immediate action or check the validity of the input.\n- Users should ensure that setting the delay value aligns with the intended use of the CacheFTPHandler to avoid unexpected behavior."
                },
                {
                    "method_name": "setMaxConns",
                    "source_code": "def setMaxConns(self, m):\n    self.max_conns = m",
                    "first_doc": "**setMaxConns**: The function of setMaxConns is to set the maximum number of concurrent connections allowed for the CacheFTPHandler instance.\n\n**parameters**: The parameters of this Function.\n· m: The value to be assigned as the maximum number of concurrent connections. This parameter determines how many connections the handler can manage simultaneously.\n\n**Code Description**:  \nThis method assigns the value provided in the parameter m to the instance attribute max_conns. By calling setMaxConns, users can dynamically configure the maximum number of concurrent connections that the CacheFTPHandler will permit. This is useful for controlling resource usage and managing connection limits in FTP operations. The method directly updates the internal state of the handler by setting the max_conns attribute to the specified value.\n\n**Note**:  \nEnsure that the value passed to m is an appropriate integer representing the desired connection limit. Setting this value too high or too low may affect the performance or reliability of the FTP handler. This method does not perform any validation or type checking on the input parameter."
                },
                {
                    "method_name": "connect_ftp",
                    "source_code": "def connect_ftp(self, user, passwd, host, port, dirs):\n    key = user, passwd, host, port\n    if self.cache.has_key(key):\n        self.timeout[key] = time.time() + self.delay\n    else:\n        self.cache[key] = ftpwrapper(user, passwd, host, port, dirs)\n        self.timeout[key] = time.time() + self.delay\n    self.check_cache()\n    return self.cache[key]",
                    "first_doc": "**connect_ftp**: The function of connect_ftp is to establish or retrieve a cached FTP connection based on user credentials and connection parameters, while managing the connection cache for efficiency and resource control.\n\n**parameters**: The parameters of this Function.\n· user: The username used for FTP authentication.\n· passwd: The password associated with the user for FTP authentication.\n· host: The hostname or IP address of the FTP server.\n· port: The port number to connect to on the FTP server.\n· dirs: The initial directory or directories to be used upon connection.\n\n**Code Description**:  \nThis function manages FTP connections by utilizing a cache to avoid redundant connection setups and to optimize resource usage. It constructs a unique key from the combination of user, passwd, host, and port, which identifies each FTP connection.\n\n- If a connection with the specified key already exists in the cache, the function updates its timeout value to extend its validity, ensuring the connection remains active for a defined delay period.\n- If no such connection exists, a new FTP connection is established using the ftpwrapper class, and this connection is stored in the cache under the constructed key. The timeout for this new connection is also set to the current time plus the delay period.\n\nAfter updating or adding a connection, the function invokes check_cache to enforce cache constraints. The check_cache method is responsible for removing expired connections and ensuring the cache does not exceed its maximum allowed size. This guarantees that only valid and necessary FTP connections are maintained, preventing resource leaks and optimizing performance.\n\nFinally, the function returns the FTP connection instance associated with the requested parameters, either from the cache or newly created.\n\n**Note**:  \n- The function assumes that the cache and timeout dictionaries are properly maintained and synchronized.\n- It is important to ensure that the ftpwrapper class is correctly implemented to handle FTP connections.\n- The delay attribute must be set to define how long a connection remains valid before expiring.\n- The function relies on check_cache to handle expiration and cache size limits, so any changes to cache management should be reflected in both methods.\n\n**Output Example**:  \nAn example return value is an instance of the ftpwrapper class, representing an active FTP connection for the specified user, password, host, and port. For example:\n<ftpwrapper instance at 0x7f8c2d4e7b80>"
                },
                {
                    "method_name": "check_cache",
                    "source_code": "def check_cache(self):\n    # first check for old ones\n    t = time.time()\n    if self.soonest <= t:\n        for k, v in self.timeout.items():\n            if v < t:\n                self.cache[k].close()\n                del self.cache[k]\n                del self.timeout[k]\n    self.soonest = min(self.timeout.values())\n\n    # then check the size\n    if len(self.cache) == self.max_conns:\n        for k, v in self.timeout.items():\n            if v == self.soonest:\n                del self.cache[k]\n                del self.timeout[k]\n                break\n        self.soonest = min(self.timeout.values())",
                    "first_doc": "**check_cache**: The function of check_cache is to manage and maintain the FTP connection cache by removing expired or excess connections.\n\n**parameters**: The parameters of this Function.\n· self: Refers to the instance of the CacheFTPHandler class, providing access to the cache, timeout, soonest, and max_conns attributes.\n\n**Code Description**:  \nThis function is responsible for ensuring that the FTP connection cache remains within defined constraints, both in terms of connection expiration and the maximum number of allowed connections. It operates in two main steps:\n\n1. **Expiration Check**:  \n   The function first checks if any cached FTP connections have expired. It compares the current time with the stored timeout values for each connection. If a connection's timeout has passed, the connection is closed, and its entries are removed from both the cache and timeout dictionaries. After this cleanup, the soonest attribute is updated to reflect the next soonest timeout among the remaining connections.\n\n2. **Cache Size Enforcement**:  \n   After handling expired connections, the function checks if the cache has reached its maximum allowed size (max_conns). If so, it identifies and removes the connection with the earliest timeout (the one that will expire soonest), ensuring that the cache does not exceed its size limit. The soonest attribute is updated again to reflect the new state of the cache.\n\nThis function is called by the connect_ftp method, which is responsible for establishing or retrieving FTP connections from the cache. After adding or updating a connection in the cache, connect_ftp invokes check_cache to enforce expiration and size constraints, ensuring optimal cache performance and resource management.\n\n**Note**:  \n- The function assumes that the timeout dictionary is always non-empty when min(self.timeout.values()) is called.  \n- It is important to ensure that the soonest attribute is kept in sync with the timeout dictionary to avoid errors.  \n- Proper management of the cache and timeout dictionaries is crucial to prevent resource leaks and ensure efficient connection reuse.  \n- The function directly closes FTP connections when they expire or when the cache exceeds its size limit, which may affect any ongoing operations using those connections."
                }
            ]
        },
        {
            "type": "class",
            "name": "GopherHandler",
            "methods": [
                {
                    "method_name": "gopher_open",
                    "source_code": "def gopher_open(self, req):\n    host = req.get_host()\n    if not host:\n        raise GopherError('no host given')\n    host = unquote(host)\n    selector = req.get_selector()\n    type, selector = splitgophertype(selector)\n    selector, query = splitquery(selector)\n    selector = unquote(selector)\n    if query:\n        query = unquote(query)\n        fp = gopherlib.send_query(selector, query, host)\n    else:\n        fp = gopherlib.send_selector(selector, host)\n    return addinfourl(fp, noheaders(), req.get_full_url())",
                    "first_doc": "**gopher_open**: The function of gopher_open is to handle opening Gopher protocol URLs by establishing a connection, sending the appropriate selector or query, and returning a file-like response object.\n\n**parameters**: The parameters of this Function.\n· req: The request object representing the Gopher URL to be opened. This object must provide methods to retrieve the host, selector, and full URL.\n\n**Code Description**:  \nThe gopher_open method is responsible for processing Gopher protocol requests. It begins by extracting the host from the provided request object using req.get_host(). If the host is missing, it raises a GopherError with the message 'no host given', ensuring that only valid Gopher URLs are processed.\n\nThe host value is then decoded using unquote to handle any percent-encoded characters. The method retrieves the selector from the request using req.get_selector(), and splits it into the Gopher type and the actual selector using splitgophertype. Further, the selector is split into the main selector and an optional query component using splitquery. Both the selector and query are decoded with unquote to ensure proper formatting.\n\nIf a query is present, the method sends both the selector and query to the Gopher server using gopherlib.send_query. If there is no query, it sends only the selector using gopherlib.send_selector. Both functions return a file-like object (fp) representing the server's response.\n\nFinally, the method wraps the response in an addinfourl object, which provides a file-like interface along with URL and header information. The headers are set to an empty value using noheaders(), and the full URL is obtained from req.get_full_url().\n\nThis function integrates with the GopherError class to provide clear error handling specific to Gopher protocol operations. It also relies on the gopherlib module for network communication and selector/query handling.\n\n**Note**:  \n- The request object (req) must support get_host(), get_selector(), and get_full_url() methods.\n- If the host is missing from the request, a GopherError will be raised, halting further processing.\n- The function expects properly formatted Gopher selectors and queries; malformed input may result in errors or unexpected behavior.\n- The returned object is a file-like response suitable for reading Gopher server data.\n\n**Output Example**:  \nA typical return value is an addinfourl object wrapping the server's response. For example:\n\n<addinfourl at 0x7f8a2c3e2e80 whose fp = <_io.BufferedReader name=5>>\n\nThis object can be used to read the response data from the Gopher server, similar to how HTTP responses are handled."
                }
            ]
        },
        {
            "type": "class",
            "name": "OpenerFactory",
            "methods": [
                {
                    "method_name": "add_proxy_handler",
                    "source_code": "def add_proxy_handler(self, ph):\n    self.proxy_handlers = self.proxy_handlers + [ph]",
                    "first_doc": "**add_proxy_handler**: The function of add_proxy_handler is to add a new proxy handler to the list of existing proxy handlers managed by the OpenerFactory instance.\n\n**parameters**: The parameters of this Function.\n· ph: The proxy handler object to be added to the list of proxy handlers.\n\n**Code Description**:  \nThis function appends the provided proxy handler (ph) to the current list of proxy handlers stored in the instance variable self.proxy_handlers. It achieves this by creating a new list that combines the existing proxy handlers with the new one and assigns this updated list back to self.proxy_handlers. This ensures that the new proxy handler is included in subsequent operations that rely on the list of proxy handlers.\n\n**Note**:  \n- The function does not perform any validation or type checking on the ph parameter; it assumes that the argument provided is a valid proxy handler.\n- Each call to this function will add the given proxy handler to the end of the proxy_handlers list, potentially allowing duplicate handlers if the same object is added multiple times.\n- The function replaces the entire proxy_handlers list with a new list containing the previous handlers and the new one, which may have performance implications if the list is very large."
                },
                {
                    "method_name": "add_handler",
                    "source_code": "def add_handler(self, h):\n    self.handlers = self.handlers + [h]",
                    "first_doc": "**add_handler**: The function of add_handler is to add a new handler object to the existing list of handlers managed by the OpenerFactory instance.\n\n**parameters**: The parameters of this Function.\n· h: The handler object to be added to the handlers list.\n\n**Code Description**:  \nThis function appends a new handler, represented by the parameter h, to the current list of handlers stored in the instance variable self.handlers. It achieves this by creating a new list that consists of the existing handlers followed by the new handler h, and then assigns this new list back to self.handlers. This ensures that the handler is added at the end of the list, preserving the order of handler addition.\n\n**Note**:  \n- The function does not perform any validation or type checking on the handler object h; it assumes that h is a valid handler.\n- The handlers list is replaced with a new list each time a handler is added, which may have performance implications if the list is very large.\n- The function does not check for duplicate handlers, so the same handler can be added multiple times."
                },
                {
                    "method_name": "replace_handler",
                    "source_code": "def replace_handler(self, h):\n    pass",
                    "first_doc": "**replace_handler**: The function of replace_handler is to provide an interface for replacing an existing handler with a new handler object.\n\n**parameters**: The parameters of this Function.\n· h: The new handler object that is intended to replace an existing handler.\n\n**Code Description**:  \nThis function is designed to accept a single parameter, h, which represents a handler object. The purpose of this function is to serve as a placeholder or interface for the logic that would replace an existing handler with the provided handler object. However, in its current form, the function does not contain any implementation and does not perform any operations. It is likely intended to be overridden or implemented in a subclass or by the user, where the actual replacement logic would be defined.\n\n**Note**:  \n- This function does not perform any action as currently implemented; it simply passes without modifying any state or returning a value.\n- To utilize this function for its intended purpose, an implementation must be provided that defines how the handler replacement should occur.\n- This function is likely part of a larger handler management system, and its correct usage depends on the context in which it is implemented."
                },
                {
                    "method_name": "build_opener",
                    "source_code": "def build_opener(self):\n    opener = OpenerDirector()\n    for ph in self.proxy_handlers:\n        if inspect.isclass(ph):\n            ph = ph()\n        opener.add_handler(ph)",
                    "first_doc": "**build_opener**: The function of build_opener is to create and configure an OpenerDirector instance by adding a set of proxy handlers to it, returning a fully assembled opener object capable of handling URL operations with the specified handlers.\n\n**parameters**: This function does not take any parameters.\n\n**Code Description**:  \nThe build_opener function is responsible for constructing an OpenerDirector, which is a central component for managing URL opening and error handling through a modular handler system. The function operates as follows:\n\n1. It instantiates an OpenerDirector object, which will serve as the main controller for handling URL requests and errors.\n2. It iterates over the collection self.proxy_handlers. Each element in this collection is intended to be a handler for proxy-related operations.\n3. For each handler (ph) in the proxy_handlers list:\n   - If the handler is provided as a class (rather than an instance), it is instantiated by calling ph().\n   - The handler instance is then registered with the OpenerDirector by calling its add_handler method. This method inspects the handler for protocol and error handling methods, and integrates it into the OpenerDirector's internal management system.\n4. After all handlers have been added, the fully configured OpenerDirector (referred to as opener) is returned.\n\nThe relationship with its callees is as follows:\n- OpenerDirector is the core object that manages the registration and invocation of handlers for different protocols and error types.\n- The add_handler method of OpenerDirector is used to register each handler, ensuring that the opener is capable of handling the protocols and errors supported by the provided proxy handlers.\n\nThis design allows for flexible and dynamic assembly of opener objects, making it possible to customize URL handling behavior by specifying different sets of handlers.\n\n**Note**:  \n- The function expects self.proxy_handlers to be a list of handler classes or instances. If a class is provided, it must be instantiable without arguments.\n- Each handler must conform to the expected interface and method naming conventions so that OpenerDirector can recognize and register its capabilities.\n- The returned opener is ready to be used for opening URLs with the configured set of handlers. If additional handlers are needed, they must be added before using the opener for URL operations.\n- The function does not perform validation on the handlers beyond checking if they are classes or instances. Handlers must be compatible with OpenerDirector's expectations to function correctly."
                }
            ]
        },
        {
            "type": "class",
            "name": "HTTPSHandler",
            "methods": [
                {
                    "method_name": "https_open",
                    "source_code": "def https_open(self, req):\n    return self.do_open(httplib.HTTPS, req)",
                    "first_doc": "**https_open**: The function of https_open is to initiate and process an HTTPS request using a provided request object.\n\n**parameters**: The parameters of this Function.\n· req: The request object containing all necessary information for the HTTPS transaction, such as the target URL, headers, and optional data payload.\n\n**Code Description**:  \nThe https_open function is responsible for handling HTTPS requests. It achieves this by delegating the actual connection and request logic to the do_open method, specifying httplib.HTTPS as the HTTP class to be used for the connection. The req parameter is passed directly to do_open, which manages the details of establishing a secure connection, sending the request, and processing the server's response.\n\nFunctionally, https_open acts as a protocol-specific entry point for HTTPS transactions within the handler class. By calling self.do_open(httplib.HTTPS, req), it ensures that all HTTPS requests are processed using the secure HTTPS protocol, leveraging the comprehensive request and response handling implemented in do_open. This design allows for clear separation between protocol-specific logic (handled by https_open) and the generic HTTP/HTTPS transaction logic (handled by do_open).\n\n**Note**:  \n- This function is intended for internal use by the HTTPSHandler class and is not typically called directly by user code.\n- The request object (req) must provide all necessary methods and attributes expected by do_open, such as get_host(), has_data(), get_data(), get_selector(), get_full_url(), and headers.\n- Proper error handling and response processing are managed by do_open, including support for both GET and POST methods and handling of network or protocol errors.\n\n**Output Example**:  \nIf the HTTPS request is successful and the server responds with a 200 status code, the function returns an addinfourl object representing the response, for example:\n<addinfourl at 0x7f1c8b2e3d60 whose fp = <socket._fileobject object at 0x7f1c8b2e3c90>>\n\nIf there is an error such as a missing host or a socket error, a URLError is raised with a descriptive message, such as:\n<urlopen error no host given>\nor\n<urlopen error [Errno 11001] getaddrinfo failed>\n\nFor non-200 status codes, the function returns the result of the parent error handler, which may be a custom error response object or None, depending on the handler's implementation."
                }
            ]
        }
    ],
    "testscripts/pysimple3.py": []
}