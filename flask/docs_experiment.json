{
    "flask/docs/conf.py": [
        {
            "details": {
                "docstring": null,
                "method_name": "github_link",
                "second_doc": "\"\"\"\nGenerate a hyperlink node pointing to a specific file or directory in the project's GitHub repository, corresponding to the current documentation version. This ensures that documentation references the correct source code version for improved clarity and traceability.\n\nArgs:\n    name (str): The role name used in the ReStructuredText markup.\n    rawtext (str): The original text marked up.\n    text (str): The target file or path in the repository, optionally with alternate link text.\n    lineno (int): The line number where the role was found.\n    inliner: The inliner instance processing the role.\n    options (dict, optional): Role options.\n    content (list, optional): Content block if present.\n\nReturns:\n    tuple: A list containing a single reference node to the GitHub URL, and an empty list for any messages or errors.\n\"\"\"",
                "source_code": "app = inliner.document.settings.env.app\n    release = app.config.release\n    base_url = \"https://github.com/pallets/flask/tree/\"\n\n    if text.endswith(\">\"):\n        words, text = text[:-1].rsplit(\"<\", 1)\n        words = words.strip()\n    else:\n        words = None\n\n    if packaging.version.parse(release).is_devrelease:\n        url = f\"{base_url}master/{text}\"\n    else:\n        url = f\"{base_url}{release}/{text}\"\n\n    if words is None:\n        words = url\n\n    from docutils.nodes import reference\n    from docutils.parsers.rst.roles import set_classes\n\n    options = options or {}\n    set_classes(options)\n    node = reference(rawtext, words, refuri=url, **options)\n    return [node], []"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "setup",
                "second_doc": "\"\"\"\nRegisters a custom role \"gh\" with the application's documentation system to enable linking to GitHub resources directly in the documentation.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "app.add_role(\"gh\", github_link)"
            },
            "type": "function"
        }
    ],
    "flask/examples/javascript/js_example/__init__.py": [],
    "flask/examples/javascript/js_example/views.py": [
        {
            "details": {
                "docstring": null,
                "method_name": "index",
                "second_doc": "\"\"\"\nRenders the appropriate HTML template based on the requested JavaScript rendering approach, allowing the application to serve dynamic content with different client-side behaviors.\n\nArgs:\n    js (str): The rendering method to use, which can be \"plain\", \"jquery\", or \"fetch\".\n\nReturns:\n    str: The rendered HTML template associated with the specified rendering method.\n\"\"\"",
                "source_code": "return render_template(f\"{js}.html\", js=js)"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "add",
                "second_doc": "\"\"\"\nHandles POST requests to the \"/add\" endpoint by retrieving two numerical values from the submitted form data, computing their sum, and returning the result as a JSON response. This allows clients to perform addition operations via a web interface.\n\nArgs:\n    None (expects form data with parameters 'a' and 'b' in the POST request)\n\nReturns:\n    Response: A JSON object containing the sum of the provided values under the key 'result'.\n\"\"\"",
                "source_code": "a = request.form.get(\"a\", 0, type=float)\n    b = request.form.get(\"b\", 0, type=float)\n    return jsonify(result=a + b)"
            },
            "type": "function"
        }
    ],
    "flask/examples/javascript/setup.py": [],
    "flask/examples/javascript/tests/conftest.py": [
        {
            "details": {
                "docstring": null,
                "method_name": "fixture_app",
                "second_doc": "\"\"\"\nProvides a pytest fixture that configures the Flask application for testing, ensures isolated test runs, and restores its state afterwards.\n\nThis setup is necessary to allow Flask's internal mechanisms and features (such as error handling, test clients, and debugging) to behave as expected during test execution without impacting the application's normal operation.\n\nArgs:\n    None\n\nYields:\n    Flask: The Flask application instance in testing mode.\n\"\"\"",
                "source_code": "app.testing = True\n    yield app\n    app.testing = False"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "client",
                "second_doc": "\"\"\"\nCreates and returns a test client instance for simulating requests to the Flask application.\n\nThis method allows developers to programmatically interact with the application in a controlled environment, enabling thorough testing of routes, handlers, and responses without running a live server.\n\nReturns:\n    flask.testing.FlaskClient: A test client instance for sending requests to the application.\n\"\"\"",
                "source_code": "return app.test_client()"
            },
            "type": "function"
        }
    ],
    "flask/examples/javascript/tests/test_js_example.py": [
        {
            "details": {
                "docstring": null,
                "method_name": "test_index",
                "second_doc": "\"\"\"\nTests that the correct HTML template is rendered when various URL paths are requested in the web application.\n\nArgs:\n    path (str): The URL route to request in the test.\n    template_name (str): The expected name of the template to be rendered for the given route.\n\nReturns:\n    None: The function asserts correctness without returning a value.\n\nWhy:\n    Ensuring the proper template is rendered for each URL path helps verify the routing and rendering logic of the application, preventing incorrect views from being delivered to users.\n\"\"\"",
                "source_code": "def check(sender, template, context):\n        assert template.name == template_name\n\n    with template_rendered.connected_to(check, app):\n        client.get(path)"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_add",
                "second_doc": "\"\"\"\nTests the POST endpoint '/add' by sending various combinations of input data and verifying the correctness of the calculated sum in the response. This ensures that the endpoint properly handles different data types and missing or invalid inputs to maintain robustness and reliability of the application's core calculation functionality.\n\nArgs:\n    a: The first addend, which can be an integer, float, None, or string.\n    b: The second addend, which can be an integer, float, None, or string.\n    result: The expected outcome of the addition operation as returned by the service.\n\nReturns:\n    None. Asserts that the endpoint's response matches the expected result for each test case.\n\"\"\"",
                "source_code": "response = client.post(\"/add\", data={\"a\": a, \"b\": b})\n    assert response.get_json()[\"result\"] == result"
            },
            "type": "function"
        }
    ],
    "flask/examples/tutorial/flaskr/__init__.py": [
        {
            "details": {
                "docstring": "\"\"\"Create and configure an instance of the Flask application.\"\"\"",
                "first_doc": "\"\"\"\nCreates and configures an instance of the Flask application.\n\nThis function sets up the Flask app with default and instance-based configuration, ensures the instance directory exists, registers database commands and blueprints, defines a route, and sets the main application index.\n\nReturns:\n    Flask: The configured Flask application instance.\n\"\"\"",
                "method_name": "create_app",
                "second_doc": "\"\"\"\nInitializes and prepares a web application instance with essential configuration, directory setup, blueprint registration, and routes.\n\nBy assembling configuration from multiple sources, ensuring directory structure, registering modular components, and exposing key endpoints, this function provides a robust foundation for serving web content and managing application resources.\n\nArgs:\n    test_config (dict, optional): Configuration dictionary for testing environments. If provided, overrides default and instance configuration.\n\nReturns:\n    Flask: The fully initialized and configured Flask application instance.\n\"\"\"",
                "source_code": "app = Flask(__name__, instance_relative_config=True)\n    app.config.from_mapping(\n        # a default secret that should be overridden by instance config\n        SECRET_KEY=\"dev\",\n        # store the database in the instance folder\n        DATABASE=os.path.join(app.instance_path, \"flaskr.sqlite\"),\n    )\n\n    if test_config is None:\n        # load the instance config, if it exists, when not testing\n        app.config.from_pyfile(\"config.py\", silent=True)\n    else:\n        # load the test config if passed in\n        app.config.update(test_config)\n\n    # ensure the instance folder exists\n    try:\n        os.makedirs(app.instance_path)\n    except OSError:\n        pass\n\n    @app.route(\"/hello\")\n    def hello():\n        return \"Hello, World!\"\n\n    # register the database commands\n    from flaskr import db\n\n    db.init_app(app)\n\n    # apply the blueprints to the app\n    from flaskr import auth, blog\n\n    app.register_blueprint(auth.bp)\n    app.register_blueprint(blog.bp)\n\n    # make url_for('index') == url_for('blog.index')\n    # in another app, you might define a separate main index here with\n    # app.route, while giving the blog blueprint a url_prefix, but for\n    # the tutorial the blog will be the main index\n    app.add_url_rule(\"/\", endpoint=\"index\")\n\n    return app"
            },
            "type": "function"
        }
    ],
    "flask/examples/tutorial/flaskr/auth.py": [
        {
            "details": {
                "docstring": "\"\"\"View decorator that redirects anonymous users to the login page.\"\"\"",
                "first_doc": "\"\"\"\nA decorator that ensures a user is logged in before accessing a view function.\n\nIf the current user is not authenticated, the user is redirected to the login page. Otherwise, the decorated view function is called as normal.\n\nArgs:\n    view: The view function to protect with login authentication.\n\nReturns:\n    A wrapped view function that checks for user authentication before proceeding.\n\"\"\"",
                "method_name": "login_required",
                "second_doc": "\"\"\"\nA decorator that restricts access to a view function to authenticated users.\n\nBy checking if a user session is active, this decorator prevents unauthorized users from accessing certain views, which helps maintain the proper flow and integrity of the application. If no authenticated user is found, it redirects the request to the login page, ensuring only users with the correct permissions can access protected resources.\n\nArgs:\n    view (function): The view function to be protected by authentication.\n\nReturns:\n    function: A wrapped version of the view function that performs an authentication check before execution. If the user is not logged in, it initiates a redirect to the login page.\n\"\"\"",
                "source_code": "@functools.wraps(view)\n    def wrapped_view(**kwargs):\n        if g.user is None:\n            return redirect(url_for(\"auth.login\"))\n\n        return view(**kwargs)\n\n    return wrapped_view"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": "\"\"\"If a user id is stored in the session, load the user object from\n    the database into ``g.user``.\"\"\"",
                "first_doc": "\"\"\"\nLoads the logged-in user information into the global request context.\n\nChecks the session for a stored user ID. If a user is logged in, queries the database for the user's information and sets it in the global request context (g.user). Otherwise, sets g.user to None.\n\nReturns:\n    None: This method does not return a value.\n\"\"\"",
                "method_name": "load_logged_in_user",
                "second_doc": "\"\"\"\nRetrieves the current user's information from the session and populates the global request context.\n\nThis process enables the application to consistently identify and access user data during each request, enhancing request handling and user experience. When a user is logged in, their details are fetched from the database and linked to the request; otherwise, no user information is associated.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "user_id = session.get(\"user_id\")\n\n    if user_id is None:\n        g.user = None\n    else:\n        g.user = (\n            get_db().execute(\"SELECT * FROM user WHERE id = ?\", (user_id,)).fetchone()\n        )"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": "\"\"\"Register a new user.\n\n    Validates that the username is not already taken. Hashes the\n    password for security.\n    \"\"\"",
                "first_doc": "\"\"\"\nHandles user registration by processing GET and POST requests.\n\nOn GET requests, displays the registration page. On POST requests, validates the submitted username and password, checks if the username is available, and creates a new user account if valid. If there are input errors or the username is already taken, displays an error message.\n\nReturns:\n    A redirect response to the login page upon successful registration, or the rendered registration template with error messages if registration fails.\n\"\"\"",
                "method_name": "register",
                "second_doc": "\"\"\"\nProcesses registration requests, enabling new users to create accounts by validating input, ensuring username uniqueness, and securely storing credentials.\n\nBy implementing validation and feedback during registration, the method helps maintain data integrity and provides a clear user experience, guiding users towards successful account creation while preventing duplicate registrations.\n\nArgs:\n    None directly. Relies on form data from the request object when handling POST requests, specifically 'username' and 'password'.\n\nReturns:\n    Response object: Redirects to the login page upon successful registration, or renders the registration template with relevant error messages if input validation fails or the username is already taken.\n\"\"\"",
                "source_code": "if request.method == \"POST\":\n        username = request.form[\"username\"]\n        password = request.form[\"password\"]\n        db = get_db()\n        error = None\n\n        if not username:\n            error = \"Username is required.\"\n        elif not password:\n            error = \"Password is required.\"\n        elif (\n            db.execute(\"SELECT id FROM user WHERE username = ?\", (username,)).fetchone()\n            is not None\n        ):\n            error = f\"User {username} is already registered.\"\n\n        if error is None:\n            # the name is available, store it in the database and go to\n            # the login page\n            db.execute(\n                \"INSERT INTO user (username, password) VALUES (?, ?)\",\n                (username, generate_password_hash(password)),\n            )\n            db.commit()\n            return redirect(url_for(\"auth.login\"))\n\n        flash(error)\n\n    return render_template(\"auth/register.html\")"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": "\"\"\"Log in a registered user by adding the user id to the session.\"\"\"",
                "first_doc": "\"\"\"\nHandles user login by validating credentials and managing the user session.\n\nIf the request method is POST, this method retrieves the username and password from the form data, checks the credentials against the database, and manages session storage for the authenticated user. On failed authentication, an error message is flashed to the user interface. On successful authentication, the user's ID is stored in the session and the user is redirected to the index page. If the request method is GET, the login page is rendered.\n\nReturns:\n    A redirect to the index page on successful login; otherwise, the login page template is rendered with any relevant error messages.\n\"\"\"",
                "method_name": "login",
                "second_doc": "\"\"\"\nAuthenticates a user by verifying submitted credentials and establishes a session for recognized users.\n\nThis method processes login requests: upon receiving POST data, it checks the provided username and password against stored user data, manages session initialization if validation succeeds, or communicates relevant error feedback to the user interface if authentication fails. For GET requests, it serves the login page. This approach ensures that only verified users gain access to specific resources while presenting appropriate feedback and preserving a seamless user experience.\n\nArgs:\n    None directly. Relies on the Flask `request` context to access form data for POST requests.\n\nReturns:\n    Response: Redirects the user to the index page upon successful authentication, or renders the login template with error messages otherwise.\n\"\"\"",
                "source_code": "if request.method == \"POST\":\n        username = request.form[\"username\"]\n        password = request.form[\"password\"]\n        db = get_db()\n        error = None\n        user = db.execute(\n            \"SELECT * FROM user WHERE username = ?\", (username,)\n        ).fetchone()\n\n        if user is None:\n            error = \"Incorrect username.\"\n        elif not check_password_hash(user[\"password\"], password):\n            error = \"Incorrect password.\"\n\n        if error is None:\n            # store the user id in a new session and return to the index\n            session.clear()\n            session[\"user_id\"] = user[\"id\"]\n            return redirect(url_for(\"index\"))\n\n        flash(error)\n\n    return render_template(\"auth/login.html\")"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": "\"\"\"Clear the current session, including the stored user id.\"\"\"",
                "first_doc": "\"\"\"\nLogs out the current user by clearing the session.\n\nClears all data stored in the session for the current user and redirects them to the index page.\n\nReturns:\n    A response object that redirects the user to the index page.\n\"\"\"",
                "method_name": "logout",
                "second_doc": "\"\"\"\nLogs out the current user by clearing all session data and redirects them to the home page.\n\nThis method helps ensure that sensitive user information is properly removed after logout, providing a secure way to end a user's session.\n\nArgs:\n    None\n\nReturns:\n    werkzeug.wrappers.response.Response: A response object that redirects the user to the index (home) page.\n\"\"\"",
                "source_code": "session.clear()\n    return redirect(url_for(\"index\"))"
            },
            "type": "function"
        }
    ],
    "flask/examples/tutorial/flaskr/blog.py": [
        {
            "details": {
                "docstring": "\"\"\"Show all the posts, most recent first.\"\"\"",
                "first_doc": "\"\"\"\nDisplays a list of blog posts on the index page.\n\nRetrieves all blog posts from the database, including their id, title, body, creation timestamp, author's id, and username. The posts are ordered by their creation time in descending order and then rendered in the \"blog/index.html\" template.\n\nReturns:\n    A rendered HTML page displaying the list of blog posts.\n\"\"\"",
                "method_name": "index",
                "second_doc": "\"\"\"\nRetrieves all existing blog posts from the database, including relevant details such as the post's ID, title, content, creation time, and author information, then presents them on the main page in reverse chronological order.  \nThis organization allows users to conveniently browse recent updates and articles authored by various users.\n\nArgs:\n    None\n\nReturns:\n    str: Rendered HTML page showing a list of blog posts populated with data from the database.\n\"\"\"",
                "source_code": "db = get_db()\n    posts = db.execute(\n        \"SELECT p.id, title, body, created, author_id, username\"\n        \" FROM post p JOIN user u ON p.author_id = u.id\"\n        \" ORDER BY created DESC\"\n    ).fetchall()\n    return render_template(\"blog/index.html\", posts=posts)"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": "\"\"\"Get a post and its author by id.\n\n    Checks that the id exists and optionally that the current user is\n    the author.\n\n    :param id: id of post to get\n    :param check_author: require the current user to be the author\n    :return: the post with author information\n    :raise 404: if a post with the given id doesn't exist\n    :raise 403: if the current user isn't the author\n    \"\"\"",
                "first_doc": "\"\"\"\nRetrieves a post by its identifier, checking for existence and optional author verification.\n\nArgs:\n    id: The unique identifier of the post to retrieve.\n\nReturns:\n    The post object as a dictionary containing its details, or aborts and responds with an error if not found or unauthorized.\n\"\"\"",
                "method_name": "get_post",
                "second_doc": "\"\"\"\nFetches a post from the database using its unique identifier, ensuring it exists and that the requester has permission to access it if author verification is required.\n\nThis method ensures that only authorized users can view posts they are permitted to access, thus maintaining content integrity and access control.\n\nArgs:\n    id (int): The unique identifier of the post to retrieve.\n    check_author (bool, optional): Whether to verify that the current user is the author of the post.\n\nReturns:\n    dict: A dictionary representing the post's details.\n\nRaises:\n    404: If the post does not exist.\n    403: If author verification is enabled and the current user is not the post's author.\n\"\"\"",
                "source_code": "post = (\n        get_db()\n        .execute(\n            \"SELECT p.id, title, body, created, author_id, username\"\n            \" FROM post p JOIN user u ON p.author_id = u.id\"\n            \" WHERE p.id = ?\",\n            (id,),\n        )\n        .fetchone()\n    )\n\n    if post is None:\n        abort(404, f\"Post id {id} doesn't exist.\")\n\n    if check_author and post[\"author_id\"] != g.user[\"id\"]:\n        abort(403)\n\n    return post"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": "\"\"\"Create a new post for the current user.\"\"\"",
                "first_doc": "\"\"\"\nHandles the creation of a new blog post via a web form.\n\nProcesses both GET and POST requests. For GET requests, it displays the form for creating a new post. For POST requests, it validates the input, adds the post to the database if valid, flashes errors when necessary, and redirects the user after successful creation.\n\nReturns:\n    The rendered template for the post creation form if the request is GET or if form validation fails; otherwise, a redirect response to the blog index on successful post creation.\n\"\"\"",
                "method_name": "create",
                "second_doc": "\"\"\"\nManages user-initiated requests for creating new content entries through a web interface.\n\nOn receiving a GET request, the method presents an interactive form to the user for entering details of the new entry. When a POST request is received, it verifies that required fields are provided, displays immediate feedback on missing information, and if validation succeeds, stores the new entry with a reference to the current user before redirecting to the main listing page.\n\nThis approach ensures user input is validated before being stored, only authenticated users can create content, and users receive prompt navigation and messaging based on their actions.\n\nArgs:\n    None directly. Accesses form data from the global request object and user context.\n\nReturns:\n    Response: The rendered creation form template if accessed via GET or if validation fails; otherwise, an HTTP redirect to the main listing of entries after successful creation.\n\"\"\"",
                "source_code": "if request.method == \"POST\":\n        title = request.form[\"title\"]\n        body = request.form[\"body\"]\n        error = None\n\n        if not title:\n            error = \"Title is required.\"\n\n        if error is not None:\n            flash(error)\n        else:\n            db = get_db()\n            db.execute(\n                \"INSERT INTO post (title, body, author_id) VALUES (?, ?, ?)\",\n                (title, body, g.user[\"id\"]),\n            )\n            db.commit()\n            return redirect(url_for(\"blog.index\"))\n\n    return render_template(\"blog/create.html\")"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": "\"\"\"Update a post if the current user is the author.\"\"\"",
                "first_doc": "\"\"\"\nHandles displaying and processing the blog post update form.\n\nArgs:\n    id: The unique identifier of the post to update.\n\nReturns:\n    A redirect response to the blog index if the update is successful, or an HTML page rendering the update form with current post data if the request is a GET or the form submission is invalid.\n\"\"\"",
                "method_name": "update",
                "second_doc": "\"\"\"\nHandles display and processing of the form used to update an existing blog post entry.\n\nThis method ensures that users can modify post details while validating input to maintain data integrity. It retrieves the targeted post, displays its current information for editing, and processes updates when submitted.\n\nArgs:\n    id (int): The unique identifier of the post to be updated.\n\nReturns:\n    Response: Redirects to the blog index page if the update is successful. Otherwise, renders the update form template with the current post data if the request is a GET or if there are validation errors.\n\"\"\"",
                "source_code": "post = get_post(id)\n\n    if request.method == \"POST\":\n        title = request.form[\"title\"]\n        body = request.form[\"body\"]\n        error = None\n\n        if not title:\n            error = \"Title is required.\"\n\n        if error is not None:\n            flash(error)\n        else:\n            db = get_db()\n            db.execute(\n                \"UPDATE post SET title = ?, body = ? WHERE id = ?\", (title, body, id)\n            )\n            db.commit()\n            return redirect(url_for(\"blog.index\"))\n\n    return render_template(\"blog/update.html\", post=post)"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": "\"\"\"Delete a post.\n\n    Ensures that the post exists and that the logged in user is the\n    author of the post.\n    \"\"\"",
                "first_doc": "\"\"\"\nDeletes a post with the specified ID from the database.\n\nArgs:\n    id: The unique identifier of the post to be deleted.\n\nReturns:\n    A redirect response to the blog index page after successful deletion of the post.\n\"\"\"",
                "method_name": "delete",
                "second_doc": "\"\"\"\nRemoves a specific post from persistent storage after verifying user authorization.\n\nArgs:\n    id (int): The unique identifier of the post to be removed.\n\nReturns:\n    Response: A redirect to the main listing page once the post is deleted, ensuring users see the updated list of posts.\n\nWhy:\n    This method enables users to manage their content by permanently deleting posts they no longer wish to maintain, keeping the database current and relevant to user intentions.\n\"\"\"",
                "source_code": "get_post(id)\n    db = get_db()\n    db.execute(\"DELETE FROM post WHERE id = ?\", (id,))\n    db.commit()\n    return redirect(url_for(\"blog.index\"))"
            },
            "type": "function"
        }
    ],
    "flask/examples/tutorial/flaskr/db.py": [
        {
            "details": {
                "docstring": "\"\"\"Connect to the application's configured database. The connection\n    is unique for each request and will be reused if this is called\n    again.\n    \"\"\"",
                "first_doc": "\"\"\"\nEstablishes a connection to the database and returns the connection object.\n\nChecks if a database connection already exists in the Flask application context variable `g`. If not, establishes a new SQLite database connection with the application's configured database path and sets the row factory for results.\n\nReturns:\n    A database connection object stored in the application context (`g.db`).\n\"\"\"",
                "method_name": "get_db",
                "second_doc": "\"\"\"\nEnsures each request has access to a single, properly configured database connection by initializing and storing it in the Flask application context if not already present. This approach helps manage database resources efficiently within the request lifecycle.\n\nArgs:\n    None\n\nReturns:\n    sqlite3.Connection: The current request's active database connection from the Flask application context.\n\"\"\"",
                "source_code": "if \"db\" not in g:\n        g.db = sqlite3.connect(\n            current_app.config[\"DATABASE\"], detect_types=sqlite3.PARSE_DECLTYPES\n        )\n        g.db.row_factory = sqlite3.Row\n\n    return g.db"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": "\"\"\"If this request connected to the database, close the\n    connection.\n    \"\"\"",
                "first_doc": "\"\"\"\nCloses the database connection if it exists in the Flask application context.\n\nThis method checks if a database connection is stored in the Flask global context variable and closes it if present.\n\nReturns:\n    None: This method does not return a value.\n\"\"\"",
                "method_name": "close_db",
                "second_doc": "\"\"\"\nSafely releases the application's database connection stored in the global context.\n\nBy removing and closing the database connection from the application's context, this method helps prevent resource leaks and ensures efficient utilization of database resources during the application's lifecycle.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "db = g.pop(\"db\", None)\n\n    if db is not None:\n        db.close()"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": "\"\"\"Clear existing data and create new tables.\"\"\"",
                "first_doc": "\"\"\"\nInitializes the database using the schema defined in the schema.sql file.\n\nThis method reads the schema.sql file from the current application's resources and executes its SQL statements to set up the database schema.\n\nReturns:\n    None: This method does not return a value.\n\"\"\"",
                "method_name": "init_db",
                "second_doc": "\"\"\"\nSets up the application's database structure by executing the SQL statements defined in the schema.sql file.\n\nThis method ensures that all necessary tables and relations required for the application to function are established in the database. By initializing the schema in a consistent way, it helps provide a stable foundation for storing and retrieving application data.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "db = get_db()\n\n    with current_app.open_resource(\"schema.sql\") as f:\n        db.executescript(f.read().decode(\"utf8\"))"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": "\"\"\"Clear existing data and create new tables.\"\"\"",
                "first_doc": "\"\"\"\nInitializes the application's database by running database setup routines.\n\nThis command is intended to be executed from the command line interface to ensure that the required database tables and initial schema are ready for use.\n\nReturns:\n    None: This function does not return a value.\n\"\"\"",
                "method_name": "init_db_command",
                "second_doc": "\"\"\"\nSets up the necessary database infrastructure by executing setup routines within the application's context.\n\nThis command ensures that the backend data storage is properly structured before the application is used, preventing errors related to missing tables or schemas.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "init_db()\n    click.echo(\"Initialized the database.\")"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": "\"\"\"Register database functions with the Flask app. This is called by\n    the application factory.\n    \"\"\"",
                "first_doc": "\"\"\"\nConfigures the given application with database teardown and initialization CLI commands.\n\nArgs:\n    app: The application instance to initialize with teardown and database CLI functionality.\n\nReturns:\n    None: This method does not return a value.\n\"\"\"",
                "method_name": "init_app",
                "second_doc": "\"\"\"\nSets up the application to automatically close the database connection on teardown and adds a custom database initialization command to the application's CLI interface.\n\nThis ensures database resources are managed efficiently and provides developers with tools for easy database initialization during application development and deployment.\n\nArgs:\n    app: The application instance that will be configured with database resource management and CLI command integration.\n\nReturns:\n    None: The function modifies the application instance in-place and does not return anything.\n\"\"\"",
                "source_code": "app.teardown_appcontext(close_db)\n    app.cli.add_command(init_db_command)"
            },
            "type": "function"
        }
    ],
    "flask/examples/tutorial/setup.py": [],
    "flask/examples/tutorial/tests/conftest.py": [
        {
            "details": {
                "docstring": "\"\"\"Create and configure a new app instance for each test.\"\"\"",
                "first_doc": "\"\"\"\nCreates and configures a Flask application instance for testing with a temporary and isolated database.\n\nThis function sets up an application context, initializes the database, loads test data, and yields the app for use in tests. It ensures that each test has its own unique database which is cleaned up after testing.\n\nReturns:\n    app: The configured Flask application instance ready for testing.\n\"\"\"",
                "method_name": "app",
                "second_doc": "\"\"\"\nSets up and provides a Flask application instance pre-configured with a temporary, isolated database for use in automated tests.\n\nBy generating a unique database for each run and populating it with test data, this method helps to ensure that test cases are reliably repeatable and unaffected by side effects from previous or parallel tests. This isolation preserves the integrity and independence of each test, supporting more accurate development and troubleshooting.\n\nArgs:\n    None\n\nYields:\n    app: The Flask application instance, configured for testing with its own isolated database.\n\"\"\"",
                "source_code": "# create a temporary file to isolate the database for each test\n    db_fd, db_path = tempfile.mkstemp()\n    # create the app with common test config\n    app = create_app({\"TESTING\": True, \"DATABASE\": db_path})\n\n    # create the database and load test data\n    with app.app_context():\n        init_db()\n        get_db().executescript(_data_sql)\n\n    yield app\n\n    # close and remove the temporary database\n    os.close(db_fd)\n    os.unlink(db_path)"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": "\"\"\"A test client for the app.\"\"\"",
                "first_doc": "\"\"\"\nCreates and returns a test client for the given Flask application.\n\nArgs:\n    app: The Flask application instance for which to create a test client.\n\nReturns:\n    A test client instance for the provided Flask app, allowing you to simulate requests to the application in a testing environment.\n\"\"\"",
                "method_name": "client",
                "second_doc": "\"\"\"\nInitializes and returns a test client for the specified Flask application to facilitate the simulation and verification of HTTP requests during development and testing processes.\n\nArgs:\n    app: The Flask application instance used to create the test client.\n\nReturns:\n    A Werkzeug test client instance configured for the given Flask app, enabling simulation of HTTP requests and responses for application testing.\n\"\"\"",
                "source_code": "return app.test_client()"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": "\"\"\"A test runner for the app's Click commands.\"\"\"",
                "first_doc": "\"\"\"\nCreates and returns a test command line runner for the given app.\n\nArgs:\n    app: The application instance for which to create the test CLI runner.\n\nReturns:\n    A test CLI runner instance for executing CLI commands against the provided application.\n\"\"\"",
                "method_name": "runner",
                "second_doc": "\"\"\"\nInitializes and provides a command line test runner bound to the specified application instance, enabling automated verification and interaction with the application's CLI commands in a controlled test environment.\n\nArgs:\n    app: The Flask application instance to be tested.\n\nReturns:\n    A test CLI runner object for executing command line operations against the given application within a test context.\n\"\"\"",
                "source_code": "return app.test_cli_runner()"
            },
            "type": "function"
        },
        {
            "methods": [
                {
                    "docstring": null,
                    "method_name": "__init__",
                    "second_doc": "\"\"\"\nInitializes the AuthActions class with a test client instance.\n\nArgs:\n    client: The testing client instance used to simulate HTTP requests.\n\nReturns:\n    None\n\nThis method establishes the connection between the AuthActions utility and the provided client, allowing for the simulation of authentication-related actions in a controlled testing environment. This supports streamlined and reliable testing of request-handling logic within the application.\n\"\"\"",
                    "source_code": "self._client = client"
                },
                {
                    "docstring": null,
                    "method_name": "login",
                    "second_doc": "\"\"\"\nSends a POST request to the login endpoint with the provided user credentials to authenticate the user.\n\nBy performing this action, the method facilitates verifying user identity and establishing a new session so subsequent requests can be made on behalf of the authenticated user.\n\nArgs:\n    username (str): The username of the user attempting to log in.\n    password (str): The password associated with the username.\n\nReturns:\n    Response: The response object returned by the client after attempting authentication.\n\"\"\"",
                    "source_code": "return self._client.post(\n            \"/auth/login\", data={\"username\": username, \"password\": password}\n        )"
                },
                {
                    "docstring": null,
                    "method_name": "logout",
                    "second_doc": "\"\"\"\nLogs the user out by sending a GET request to the logout endpoint.\n\nThis method triggers a request to terminate the user's session, ensuring that authentication credentials are invalidated and access to protected resources is revoked.\n\nArgs:\n    None\n\nReturns:\n    Response: The response object resulting from the logout request.\n\"\"\"",
                    "source_code": "return self._client.get(\"/auth/logout\")"
                }
            ],
            "name": "AuthActions",
            "type": "class"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "auth",
                "second_doc": "\"\"\"\nCreate and return an authentication actions handler associated with the provided client.\n\nArgs:\n    client: The client instance with which authentication actions will be performed.\n\nReturns:\n    AuthActions: An object that provides authentication-related actions for the given client.\n\nWhy:\n    This method facilitates interaction with user authentication processes, making it easier to manage login, logout, and other auth workflows in a web application context.\n\"\"\"",
                "source_code": "return AuthActions(client)"
            },
            "type": "function"
        }
    ],
    "flask/examples/tutorial/tests/test_auth.py": [
        {
            "details": {
                "docstring": null,
                "method_name": "test_register",
                "second_doc": "\"\"\"\nTests the registration route by verifying access, successful user creation, and appropriate redirection during the registration process.\n\nThis method ensures that the registration functionality operates as expected by:\n- Confirming registration page is accessible.\n- Validating that upon successful registration, the user is redirected to the login page.\n- Checking that the new user is properly inserted into the database.\n\nArgs:\n    client: A test client instance used to simulate requests to the application.\n    app: The Flask application instance.\n\nReturns:\n    None\n\"\"\"",
                "source_code": "assert client.get(\"/auth/register\").status_code == 200\n\n    # test that successful registration redirects to the login page\n    response = client.post(\"/auth/register\", data={\"username\": \"a\", \"password\": \"a\"})\n    assert \"http://localhost/auth/login\" == response.headers[\"Location\"]\n\n    # test that the user was inserted into the database\n    with app.app_context():\n        assert (\n            get_db().execute(\"select * from user where username = 'a'\").fetchone()\n            is not None\n        )"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_register_validate_input",
                "second_doc": "\"\"\"\nTests the registration endpoint to ensure that user input validation works correctly by submitting various invalid username and password combinations and checking for the appropriate error messages in the response.\n\nArgs:\n    username (str): The username value to send in the registration request.\n    password (str): The password value to send in the registration request.\n    message (bytes): The expected error message in the response.\n\nReturns:\n    None: Asserts within the method verify the endpoint's input validation behavior.\n    \nWhy:\n    This testing ensures that the registration process properly handles incomplete or invalid user input, which helps maintain application integrity and provides clear feedback to users.\n\"\"\"",
                "source_code": "response = client.post(\n        \"/auth/register\", data={\"username\": username, \"password\": password}\n    )\n    assert message in response.data"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_login",
                "second_doc": "\"\"\"\nTest the login functionality by verifying that the login page loads, a successful login redirects to the index, and that user session and context are set appropriately.\n\nArgs:\n    client: A test client instance for sending HTTP requests.\n    auth: An authentication helper for simulating user login.\n\nReturns:\n    None. Assertions within the test will fail if login functionality does not behave as expected.\n\nWhy:\n    Ensuring the login workflow works correctly is essential for maintaining secure access and expected user experience in the web application.\n\"\"\"",
                "source_code": "assert client.get(\"/auth/login\").status_code == 200\n\n    # test that successful login redirects to the index page\n    response = auth.login()\n    assert response.headers[\"Location\"] == \"http://localhost/\"\n\n    # login request set the user_id in the session\n    # check that the user is loaded from the session\n    with client:\n        client.get(\"/\")\n        assert session[\"user_id\"] == 1\n        assert g.user[\"username\"] == \"test\""
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_login_validate_input",
                "second_doc": "\"\"\"\nTests that the login function properly handles incorrect username and password input by returning the appropriate error messages.\n\nArgs:\n    username (str): The username provided for authentication.\n    password (str): The password provided for authentication.\n    message (bytes): The expected error message in the response data.\n\nReturns:\n    None: Asserts that the expected error message is present in the server response.\n    \nRaises:\n    AssertionError: If the expected message is not found in the response data.\n\"\"\"",
                "source_code": "response = auth.login(username, password)\n    assert message in response.data"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_logout",
                "second_doc": "\"\"\"\nTests the logout functionality by verifying that user session data is removed after logging out.\n\nThis ensures that upon logout, the application properly clears user authentication information, maintaining security and expected session management.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "auth.login()\n\n    with client:\n        auth.logout()\n        assert \"user_id\" not in session"
            },
            "type": "function"
        }
    ],
    "flask/examples/tutorial/tests/test_blog.py": [
        {
            "details": {
                "docstring": null,
                "method_name": "test_index",
                "second_doc": "\"\"\"\nTests that the application's index page displays the correct content for unauthenticated and authenticated users. This ensures that key elements are visible based on the user's authentication state, thereby verifying the dynamic rendering logic of the web interface.\n\nArgs:\n    None directly; uses test fixtures such as client and auth for making requests and simulating login.\n\nReturns:\n    None. Asserts correctness of the rendered content as part of a test routine.\n\"\"\"",
                "source_code": "response = client.get(\"/\")\n    assert b\"Log In\" in response.data\n    assert b\"Register\" in response.data\n\n    auth.login()\n    response = client.get(\"/\")\n    assert b\"test title\" in response.data\n    assert b\"by test on 2018-01-01\" in response.data\n    assert b\"test\\nbody\" in response.data\n    assert b'href=\"/1/update\"' in response.data"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_login_required",
                "second_doc": "\"\"\"\nEnsures that attempting to access protected endpoints without authentication redirects the user to the login page.\n\nArgs:\n    path (str): The URL path being accessed during the test.\n\nReturns:\n    None\n\nWhy:\n    To verify that endpoints requiring authentication are properly secured, prompting unauthenticated users to log in before access is granted.\n\"\"\"",
                "source_code": "response = client.post(path)\n    assert response.headers[\"Location\"] == \"http://localhost/auth/login\""
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_author_required",
                "second_doc": "\"\"\"\nTests that users cannot modify or delete posts authored by others, ensuring proper access control and user permissions in the application.\n\nArgs:\n    None\n\nReturns:\n    None\n\nWhy:\n    This method ensures the application's integrity and security by verifying that users can only edit or delete their own posts and are restricted from modifying or accessing options for posts created by others.\n\"\"\"",
                "source_code": "with app.app_context():\n        db = get_db()\n        db.execute(\"UPDATE post SET author_id = 2 WHERE id = 1\")\n        db.commit()\n\n    auth.login()\n    # current user can't modify other user's post\n    assert client.post(\"/1/update\").status_code == 403\n    assert client.post(\"/1/delete\").status_code == 403\n    # current user doesn't see edit link\n    assert b'href=\"/1/update\"' not in client.get(\"/\").data"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_exists_required",
                "second_doc": "\"\"\"\nTests that accessing update or delete routes for a non-existent resource returns a 404 error.\n\nThis ensures the application properly handles attempts to modify or remove resources that do not exist, preventing unintended behavior or security issues.\n\nArgs:\n    path (str): The route to test, such as update or delete endpoints.\n\nReturns:\n    None\n\"\"\"",
                "source_code": "auth.login()\n    assert client.post(path).status_code == 404"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_create",
                "second_doc": "\"\"\"\nTest that an authenticated user can access the post creation page, submit a new post, and that the post is successfully stored in the database.\n\nArgs:\n    None\n\nReturns:\n    None\n\nWhy:\n    This method verifies that the process for creating new content operates correctly, ensuring both the user interface for content creation and the backend data persistence work as intended. This is essential to maintain consistent and reliable user experiences when interacting with the application's core features.\n\"\"\"",
                "source_code": "auth.login()\n    assert client.get(\"/create\").status_code == 200\n    client.post(\"/create\", data={\"title\": \"created\", \"body\": \"\"})\n\n    with app.app_context():\n        db = get_db()\n        count = db.execute(\"SELECT COUNT(id) FROM post\").fetchone()[0]\n        assert count == 2"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_update",
                "second_doc": "\"\"\"\nTests the update functionality of a blog post to ensure that changes made through the web interface are correctly persisted in the application's database.\n\nThis method verifies that the update endpoint is accessible after authentication, that a post's title can be modified via a POST request, and that the changes are reflected in the database. This helps guarantee that users' edits to content are reliably processed and stored by the application.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "auth.login()\n    assert client.get(\"/1/update\").status_code == 200\n    client.post(\"/1/update\", data={\"title\": \"updated\", \"body\": \"\"})\n\n    with app.app_context():\n        db = get_db()\n        post = db.execute(\"SELECT * FROM post WHERE id = 1\").fetchone()\n        assert post[\"title\"] == \"updated\""
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_create_update_validate",
                "second_doc": "\"\"\"\nTest that form submission to creation and update endpoints with empty fields triggers validation errors.\n\nArgs:\n    path (str): The endpoint being tested (either creation or update path).\n\nReturns:\n    None. Asserts that the response contains an appropriate validation error message.\n    \nWhy:\n    This method ensures that the application enforces required input validation, thereby preserving data integrity and providing immediate user feedback when form fields are left blank.\n\"\"\"",
                "source_code": "auth.login()\n    response = client.post(path, data={\"title\": \"\", \"body\": \"\"})\n    assert b\"Title is required.\" in response.data"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_delete",
                "second_doc": "\"\"\"\nTests that a post can be successfully deleted and ensures it is removed from the database.  \nThis verifies the application's ability to process deletion requests and maintain data consistency.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "auth.login()\n    response = client.post(\"/1/delete\")\n    assert response.headers[\"Location\"] == \"http://localhost/\"\n\n    with app.app_context():\n        db = get_db()\n        post = db.execute(\"SELECT * FROM post WHERE id = 1\").fetchone()\n        assert post is None"
            },
            "type": "function"
        }
    ],
    "flask/examples/tutorial/tests/test_db.py": [
        {
            "details": {
                "docstring": null,
                "method_name": "test_get_close_db",
                "second_doc": "\"\"\"\nTests that the database connection is reused within the application context and properly closed when the context ends.\n\nThis ensures that database resources are efficiently managed and errors are appropriately raised when attempting to interact with the database after it is closed.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "with app.app_context():\n        db = get_db()\n        assert db is get_db()\n\n    with pytest.raises(sqlite3.ProgrammingError) as e:\n        db.execute(\"SELECT 1\")\n\n    assert \"closed\" in str(e.value)"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_init_db_command",
                "second_doc": "\"\"\"\nTests the application's database initialization command, ensuring it properly triggers the initialization logic and provides user feedback. Verifies the CLI command integrates with application infrastructure as expected.\n\nArgs:\n    monkeypatch: Pytest fixture for replacing parts of the system under test.\n    runner: CLI test runner for invoking commands.\n\nReturns:\n    None. Asserts are used to validate correct side effects and output.\n\"\"\"",
                "source_code": "class Recorder:\n        called = False\n\n    def fake_init_db():\n        Recorder.called = True\n\n    monkeypatch.setattr(\"flaskr.db.init_db\", fake_init_db)\n    result = runner.invoke(args=[\"init-db\"])\n    assert \"Initialized\" in result.output\n    assert Recorder.called"
            },
            "type": "function"
        }
    ],
    "flask/examples/tutorial/tests/test_factory.py": [
        {
            "details": {
                "docstring": "\"\"\"Test create_app without passing test config.\"\"\"",
                "first_doc": "\"\"\"\nTests the configuration of the application in different modes.\n\nThis method asserts that the application's 'testing' configuration\nflag behaves as expected when initialized with and without the\n'TESTING' parameter.\n\nReturns:\n    None: This method does not return a value.\n\"\"\"",
                "method_name": "test_config",
                "second_doc": "\"\"\"\nVerifies that the application correctly recognizes and responds to the presence or absence of the 'TESTING' configuration flag.\n\nThis test ensures that the application's testing mode can be toggled as intended, allowing reliable separation between normal and test behavior for different environments.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "assert not create_app().testing\n    assert create_app({\"TESTING\": True}).testing"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_hello",
                "second_doc": "\"\"\"\nTests whether the '/hello' route returns the expected response from the application.\n\nThis method ensures that the application correctly handles requests to the '/hello' endpoint by returning the appropriate data, which helps maintain the reliability and correctness of the web server.\n\nArgs:\n    client: A test client instance used to simulate HTTP requests to the application.\n\nReturns:\n    None. Asserts that the response data matches the expected output.\n\"\"\"",
                "source_code": "response = client.get(\"/hello\")\n    assert response.data == b\"Hello, World!\""
            },
            "type": "function"
        }
    ],
    "flask/setup.py": [],
    "flask/src/flask/__init__.py": [],
    "flask/src/flask/__main__.py": [],
    "flask/src/flask/app.py": [
        {
            "details": {
                "docstring": null,
                "method_name": "_make_timedelta",
                "second_doc": "\"\"\"\nConverts the input value to a timedelta object if it is not already one. This ensures consistent handling of time durations within the application.\n\nArgs:\n    value (int, float, timedelta): The value representing a time duration, either already as a timedelta or as a numeric value in seconds.\n\nReturns:\n    timedelta: A timedelta object representing the specified time duration.\n\"\"\"",
                "source_code": "if not isinstance(value, timedelta):\n        return timedelta(seconds=value)\n    return value"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": "\"\"\"Wraps a method so that it performs a check in debug mode if the\n    first request was already handled.\n    \"\"\"",
                "first_doc": "\"\"\"\nMarks a function as a setup method that should not be called after the first request is handled.\n\nArgs:\n    f: The function to be wrapped as a setup method.\n\nReturns:\n    A function object that wraps the input function and enforces that it is not called after the first request if debugging is enabled.\n\"\"\"",
                "method_name": "setupmethod",
                "second_doc": "\"\"\"\nDecorator that designates a method as part of the application setup process, ensuring it is not called after the initial request is processed.\n\nThis restriction helps catch misconfigurations or late imports that could result in inconsistent or erroneous application behavior.\n\nArgs:\n    f: The method to be wrapped and protected from execution after the application has handled its first request.\n\nReturns:\n    The wrapped function that raises an AssertionError if called after the initial request when debugging is enabled, otherwise behaves normally.\n\"\"\"",
                "source_code": "def wrapper_func(self, *args, **kwargs):\n        if self.debug and self._got_first_request:\n            raise AssertionError(\n                \"A setup function was called after the \"\n                \"first request was handled.  This usually indicates a bug \"\n                \"in the application where a module was not imported \"\n                \"and decorators or other functionality was called too late.\\n\"\n                \"To fix this make sure to import all your view modules, \"\n                \"database models and everything related at a central place \"\n                \"before the application starts serving requests.\"\n            )\n        return f(self, *args, **kwargs)\n\n    return update_wrapper(wrapper_func, f)"
            },
            "type": "function"
        },
        {
            "methods": [
                {
                    "docstring": null,
                    "method_name": "__init__",
                    "second_doc": "\"\"\"\nInitialize the core state and configuration of a web application instance, setting up routing, static file handling, request and error processing, extension registration, and other foundational features needed to manage the application's lifecycle and request/response flow.\n\nArgs:\n    import_name (str): The name of the application package or module.\n    static_url_path (str, optional): URL path for the static files route. Defaults to None.\n    static_folder (str, optional): Filesystem path to the static files folder. Defaults to 'static'.\n    static_host (str, optional): Host to use for serving static files. Defaults to None.\n    host_matching (bool, optional): Enable host-based route matching. Defaults to False.\n    subdomain_matching (bool, optional): Enable subdomain-based route matching. Defaults to False.\n    template_folder (str, optional): Filesystem path to the template folder. Defaults to 'templates'.\n    instance_path (str, optional): Absolute path to the application instance folder. If None, it will be automatically determined.\n    instance_relative_config (bool, optional): Whether the configuration is relative to the instance path. Defaults to False.\n    root_path (str, optional): The root path of the application. If None, it is determined automatically.\n\nReturns:\n    None\n\nWhy:\n    This method organizes all application components and context required for receiving and processing web requests, ensuring that routing, configuration, and resource handling are ready to support dynamic and extensible web app development workflows.\n\"\"\"",
                    "source_code": "_PackageBoundObject.__init__(\n            self, import_name, template_folder=template_folder, root_path=root_path\n        )\n\n        self.static_url_path = static_url_path\n        self.static_folder = static_folder\n\n        if instance_path is None:\n            instance_path = self.auto_find_instance_path()\n        elif not os.path.isabs(instance_path):\n            raise ValueError(\n                \"If an instance path is provided it must be absolute.\"\n                \" A relative path was given instead.\"\n            )\n\n        #: Holds the path to the instance folder.\n        #:\n        #: .. versionadded:: 0.8\n        self.instance_path = instance_path\n\n        #: The configuration dictionary as :class:`Config`.  This behaves\n        #: exactly like a regular dictionary but supports additional methods\n        #: to load a config from files.\n        self.config = self.make_config(instance_relative_config)\n\n        #: A dictionary of all view functions registered.  The keys will\n        #: be function names which are also used to generate URLs and\n        #: the values are the function objects themselves.\n        #: To register a view function, use the :meth:`route` decorator.\n        self.view_functions = {}\n\n        #: A dictionary of all registered error handlers.  The key is ``None``\n        #: for error handlers active on the application, otherwise the key is\n        #: the name of the blueprint.  Each key points to another dictionary\n        #: where the key is the status code of the http exception.  The\n        #: special key ``None`` points to a list of tuples where the first item\n        #: is the class for the instance check and the second the error handler\n        #: function.\n        #:\n        #: To register an error handler, use the :meth:`errorhandler`\n        #: decorator.\n        self.error_handler_spec = {}\n\n        #: A list of functions that are called when :meth:`url_for` raises a\n        #: :exc:`~werkzeug.routing.BuildError`.  Each function registered here\n        #: is called with `error`, `endpoint` and `values`.  If a function\n        #: returns ``None`` or raises a :exc:`BuildError` the next function is\n        #: tried.\n        #:\n        #: .. versionadded:: 0.9\n        self.url_build_error_handlers = []\n\n        #: A dictionary with lists of functions that will be called at the\n        #: beginning of each request. The key of the dictionary is the name of\n        #: the blueprint this function is active for, or ``None`` for all\n        #: requests. To register a function, use the :meth:`before_request`\n        #: decorator.\n        self.before_request_funcs = {}\n\n        #: A list of functions that will be called at the beginning of the\n        #: first request to this instance. To register a function, use the\n        #: :meth:`before_first_request` decorator.\n        #:\n        #: .. versionadded:: 0.8\n        self.before_first_request_funcs = []\n\n        #: A dictionary with lists of functions that should be called after\n        #: each request.  The key of the dictionary is the name of the blueprint\n        #: this function is active for, ``None`` for all requests.  This can for\n        #: example be used to close database connections. To register a function\n        #: here, use the :meth:`after_request` decorator.\n        self.after_request_funcs = {}\n\n        #: A dictionary with lists of functions that are called after\n        #: each request, even if an exception has occurred. The key of the\n        #: dictionary is the name of the blueprint this function is active for,\n        #: ``None`` for all requests. These functions are not allowed to modify\n        #: the request, and their return values are ignored. If an exception\n        #: occurred while processing the request, it gets passed to each\n        #: teardown_request function. To register a function here, use the\n        #: :meth:`teardown_request` decorator.\n        #:\n        #: .. versionadded:: 0.7\n        self.teardown_request_funcs = {}\n\n        #: A list of functions that are called when the application context\n        #: is destroyed.  Since the application context is also torn down\n        #: if the request ends this is the place to store code that disconnects\n        #: from databases.\n        #:\n        #: .. versionadded:: 0.9\n        self.teardown_appcontext_funcs = []\n\n        #: A dictionary with lists of functions that are called before the\n        #: :attr:`before_request_funcs` functions. The key of the dictionary is\n        #: the name of the blueprint this function is active for, or ``None``\n        #: for all requests. To register a function, use\n        #: :meth:`url_value_preprocessor`.\n        #:\n        #: .. versionadded:: 0.7\n        self.url_value_preprocessors = {}\n\n        #: A dictionary with lists of functions that can be used as URL value\n        #: preprocessors.  The key ``None`` here is used for application wide\n        #: callbacks, otherwise the key is the name of the blueprint.\n        #: Each of these functions has the chance to modify the dictionary\n        #: of URL values before they are used as the keyword arguments of the\n        #: view function.  For each function registered this one should also\n        #: provide a :meth:`url_defaults` function that adds the parameters\n        #: automatically again that were removed that way.\n        #:\n        #: .. versionadded:: 0.7\n        self.url_default_functions = {}\n\n        #: A dictionary with list of functions that are called without argument\n        #: to populate the template context.  The key of the dictionary is the\n        #: name of the blueprint this function is active for, ``None`` for all\n        #: requests.  Each returns a dictionary that the template context is\n        #: updated with.  To register a function here, use the\n        #: :meth:`context_processor` decorator.\n        self.template_context_processors = {None: [_default_template_ctx_processor]}\n\n        #: A list of shell context processor functions that should be run\n        #: when a shell context is created.\n        #:\n        #: .. versionadded:: 0.11\n        self.shell_context_processors = []\n\n        #: all the attached blueprints in a dictionary by name.  Blueprints\n        #: can be attached multiple times so this dictionary does not tell\n        #: you how often they got attached.\n        #:\n        #: .. versionadded:: 0.7\n        self.blueprints = {}\n        self._blueprint_order = []\n\n        #: a place where extensions can store application specific state.  For\n        #: example this is where an extension could store database engines and\n        #: similar things.\n        #:\n        #: The key must match the name of the extension module. For example in\n        #: case of a \"Flask-Foo\" extension in `flask_foo`, the key would be\n        #: ``'foo'``.\n        #:\n        #: .. versionadded:: 0.7\n        self.extensions = {}\n\n        #: The :class:`~werkzeug.routing.Map` for this instance.  You can use\n        #: this to change the routing converters after the class was created\n        #: but before any routes are connected.  Example::\n        #:\n        #:    from werkzeug.routing import BaseConverter\n        #:\n        #:    class ListConverter(BaseConverter):\n        #:        def to_python(self, value):\n        #:            return value.split(',')\n        #:        def to_url(self, values):\n        #:            return ','.join(super(ListConverter, self).to_url(value)\n        #:                            for value in values)\n        #:\n        #:    app = Flask(__name__)\n        #:    app.url_map.converters['list'] = ListConverter\n        self.url_map = self.url_map_class()\n\n        self.url_map.host_matching = host_matching\n        self.subdomain_matching = subdomain_matching\n\n        # tracks internally if the application already handled at least one\n        # request.\n        self._got_first_request = False\n        self._before_request_lock = Lock()\n\n        # Add a static route using the provided static_url_path, static_host,\n        # and static_folder if there is a configured static_folder.\n        # Note we do this without checking if static_folder exists.\n        # For one, it might be created while the server is running (e.g. during\n        # development). Also, Google App Engine stores static files somewhere\n        if self.has_static_folder:\n            assert (\n                bool(static_host) == host_matching\n            ), \"Invalid static_host/host_matching combination\"\n            self.add_url_rule(\n                f\"{self.static_url_path}/<path:filename>\",\n                endpoint=\"static\",\n                host=static_host,\n                view_func=self.send_static_file,\n            )\n\n        # Set the name of the Click group in case someone wants to add\n        # the app's commands to another CLI tool.\n        self.cli.name = self.name"
                },
                {
                    "docstring": "\"\"\"The name of the application.  This is usually the import name\n        with the difference that it's guessed from the run file if the\n        import name is main.  This name is used as a display name when\n        Flask needs the name of the application.  It can be set and overridden\n        to change the value.\n\n        .. versionadded:: 0.8\n        \"\"\"",
                    "first_doc": "\"\"\"\nReturns the display name of the application, which is typically derived from the import name. If the import name is \"__main__\", the name is guessed based on the run file's filename; otherwise, it is set to the import name. This value can be set or overridden if a different display name is needed.\n\nArgs:\n    self: The instance of the class.\n\nReturns:\n    str: The display name of the application.\n\"\"\"",
                    "method_name": "name",
                    "second_doc": "\"\"\"\nDetermines and returns a human-readable name for the current application instance. If the application is executed directly, the name is inferred from the filename of the script being run; otherwise, it uses the provided import name. This approach ensures that the application instance has a meaningful identifier regardless of how it is launched, which is useful for debugging, logging, and configuration.\n\nArgs:\n    self: The Flask application instance.\n\nReturns:\n    str: A string representing the name used to identify the application instance.\n\"\"\"",
                    "source_code": "if self.import_name == \"__main__\":\n            fn = getattr(sys.modules[\"__main__\"], \"__file__\", None)\n            if fn is None:\n                return \"__main__\"\n            return os.path.splitext(os.path.basename(fn))[0]\n        return self.import_name"
                },
                {
                    "docstring": "\"\"\"Returns the value of the ``PROPAGATE_EXCEPTIONS`` configuration\n        value in case it's set, otherwise a sensible default is returned.\n\n        .. versionadded:: 0.7\n        \"\"\"",
                    "first_doc": "\"\"\"\nDetermines whether exceptions should be propagated instead of handled internally.\n\nThis property checks the 'PROPAGATE_EXCEPTIONS' configuration. If it's explicitly set, the configured value is returned. Otherwise, it provides a sensible default based on the application's 'testing' or 'debug' mode.\n\nArgs:\n    self: The instance of the class.\n\nReturns:\n    Boolean indicating if exceptions should be propagated (True) or not (False).\n\"\"\"",
                    "method_name": "propagate_exceptions",
                    "second_doc": "\"\"\"\nDetermines if exceptions should be re-raised to allow higher-level error handling or debug inspection.\n\nThis property first checks if the 'PROPAGATE_EXCEPTIONS' config variable has been set; if so, that value is used. If not explicitly set, the decision falls back to whether the application is in testing or debug mode, promoting transparency during development and testing phases.\n\nBy propagating exceptions, developers can more easily detect, debug, or customize error handling behaviors, which is particularly useful in non-production environments.\n\nArgs:\n    self: The Flask application instance.\n\nReturns:\n    bool: True if exceptions should be propagated to the caller; False if they should be handled internally.\n\"\"\"",
                    "source_code": "rv = self.config[\"PROPAGATE_EXCEPTIONS\"]\n        if rv is not None:\n            return rv\n        return self.testing or self.debug"
                },
                {
                    "docstring": "\"\"\"Returns the value of the ``PRESERVE_CONTEXT_ON_EXCEPTION``\n        configuration value in case it's set, otherwise a sensible default\n        is returned.\n\n        .. versionadded:: 0.7\n        \"\"\"",
                    "first_doc": "\"\"\"\nReturns the value of the PRESERVE_CONTEXT_ON_EXCEPTION configuration or a default.\n\nRetrieves the value of the 'PRESERVE_CONTEXT_ON_EXCEPTION' setting from the instance's configuration. If this value is not set, returns the value of the 'debug' attribute as a sensible default.\n\nArgs:\n    self: The instance of the class.\n\nReturns:\n    The value of the 'PRESERVE_CONTEXT_ON_EXCEPTION' configuration if set, otherwise the value of the 'debug' attribute.\n\"\"\"",
                    "method_name": "preserve_context_on_exception",
                    "second_doc": "\"\"\"\nDetermines whether the application context should be preserved when an unhandled exception occurs, based on configuration or debug mode.\n\nThis property is essential to control the application's behavior in error situations, which affects debugging and error handling reliability during development and production.\n\nArgs:\n    self: The Flask application instance.\n\nReturns:\n    bool: True if context preservation is enabled through the 'PRESERVE_CONTEXT_ON_EXCEPTION' config or if the application is running in debug mode; otherwise, False.\n\"\"\"",
                    "source_code": "rv = self.config[\"PRESERVE_CONTEXT_ON_EXCEPTION\"]\n        if rv is not None:\n            return rv\n        return self.debug"
                },
                {
                    "docstring": "\"\"\"A standard Python :class:`~logging.Logger` for the app, with\n        the same name as :attr:`name`.\n\n        In debug mode, the logger's :attr:`~logging.Logger.level` will\n        be set to :data:`~logging.DEBUG`.\n\n        If there are no handlers configured, a default handler will be\n        added. See :doc:`/logging` for more information.\n\n        .. versionchanged:: 1.1.0\n            The logger takes the same name as :attr:`name` rather than\n            hard-coding ``\"flask.app\"``.\n\n        .. versionchanged:: 1.0.0\n            Behavior was simplified. The logger is always named\n            ``\"flask.app\"``. The level is only set during configuration,\n            it doesn't check ``app.debug`` each time. Only one format is\n            used, not different ones depending on ``app.debug``. No\n            handlers are removed, and a handler is only added if no\n            handlers are already configured.\n\n        .. versionadded:: 0.3\n        \"\"\"",
                    "first_doc": "\"\"\"\nReturns a standard Python Logger for the app, named after the instance's name attribute.\n\nIn debug mode, the logger's level is set to DEBUG. If no handlers are configured, a default handler is added. This method ensures consistent logger configuration for the app.\n\nArgs:\n    self: The instance of the class.\n\nReturns:\n    Logger: A configured Logger instance for the app.\n\"\"\"",
                    "method_name": "logger",
                    "second_doc": "\"\"\"\nProvides a configured Python Logger specific to the application's context, facilitating effective tracking and debugging of runtime events. By standardizing logger acquisition and setup, it guarantees uniform logging practices across different parts of the application, especially adjusting for debugging requirements based on configuration.\n\nArgs:\n    self: The Flask application instance for which the logger is being created.\n\nReturns:\n    Logger: A configured Logger instance tied to the application's name, with appropriate level and handlers to ensure consistent logging behavior.\n\"\"\"",
                    "source_code": "return create_logger(self)"
                },
                {
                    "docstring": "\"\"\"The Jinja environment used to load templates.\n\n        The environment is created the first time this property is\n        accessed. Changing :attr:`jinja_options` after that will have no\n        effect.\n        \"\"\"",
                    "first_doc": "\"\"\"\nGets the Jinja environment used to load templates.\n\nThe environment is created the first time this property is accessed. Modifying the `jinja_options` attribute after the environment has been initialized will not affect the returned environment.\n\nArgs:\n    self: The instance of the class.\n\nReturns:\n    The Jinja environment used for loading templates.\n\"\"\"",
                    "method_name": "jinja_env",
                    "second_doc": "\"\"\"\nInitializes and retrieves the Jinja environment responsible for processing and rendering templates within the application.\n\nBy constructing the environment on first access and subsequently caching it, this property ensures reliable and consistent template rendering performance throughout the application's lifecycle, even if configuration options are modified later.\n\nArgs:\n    self: The Flask application instance.\n\nReturns:\n    Environment: An instance of the Jinja environment used to interpret and render templates within the application context.\n\"\"\"",
                    "source_code": "return self.create_jinja_environment()"
                },
                {
                    "docstring": "\"\"\"This attribute is set to ``True`` if the application started\n        handling the first request.\n\n        .. versionadded:: 0.8\n        \"\"\"",
                    "first_doc": "\"\"\"\nIndicates whether the application has started handling the first request.\n\nReturns:\n    bool: True if the application has handled the first request; otherwise, False.\n\"\"\"",
                    "method_name": "got_first_request",
                    "second_doc": "\"\"\"\nChecks if the application has processed its first incoming request, which can be used to trigger initialization steps or to modify behavior on the very first request.\n\nReturns:\n    bool: True if the first request has already been handled by the application; False otherwise.\n\"\"\"",
                    "source_code": "return self._got_first_request"
                },
                {
                    "docstring": "\"\"\"Used to create the config attribute by the Flask constructor.\n        The `instance_relative` parameter is passed in from the constructor\n        of Flask (there named `instance_relative_config`) and indicates if\n        the config should be relative to the instance path or the root path\n        of the application.\n\n        .. versionadded:: 0.8\n        \"\"\"",
                    "first_doc": "\"\"\"\nCreates the configuration object for the Flask application.\n\nThis method uses the application's root or instance path to initialize configuration settings. It generates a dictionary of default configuration values, including environment and debug flags.\n\nArgs:\n    self: The Flask application instance.\n\nReturns:\n    An instance of the application's configuration class, initialized with the appropriate root path and default settings.\n\"\"\"",
                    "method_name": "make_config",
                    "second_doc": "\"\"\"\nInitializes and returns the configuration object tailored to the application's current environment and settings.\n\nThe method determines the configuration's root path based on whether relative instance configuration is used, establishes baseline configuration values, and injects environment-specific flags. This ensures the application has consistent and adaptive configuration parameters across different operating environments, promoting reliable and context-aware behavior.\n\nArgs:\n    self: The Flask application instance.\n\nReturns:\n    An instance of the application's configuration class, initialized with root path and default settings based on the current environment variables.\n\"\"\"",
                    "source_code": "root_path = self.root_path\n        if instance_relative:\n            root_path = self.instance_path\n        defaults = dict(self.default_config)\n        defaults[\"ENV\"] = get_env()\n        defaults[\"DEBUG\"] = get_debug_flag()\n        return self.config_class(root_path, defaults)"
                },
                {
                    "docstring": "\"\"\"Tries to locate the instance path if it was not provided to the\n        constructor of the application class.  It will basically calculate\n        the path to a folder named ``instance`` next to your main file or\n        the package.\n\n        .. versionadded:: 0.8\n        \"\"\"",
                    "first_doc": "\"\"\"\nAttempts to determine the instance path for the application if it was not provided during initialization.\n\nThis method calculates the path to a directory named 'instance' located next to the application's main file or within the package. If a prefix is available, it uses that to build a path under 'var' with an instance-specific subfolder.\n\nArgs:\n    self: The instance of the application class.\n\nReturns:\n    str: The resolved absolute path to the instance directory, either next to the package or under the environment prefix.\n\"\"\"",
                    "method_name": "auto_find_instance_path",
                    "second_doc": "\"\"\"\nDetermines the absolute filesystem path to the application's instance folder if it wasn't specified during initialization.\n\nThis method dynamically figures out a reliable location for storing instance-specific data and configurations that are outside the main source code. By checking the environment or main module's location, it ensures per-application separation of files that shouldn't be committed or shared.\n\nArgs:\n    self: The Flask application instance requesting its instance path.\n\nReturns:\n    str: The calculated absolute path to the instance directory, situated either adjacent to the application's code or under the environment prefix for standardized deployment.\n\"\"\"",
                    "source_code": "prefix, package_path = find_package(self.import_name)\n        if prefix is None:\n            return os.path.join(package_path, \"instance\")\n        return os.path.join(prefix, \"var\", f\"{self.name}-instance\")"
                },
                {
                    "docstring": "\"\"\"Opens a resource from the application's instance folder\n        (:attr:`instance_path`).  Otherwise works like\n        :meth:`open_resource`.  Instance resources can also be opened for\n        writing.\n\n        :param resource: the name of the resource.  To access resources within\n                         subfolders use forward slashes as separator.\n        :param mode: resource file opening mode, default is 'rb'.\n        \"\"\"",
                    "first_doc": "\"\"\"\nOpens a resource file located in the application's instance folder.\n\nThis method allows access to files stored in the instance folder, as defined by the class's 'instance_path' attribute. Resources within subfolders can be accessed using forward slashes as path separators. Unlike other resource-opening methods, this allows files to be opened for both reading and writing.\n\nArgs:\n    resource: The name of the resource file to open. Use forward slashes to specify files in subfolders.\n\nReturns:\n    A file object corresponding to the opened resource file, in the specified mode.\n\"\"\"",
                    "method_name": "open_instance_resource",
                    "second_doc": "\"\"\"\nEnables direct file operations on resources within the application's designated instance folder, supporting both reading and writing. This functionality is crucial for working with files intended to be application-specific, such as user-uploaded content or instance configuration, that are separate from the main application codebase.\n\nArgs:\n    resource (str): The relative path to the resource file within the instance folder. Forward slashes can be used to indicate subdirectories.\n    mode (str): The mode in which the file should be opened (e.g., 'r' for reading, 'w' for writing).\n\nReturns:\n    file object: An open file object for the specified resource in the given mode, ready for reading or writing operations.\n\"\"\"",
                    "source_code": "return open(os.path.join(self.instance_path, resource), mode)"
                },
                {
                    "docstring": "\"\"\"Reload templates when they are changed. Used by\n        :meth:`create_jinja_environment`.\n\n        This attribute can be configured with :data:`TEMPLATES_AUTO_RELOAD`. If\n        not set, it will be enabled in debug mode.\n\n        .. versionadded:: 1.0\n            This property was added but the underlying config and behavior\n            already existed.\n        \"\"\"",
                    "first_doc": "\"\"\"\nDetermines if Jinja templates should be reloaded when changed.\n\nThis property checks the configuration to see if automatic reloading of templates is enabled. If the configuration option is not set, it defaults to the application's debug mode.\n\nArgs:\n    self: The instance of the class.\n\nReturns:\n    bool: True if templates should be automatically reloaded on changes, False otherwise.\n\"\"\"",
                    "method_name": "templates_auto_reload",
                    "second_doc": "\"\"\"\nChecks whether Jinja templates should be automatically reloaded when modified, using the configuration setting if available; otherwise, falls back to the debug mode. This ensures that template changes are reflected without restarting the application, improving the development workflow.\n\nArgs:\n    self: The Flask application instance.\n\nReturns:\n    bool: True if templates will reload automatically upon changes; False if template reloading is disabled.\n\"\"\"",
                    "source_code": "rv = self.config[\"TEMPLATES_AUTO_RELOAD\"]\n        return rv if rv is not None else self.debug"
                },
                {
                    "docstring": null,
                    "method_name": "templates_auto_reload",
                    "second_doc": "\"\"\"\nConfigures whether template files should be automatically reloaded when they are changed, ensuring that updates to templates are reflected without needing to restart the server.\n\nArgs:\n    value (bool): If True, template files will be automatically reloaded when they are modified. If False, templates will only be loaded once per server run.\n\nReturns:\n    None\n\"\"\"",
                    "source_code": "self.config[\"TEMPLATES_AUTO_RELOAD\"] = value"
                },
                {
                    "docstring": "\"\"\"Create the Jinja environment based on :attr:`jinja_options`\n        and the various Jinja-related methods of the app. Changing\n        :attr:`jinja_options` after this will have no effect. Also adds\n        Flask-related globals and filters to the environment.\n\n        .. versionchanged:: 0.11\n           ``Environment.auto_reload`` set in accordance with\n           ``TEMPLATES_AUTO_RELOAD`` configuration option.\n\n        .. versionadded:: 0.5\n        \"\"\"",
                    "first_doc": "\"\"\"\nCreates and configures the Jinja environment for the application.\n\nThis method initializes a Jinja environment using the application's Jinja options and various related methods. It ensures that autoescaping and auto-reloading behaviors are set appropriately, adds Flask-related globals (such as `url_for`, flash message handlers, application configuration, and request/session proxies), and registers the `tojson` filter. Changing `jinja_options` after calling this method has no effect on the environment created.\n\nParameters:\n    self: The Flask application instance for which the Jinja environment is being created.\n\nReturns:\n    A configured Jinja Environment instance with Flask's globals and filters added.\n\"\"\"",
                    "method_name": "create_jinja_environment",
                    "second_doc": "\"\"\"\nInitializes and configures a Jinja template environment tailored to the application's settings and context.\n\nBy assembling the environment with application-specific options, global objects, and custom filters, this method ensures that rendered templates in the application have seamless access to frequently used utilities (such as routing, notifications, and configuration), dynamic data, and serialization facilities. This integration supports efficient template rendering and maintains application consistency; changes to the environment options after initialization will not affect the created environment.\n\nArgs:\n    self: The application instance for which the template environment is being set up.\n\nReturns:\n    jinja2.Environment: A Jinja Environment instance with application-specific globals and filters registered.\n\"\"\"",
                    "source_code": "options = dict(self.jinja_options)\n\n        if \"autoescape\" not in options:\n            options[\"autoescape\"] = self.select_jinja_autoescape\n\n        if \"auto_reload\" not in options:\n            options[\"auto_reload\"] = self.templates_auto_reload\n\n        rv = self.jinja_environment(self, **options)\n        rv.globals.update(\n            url_for=url_for,\n            get_flashed_messages=get_flashed_messages,\n            config=self.config,\n            # request, session and g are normally added with the\n            # context processor for efficiency reasons but for imported\n            # templates we also want the proxies in there.\n            request=request,\n            session=session,\n            g=g,\n        )\n        rv.filters[\"tojson\"] = json.tojson_filter\n        return rv"
                },
                {
                    "docstring": "\"\"\"Creates the loader for the Jinja2 environment.  Can be used to\n        override just the loader and keeping the rest unchanged.  It's\n        discouraged to override this function.  Instead one should override\n        the :meth:`jinja_loader` function instead.\n\n        The global loader dispatches between the loaders of the application\n        and the individual blueprints.\n\n        .. versionadded:: 0.7\n        \"\"\"",
                    "first_doc": "\"\"\"\nCreates and returns the global Jinja2 loader for the environment.\n\nThis method initializes the loader responsible for dispatching template requests between the application's loader and the loaders defined for individual blueprints. It is intended to be used internally, and overriding this method is discouraged; prefer overriding the `jinja_loader` method instead.\n\nArgs:\n    self: The instance of the class for which the loader is being created.\n\nReturns:\n    DispatchingJinjaLoader: An instance of DispatchingJinjaLoader configured with this object.\n\"\"\"",
                    "method_name": "create_global_jinja_loader",
                    "second_doc": "\"\"\"\nInitializes and returns the global Jinja2 template loader for the application.\n\nThis method sets up a loader that can dynamically select and dispatch templates from multiple sources within the application, such as the app itself and its modular components (blueprints). This approach ensures seamless template resolution and supports modular development by allowing templates to be organized across different parts of the application. This mechanism helps maintain flexibility and scalability in template management as the application's structure evolves.\n\nArgs:\n    self: The Flask application instance for which the template loader is created.\n\nReturns:\n    DispatchingJinjaLoader: A loader configured to handle template lookups from both the main app and its associated components.\n\"\"\"",
                    "source_code": "return DispatchingJinjaLoader(self)"
                },
                {
                    "docstring": "\"\"\"Returns ``True`` if autoescaping should be active for the given\n        template name. If no template name is given, returns `True`.\n\n        .. versionadded:: 0.5\n        \"\"\"",
                    "first_doc": "\"\"\"\nDetermines if autoescaping should be enabled for a given template filename.\n\nReturns True if autoescaping should be active for the specified template name. If no filename is provided, autoescaping is enabled by default.\n\nArgs:\n    self: The instance of the class.\n    filename: The name of the template file to check for autoescaping.\n\nReturns:\n    bool: True if autoescaping should be enabled (for .html, .htm, .xml, .xhtml files, or if no filename is given), otherwise False.\n\"\"\"",
                    "method_name": "select_jinja_autoescape",
                    "second_doc": "\"\"\"\nChecks whether autoescaping is necessary for template files based on their extensions. Autoescaping protects rendered template output from certain types of code injection vulnerabilities by default for commonly used markup files.\n\nArgs:\n    self: The Flask application instance.\n    filename (str or None): The name of the template file whose autoescaping behavior should be determined. If None, autoescaping is assumed to be required.\n\nReturns:\n    bool: True if autoescaping should be applied (for files ending with .html, .htm, .xml, .xhtml, or if no filename is provided); otherwise, False.\n\"\"\"",
                    "source_code": "if filename is None:\n            return True\n        return filename.endswith((\".html\", \".htm\", \".xml\", \".xhtml\"))"
                },
                {
                    "docstring": "\"\"\"Update the template context with some commonly used variables.\n        This injects request, session, config and g into the template\n        context as well as everything template context processors want\n        to inject.  Note that the as of Flask 0.6, the original values\n        in the context will not be overridden if a context processor\n        decides to return a value with the same key.\n\n        :param context: the context as a dictionary that is updated in place\n                        to add extra variables.\n        \"\"\"",
                    "first_doc": "\"\"\"\nUpdates the template context with commonly used variables and any values provided by template context processors.\n\nThis method injects standard variables such as request, session, config, and g into the provided template context dictionary. It also incorporates any additional variables provided by registered template context processors. Original values in the context dictionary are preserved if context processors return a value with the same key.\n\nArgs:\n    context: The context dictionary that is updated in place with extra variables.\n\nReturns:\n    None: This method updates the provided context dictionary in place and does not return a value.\n\"\"\"",
                    "method_name": "update_template_context",
                    "second_doc": "\"\"\"\nEnriches the current template context with variables supplied by context processors and standard globals, ensuring that templates have access to necessary data for dynamic rendering.\n\nThis method collects variables from registered context processors, including those associated with the current blueprint if applicable, and merges them into the provided context dictionary. It safeguards any preexisting keys in the context to maintain explicit overrides or specific values already set, thus supporting flexible and predictable template rendering.\n\nArgs:\n    context (dict): The template context dictionary to be enhanced with additional variables sourced from context processors and standard globals.\n\nReturns:\n    None: This method operates in place, updating the input context dictionary without returning a value.\n\"\"\"",
                    "source_code": "funcs = self.template_context_processors[None]\n        reqctx = _request_ctx_stack.top\n        if reqctx is not None:\n            bp = reqctx.request.blueprint\n            if bp is not None and bp in self.template_context_processors:\n                funcs = chain(funcs, self.template_context_processors[bp])\n        orig_ctx = context.copy()\n        for func in funcs:\n            context.update(func())\n        # make sure the original values win.  This makes it possible to\n        # easier add new variables in context processors without breaking\n        # existing views.\n        context.update(orig_ctx)"
                },
                {
                    "docstring": "\"\"\"Returns the shell context for an interactive shell for this\n        application.  This runs all the registered shell context\n        processors.\n\n        .. versionadded:: 0.11\n        \"\"\"",
                    "first_doc": "\"\"\"\nGenerates the shell context for an interactive shell session with the application.\n\nRuns all registered shell context processors and combines their outputs to provide additional context keys. This is typically used to provide pre-imported objects in an interactive shell environment.\n\nArgs:\n    self: The instance of the application.\n\nReturns:\n    dict: A dictionary mapping context variable names to objects for use in the interactive shell session. By default, includes the current application instance and the `g` object. Additional context variables may be added via shell context processors.\n\"\"\"",
                    "method_name": "make_shell_context",
                    "second_doc": "\"\"\"\nPrepares a dictionary of variables and objects accessible during an interactive shell session, enhancing developer productivity by providing immediate access to useful application-related objects.\n\nThis method collects and aggregates context variables from registered context processors as well as default objects, allowing users to interact with the application environment more efficiently during shell sessions.\n\nArgs:\n    self: The Flask application instance.\n\nReturns:\n    dict: A dictionary mapping variable names to objects for use in the interactive shell session. By default, includes the current application instance under 'app' and the 'g' object. Additional context variables can be supplied by custom shell context processors.\n\"\"\"",
                    "source_code": "rv = {\"app\": self, \"g\": g}\n        for processor in self.shell_context_processors:\n            rv.update(processor())\n        return rv"
                },
                {
                    "docstring": "\"\"\"Whether debug mode is enabled. When using ``flask run`` to start\n        the development server, an interactive debugger will be shown for\n        unhandled exceptions, and the server will be reloaded when code\n        changes. This maps to the :data:`DEBUG` config key. This is\n        enabled when :attr:`env` is ``'development'`` and is overridden\n        by the ``FLASK_DEBUG`` environment variable. It may not behave as\n        expected if set in code.\n\n        **Do not enable debug mode when deploying in production.**\n\n        Default: ``True`` if :attr:`env` is ``'development'``, or\n        ``False`` otherwise.\n        \"\"\"",
                    "first_doc": "\"\"\"\nIndicates whether debug mode is enabled for the current Flask application.\n\nWhen enabled, the development server displays an interactive debugger for unhandled exceptions and automatically reloads when code changes. This property is tied to the application's configuration and environment, corresponding to the 'DEBUG' config key. Debug mode is enabled by default if the environment is set to 'development', but can be overridden by the FLASK_DEBUG environment variable. Caution should be exercised, as enabling debug mode in production poses security risks.\n\nDo not enable debug mode when deploying in production.\n\nArgs:\n    self: The Flask application instance.\n\nReturns:\n    bool: True if debug mode is enabled, False otherwise.\n\"\"\"",
                    "method_name": "debug",
                    "second_doc": "\"\"\"\nChecks if the application is currently running in debug mode by examining its configuration settings.\n\nThis check is useful for enabling features such as auto-reload and detailed error reports during development, helping developers quickly identify and resolve issues while making code changes. The debug state adapts based on configuration, ensuring the application operates safely and appropriately in different environments.\n\nArgs:\n    self: The current Flask application instance.\n\nReturns:\n    bool: True if the debug mode is active according to the application's configuration, False otherwise.\n\"\"\"",
                    "source_code": "return self.config[\"DEBUG\"]"
                },
                {
                    "docstring": null,
                    "method_name": "debug",
                    "second_doc": "\"\"\"\nEnables or disables debugging mode and configures the template engine to reload templates automatically if needed.\n\nThis ensures that code and template changes are quickly reflected during development, aiding in faster iteration and diagnosis of issues.\n\nArgs:\n    value (bool): If True, activates debugging features and auto-reloads templates; if False, disables them.\n\nReturns:\n    None\n\"\"\"",
                    "source_code": "self.config[\"DEBUG\"] = value\n        self.jinja_env.auto_reload = self.templates_auto_reload"
                },
                {
                    "docstring": "\"\"\"Runs the application on a local development server.\n\n        Do not use ``run()`` in a production setting. It is not intended to\n        meet security and performance requirements for a production server.\n        Instead, see :doc:`/deploying/index` for WSGI server recommendations.\n\n        If the :attr:`debug` flag is set the server will automatically reload\n        for code changes and show a debugger in case an exception happened.\n\n        If you want to run the application in debug mode, but disable the\n        code execution on the interactive debugger, you can pass\n        ``use_evalex=False`` as parameter.  This will keep the debugger's\n        traceback screen active, but disable code execution.\n\n        It is not recommended to use this function for development with\n        automatic reloading as this is badly supported.  Instead you should\n        be using the :command:`flask` command line script's ``run`` support.\n\n        .. admonition:: Keep in Mind\n\n           Flask will suppress any server error with a generic error page\n           unless it is in debug mode.  As such to enable just the\n           interactive debugger without the code reloading, you have to\n           invoke :meth:`run` with ``debug=True`` and ``use_reloader=False``.\n           Setting ``use_debugger`` to ``True`` without being in debug mode\n           won't catch any exceptions because there won't be any to\n           catch.\n\n        :param host: the hostname to listen on. Set this to ``'0.0.0.0'`` to\n            have the server available externally as well. Defaults to\n            ``'127.0.0.1'`` or the host in the ``SERVER_NAME`` config variable\n            if present.\n        :param port: the port of the webserver. Defaults to ``5000`` or the\n            port defined in the ``SERVER_NAME`` config variable if present.\n        :param debug: if given, enable or disable debug mode. See\n            :attr:`debug`.\n        :param load_dotenv: Load the nearest :file:`.env` and :file:`.flaskenv`\n            files to set environment variables. Will also change the working\n            directory to the directory containing the first file found.\n        :param options: the options to be forwarded to the underlying Werkzeug\n            server. See :func:`werkzeug.serving.run_simple` for more\n            information.\n\n        .. versionchanged:: 1.0\n            If installed, python-dotenv will be used to load environment\n            variables from :file:`.env` and :file:`.flaskenv` files.\n\n            If set, the :envvar:`FLASK_ENV` and :envvar:`FLASK_DEBUG`\n            environment variables will override :attr:`env` and\n            :attr:`debug`.\n\n            Threaded mode is enabled by default.\n\n        .. versionchanged:: 0.10\n            The default port is now picked from the ``SERVER_NAME``\n            variable.\n        \"\"\"",
                    "first_doc": "\"\"\"\nRuns the application on a local development server for development and debugging.\n\nThis method starts a local server to run the application for development purposes. Do not use this server in production, as it does not meet the security and performance requirements for production environments. When debug mode is enabled, the server will automatically reload on code changes and provide an interactive debugger if exceptions occur.\n\nParameters:\n  self: The instance of the class. The following fields are accessed or initialized:\n    - self.env: The environment name the application is running under, such as 'development' or 'production'.\n    - self.debug: A boolean flag indicating if the application is running in debug mode.\n    - self.config: A configuration dictionary that may provide settings like 'SERVER_NAME'.\n    - self.name: The name of the application.\n    - self._got_first_request: Tracks if the first request has been handled, for server reset logic.\n\nReturns:\n  None: This method does not return a value. It runs the development server, and blocks further code execution until the server is stopped.\n\"\"\"",
                    "method_name": "run",
                    "second_doc": "\"\"\"\nInitializes and launches a lightweight web server instance for local development and application debugging.\n\nBy configuring server options such as host, port, and debug mode, this method enables a responsive and interactive environment for building and testing application functionality. Automatic code reloading and detailed error feedback are supported to streamline the iterative development process. It avoids starting the local server if the application has already been invoked via command-line tooling, ensuring that only a single development server is initiated and preventing unnecessary duplication.\n\nArgs:\n  self: The application instance from which server and environment settings (such as environment name, debug status, configuration, and first request tracking) are accessed.\n  host (str, optional): The hostname to listen on. If not provided, defaults to '127.0.0.1' or the value specified by configuration.\n  port (int, optional): The port to bind to. Defaults to '5000' or the value specified by configuration.\n  debug (bool, optional): If provided, overrides the application's debug mode for this session.\n  load_dotenv (bool, optional): If True, loads environment variables from a '.env' file prior to launching.\n  **options: Additional keyword arguments for further server configuration (such as enabling threaded mode or adjusting reloader behavior).\n\nReturns:\n  None: Runs the development server and blocks further code execution until the server is stopped or interrupted.\n\"\"\"",
                    "source_code": "# Change this into a no-op if the server is invoked from the\n        # command line. Have a look at cli.py for more information.\n        if os.environ.get(\"FLASK_RUN_FROM_CLI\") == \"true\":\n            from .debughelpers import explain_ignored_app_run\n\n            explain_ignored_app_run()\n            return\n\n        if get_load_dotenv(load_dotenv):\n            cli.load_dotenv()\n\n            # if set, let env vars override previous values\n            if \"FLASK_ENV\" in os.environ:\n                self.env = get_env()\n                self.debug = get_debug_flag()\n            elif \"FLASK_DEBUG\" in os.environ:\n                self.debug = get_debug_flag()\n\n        # debug passed to method overrides all other sources\n        if debug is not None:\n            self.debug = bool(debug)\n\n        server_name = self.config.get(\"SERVER_NAME\")\n        sn_host = sn_port = None\n\n        if server_name:\n            sn_host, _, sn_port = server_name.partition(\":\")\n\n        if not host:\n            if sn_host:\n                host = sn_host\n            else:\n                host = \"127.0.0.1\"\n\n        if port or port == 0:\n            port = int(port)\n        elif sn_port:\n            port = int(sn_port)\n        else:\n            port = 5000\n\n        options.setdefault(\"use_reloader\", self.debug)\n        options.setdefault(\"use_debugger\", self.debug)\n        options.setdefault(\"threaded\", True)\n\n        cli.show_server_banner(self.env, self.debug, self.name, False)\n\n        from werkzeug.serving import run_simple\n\n        try:\n            run_simple(host, port, self, **options)\n        finally:\n            # reset the first request information if the development server\n            # reset normally.  This makes it possible to restart the server\n            # without reloader and that stuff from an interactive shell.\n            self._got_first_request = False"
                },
                {
                    "docstring": "\"\"\"Creates a test client for this application.  For information\n        about unit testing head over to :doc:`/testing`.\n\n        Note that if you are testing for assertions or exceptions in your\n        application code, you must set ``app.testing = True`` in order for the\n        exceptions to propagate to the test client.  Otherwise, the exception\n        will be handled by the application (not visible to the test client) and\n        the only indication of an AssertionError or other exception will be a\n        500 status code response to the test client.  See the :attr:`testing`\n        attribute.  For example::\n\n            app.testing = True\n            client = app.test_client()\n\n        The test client can be used in a ``with`` block to defer the closing down\n        of the context until the end of the ``with`` block.  This is useful if\n        you want to access the context locals for testing::\n\n            with app.test_client() as c:\n                rv = c.get('/?vodka=42')\n                assert request.args['vodka'] == '42'\n\n        Additionally, you may pass optional keyword arguments that will then\n        be passed to the application's :attr:`test_client_class` constructor.\n        For example::\n\n            from flask.testing import FlaskClient\n\n            class CustomClient(FlaskClient):\n                def __init__(self, *args, **kwargs):\n                    self._authentication = kwargs.pop(\"authentication\")\n                    super(CustomClient,self).__init__( *args, **kwargs)\n\n            app.test_client_class = CustomClient\n            client = app.test_client(authentication='Basic ....')\n\n        See :class:`~flask.testing.FlaskClient` for more information.\n\n        .. versionchanged:: 0.4\n           added support for ``with`` block usage for the client.\n\n        .. versionadded:: 0.7\n           The `use_cookies` parameter was added as well as the ability\n           to override the client to be used by setting the\n           :attr:`test_client_class` attribute.\n\n        .. versionchanged:: 0.11\n           Added `**kwargs` to support passing additional keyword arguments to\n           the constructor of :attr:`test_client_class`.\n        \"\"\"",
                    "first_doc": "\"\"\"\nCreates a test client for the application to facilitate testing.\n\nThis method instantiates and returns a test client instance for the application, which can be used to simulate client requests to the application's routes and test its behavior. The test client can be used within a context manager (with block) for accessing context locals during testing. Optional keyword arguments may be provided and will be passed to the application's test client class constructor.\n\nArgs:\n    self: The application instance for which the test client is created.\n\nReturns:\n    An instance of the application's test client class, allowing simulation of HTTP requests for testing purposes.\n\"\"\"",
                    "method_name": "test_client",
                    "second_doc": "\"\"\"\nCreates and returns a test client instance configured for the application to support simulated request testing.\n\nThis method constructs a test client, allowing simulation of HTTP requests to the application's endpoints. It is used to verify that application routes and logic behave as expected by providing an isolated environment for sending requests and inspecting responses. This is important for ensuring that application features can be programmatically validated and tested without running a real server.\n\nArgs:\n    self: The application instance for which the test client is created.\n    use_cookies (bool, optional): Whether to track and manage cookies between requests. Defaults to True.\n    **kwargs: Additional keyword arguments passed to the test client class constructor.\n\nReturns:\n    An instance of the test client, which can simulate HTTP request/response cycles for the application during testing.\n\"\"\"",
                    "source_code": "cls = self.test_client_class\n        if cls is None:\n            from .testing import FlaskClient as cls\n        return cls(self, self.response_class, use_cookies=use_cookies, **kwargs)"
                },
                {
                    "docstring": "\"\"\"Create a CLI runner for testing CLI commands.\n        See :ref:`testing-cli`.\n\n        Returns an instance of :attr:`test_cli_runner_class`, by default\n        :class:`~flask.testing.FlaskCliRunner`. The Flask app object is\n        passed as the first argument.\n\n        .. versionadded:: 1.0\n        \"\"\"",
                    "first_doc": "\"\"\"\nCreates a CLI runner instance for testing CLI commands with the current Flask application.\n\nThis method returns an instance of the class specified by the `test_cli_runner_class` attribute. By default, this is `flask.testing.FlaskCliRunner`. The returned runner instance is initialized with the current Flask app object.\n\nArgs:\n    self: The instance of the Flask application.\n\nReturns:\n    An instance of the CLI runner class for testing CLI commands, typically a FlaskCliRunner configured with the current app.\n\"\"\"",
                    "method_name": "test_cli_runner",
                    "second_doc": "\"\"\"\nInitializes and returns a command-line interface (CLI) runner configured for the current Flask application, allowing for isolated testing and execution of CLI commands associated with the app.\n\nThis enables developers to programmatically invoke and validate command-line behavior in a controlled environment, ensuring reliability and correctness of custom commands or extensions intended for application management and automation.\n\nArgs:\n    self: The Flask application instance.\n    **kwargs: Additional keyword arguments passed to the CLI runner class constructor.\n\nReturns:\n    An instance of the CLI runner class (usually FlaskCliRunner) set up to interact with the current Flask application for testing and executing CLI commands.\n\"\"\"",
                    "source_code": "cls = self.test_cli_runner_class\n\n        if cls is None:\n            from .testing import FlaskCliRunner as cls\n\n        return cls(self, **kwargs)"
                },
                {
                    "docstring": "\"\"\"Register a :class:`~flask.Blueprint` on the application. Keyword\n        arguments passed to this method will override the defaults set on the\n        blueprint.\n\n        Calls the blueprint's :meth:`~flask.Blueprint.register` method after\n        recording the blueprint in the application's :attr:`blueprints`.\n\n        :param blueprint: The blueprint to register.\n        :param url_prefix: Blueprint routes will be prefixed with this.\n        :param subdomain: Blueprint routes will match on this subdomain.\n        :param url_defaults: Blueprint routes will use these default values for\n            view arguments.\n        :param options: Additional keyword arguments are passed to\n            :class:`~flask.blueprints.BlueprintSetupState`. They can be\n            accessed in :meth:`~flask.Blueprint.record` callbacks.\n\n        .. versionadded:: 0.7\n        \"\"\"",
                    "first_doc": "\"\"\"\nRegisters a Flask Blueprint on the application, allowing its routes, error handlers, and other properties to be associated with the main app. Any keyword arguments provided will override the defaults set on the blueprint.\n\nArgs:\n    blueprint: The Blueprint instance to register with the application.\n\nFields Initialized:\n    blueprints: A mapping of blueprint names to their Blueprint instances, updated to include the newly registered blueprint.\n    _blueprint_order: A list tracking the order in which blueprints are registered, updated with the new blueprint if this is its first registration.\n\nReturns:\n    None: This method does not return a value; it modifies the application's state by registering the blueprint.\n\"\"\"",
                    "method_name": "register_blueprint",
                    "second_doc": "\"\"\"\nIntegrates a Flask Blueprint with the application, ensuring its routes, error handlers, and extensions are made available as part of the overall app. By registering a blueprint, modular components can be logically organized and reused within the project. Keyword arguments can be used to override specific defaults set on the blueprint.\n\nArgs:\n    blueprint: The Blueprint instance to attach to the application.\n    **options: Arbitrary keyword arguments to override default blueprint configuration.\n\nReturns:\n    None: The method updates the application's state to include the blueprint, allowing its functionality to participate in request handling and application behavior.\n    \nWhy:\n    This method enables a modular, organized approach to app development by allowing distinct components (blueprints) to be cleanly registered and integrated into the main application. This facilitates code reuse, extension, and maintainability.\n\"\"\"",
                    "source_code": "first_registration = False\n\n        if blueprint.name in self.blueprints:\n            assert self.blueprints[blueprint.name] is blueprint, (\n                \"A name collision occurred between blueprints\"\n                f\" {blueprint!r} and {self.blueprints[blueprint.name]!r}.\"\n                f\" Both share the same name {blueprint.name!r}.\"\n                f\" Blueprints that are created on the fly need unique\"\n                f\" names.\"\n            )\n        else:\n            self.blueprints[blueprint.name] = blueprint\n            self._blueprint_order.append(blueprint)\n            first_registration = True\n\n        blueprint.register(self, options, first_registration)"
                },
                {
                    "docstring": "\"\"\"Iterates over all blueprints by the order they were registered.\n\n        .. versionadded:: 0.11\n        \"\"\"",
                    "first_doc": "\"\"\"\nIterates over all blueprints in the order they were registered.\n\nArgs:\n    self: The instance of the class on which the method is called.\n\nReturns:\n    iterator: An iterator over the collection representing the order in which blueprints were registered.\n\"\"\"",
                    "method_name": "iter_blueprints",
                    "second_doc": "\"\"\"\nProvides an iterator over registered blueprints in the sequence they were added, ensuring consistent processing order for modular application components.\n\nArgs:\n    self: The Flask application instance.\n\nReturns:\n    Iterator[str]: An iterator yielding blueprint names in their registration order.\n    \nThis method ensures predictable execution of application setup, teardown, and routing by maintaining blueprint order.\n\"\"\"",
                    "source_code": "return iter(self._blueprint_order)"
                },
                {
                    "docstring": "\"\"\"Connects a URL rule.  Works exactly like the :meth:`route`\n        decorator.  If a view_func is provided it will be registered with the\n        endpoint.\n\n        Basically this example::\n\n            @app.route('/')\n            def index():\n                pass\n\n        Is equivalent to the following::\n\n            def index():\n                pass\n            app.add_url_rule('/', 'index', index)\n\n        If the view_func is not provided you will need to connect the endpoint\n        to a view function like so::\n\n            app.view_functions['index'] = index\n\n        Internally :meth:`route` invokes :meth:`add_url_rule` so if you want\n        to customize the behavior via subclassing you only need to change\n        this method.\n\n        For more information refer to :ref:`url-route-registrations`.\n\n        .. versionchanged:: 0.2\n           `view_func` parameter added.\n\n        .. versionchanged:: 0.6\n           ``OPTIONS`` is added automatically as method.\n\n        :param rule: the URL rule as string\n        :param endpoint: the endpoint for the registered URL rule.  Flask\n                         itself assumes the name of the view function as\n                         endpoint\n        :param view_func: the function to call when serving a request to the\n                          provided endpoint\n        :param provide_automatic_options: controls whether the ``OPTIONS``\n            method should be added automatically. This can also be controlled\n            by setting the ``view_func.provide_automatic_options = False``\n            before adding the rule.\n        :param options: the options to be forwarded to the underlying\n                        :class:`~werkzeug.routing.Rule` object.  A change\n                        to Werkzeug is handling of method options.  methods\n                        is a list of methods this rule should be limited\n                        to (``GET``, ``POST`` etc.).  By default a rule\n                        just listens for ``GET`` (and implicitly ``HEAD``).\n                        Starting with Flask 0.6, ``OPTIONS`` is implicitly\n                        added and handled by the standard request handling.\n        \"\"\"",
                    "first_doc": "\"\"\"\nRegisters a new URL rule with the application. This method associates a URL rule with a view function and an endpoint, configuring how requests to the given URL should be handled.\n\nArgs:\n    rule: The URL rule as a string.\n    endpoint: The endpoint for the registered URL rule. If not specified, Flask will use the name of the view function.\n    view_func: The function to call when serving a request to the provided endpoint.\n    provide_automatic_options: Controls whether the \"OPTIONS\" HTTP method should be added automatically. This can also be set via the \"provide_automatic_options\" attribute of the view function prior to rule registration.\n    options: Additional options forwarded to the underlying Rule object, including an optional list of HTTP methods (\"methods\") this rule should respond to (e.g., GET, POST).\n\nReturns:\n    None. This method modifies the internal URL map and view function registry of the application.\n\"\"\"",
                    "method_name": "add_url_rule",
                    "second_doc": "\"\"\"\nDefines how incoming requests to a specific URL are directed within the web application by linking URL patterns to their corresponding view logic. This enables the framework to determine what response to generate for each request path, supporting dynamic and configurable routing capabilities.\n\nArgs:\n    rule (str): The URL pattern to associate with a view function.\n    endpoint (str, optional): A unique name for the route, used for URL generation and reverse routing. If not provided, the name of the view function is used.\n    view_func (callable): The function that should be called when a request matches the given route.\n    provide_automatic_options (bool, optional): If True, the route will automatically support the HTTP \"OPTIONS\" method; can also be controlled via an attribute on the view function.\n    **options: Additional keyword arguments to configure the route, such as allowable HTTP methods (methods=[\"GET\", \"POST\"]).\n\nReturns:\n    None: Updates the application's routing map and view function registry to include the new rule, enabling proper request dispatching.\n\"\"\"",
                    "source_code": "if endpoint is None:\n            endpoint = _endpoint_from_view_func(view_func)\n        options[\"endpoint\"] = endpoint\n        methods = options.pop(\"methods\", None)\n\n        # if the methods are not given and the view_func object knows its\n        # methods we can use that instead.  If neither exists, we go with\n        # a tuple of only ``GET`` as default.\n        if methods is None:\n            methods = getattr(view_func, \"methods\", None) or (\"GET\",)\n        if isinstance(methods, str):\n            raise TypeError(\n                \"Allowed methods must be a list of strings, for\"\n                ' example: @app.route(..., methods=[\"POST\"])'\n            )\n        methods = {item.upper() for item in methods}\n\n        # Methods that should always be added\n        required_methods = set(getattr(view_func, \"required_methods\", ()))\n\n        # starting with Flask 0.8 the view_func object can disable and\n        # force-enable the automatic options handling.\n        if provide_automatic_options is None:\n            provide_automatic_options = getattr(\n                view_func, \"provide_automatic_options\", None\n            )\n\n        if provide_automatic_options is None:\n            if \"OPTIONS\" not in methods:\n                provide_automatic_options = True\n                required_methods.add(\"OPTIONS\")\n            else:\n                provide_automatic_options = False\n\n        # Add the required methods now.\n        methods |= required_methods\n\n        rule = self.url_rule_class(rule, methods=methods, **options)\n        rule.provide_automatic_options = provide_automatic_options\n\n        self.url_map.add(rule)\n        if view_func is not None:\n            old_func = self.view_functions.get(endpoint)\n            if old_func is not None and old_func != view_func:\n                raise AssertionError(\n                    \"View function mapping is overwriting an existing\"\n                    f\" endpoint function: {endpoint}\"\n                )\n            self.view_functions[endpoint] = view_func"
                },
                {
                    "docstring": "\"\"\"A decorator that is used to register a view function for a\n        given URL rule.  This does the same thing as :meth:`add_url_rule`\n        but is intended for decorator usage::\n\n            @app.route('/')\n            def index():\n                return 'Hello World'\n\n        For more information refer to :ref:`url-route-registrations`.\n\n        :param rule: the URL rule as string\n        :param endpoint: the endpoint for the registered URL rule.  Flask\n                         itself assumes the name of the view function as\n                         endpoint\n        :param options: the options to be forwarded to the underlying\n                        :class:`~werkzeug.routing.Rule` object.  A change\n                        to Werkzeug is handling of method options.  methods\n                        is a list of methods this rule should be limited\n                        to (``GET``, ``POST`` etc.).  By default a rule\n                        just listens for ``GET`` (and implicitly ``HEAD``).\n                        Starting with Flask 0.6, ``OPTIONS`` is implicitly\n                        added and handled by the standard request handling.\n        \"\"\"",
                    "first_doc": "\"\"\"\nRegisters a view function for a given URL rule as a decorator.\n\nThis method allows a view function to be associated with a specific URL pattern by using it as a decorator. It provides a convenient way to define routes, mapping URL endpoints to view logic. For each registered route, the corresponding function will be called when a request matches the rule.\n\nArgs:\n    self: The instance of the class.\n    rule: The URL rule as a string to which the view function will be bound.\n\nReturns:\n    function: A decorator that registers the view function for the specified URL rule.\n\"\"\"",
                    "method_name": "route",
                    "second_doc": "\"\"\"\nAssociates a view function with a given URL rule using a decorator.\n\nThis method lets you connect a function to a URL pattern so that when a matching request is received, the function is executed. By using it as a decorator, developers can designate which function should handle specific routes in a clear and readable manner. This supports consistent mapping of URLs to their handling logic, maintaining organized and predictable request handling within the application.\n\nArgs:\n    self: The instance of the Flask class.\n    rule (str): The URL rule that the view function will respond to.\n\nReturns:\n    function: A decorator that, when applied to a function, registers it as the handler for the given URL rule.\n\"\"\"",
                    "source_code": "def decorator(f):\n            endpoint = options.pop(\"endpoint\", None)\n            self.add_url_rule(rule, endpoint, f, **options)\n            return f\n\n        return decorator"
                },
                {
                    "docstring": "\"\"\"A decorator to register a function as an endpoint.\n        Example::\n\n            @app.endpoint('example.endpoint')\n            def example():\n                return \"example\"\n\n        :param endpoint: the name of the endpoint\n        \"\"\"",
                    "first_doc": "\"\"\"\nRegisters a function as an endpoint under the specified name.\n\nThis method acts as a decorator, allowing you to associate a view function with a unique endpoint identifier. When applied, the function is added to the internal mapping of endpoint names to view functions.\n\nArgs:\n    endpoint: The name to associate with the decorated function as its endpoint.\n\nReturns:\n    function: A decorator that registers the given function as an endpoint and returns the original function.\n\"\"\"",
                    "method_name": "endpoint",
                    "second_doc": "\"\"\"\nAssociates a view function with a specific endpoint name, enabling the function to be invoked when routing matches.\n\nBy mapping function names to endpoints, this decorator allows for the dynamic association and retrieval of handler functions, supporting flexible and maintainable URL routing within the application.\n\nArgs:\n    endpoint (str): The unique identifier to associate with the decorated view function.\n\nReturns:\n    function: A decorator that registers the view function under the provided endpoint name and returns the original function.\n\"\"\"",
                    "source_code": "def decorator(f):\n            self.view_functions[endpoint] = f\n            return f\n\n        return decorator"
                },
                {
                    "docstring": "\"\"\"Get the exception class being handled. For HTTP status codes\n        or ``HTTPException`` subclasses, return both the exception and\n        status code.\n\n        :param exc_class_or_code: Any exception class, or an HTTP status\n            code as an integer.\n        \"\"\"",
                    "first_doc": "\"\"\"\nReturns the exception class and its associated HTTP status code, if applicable.\n\nGiven either an exception class or an HTTP status code (as an integer), this method retrieves the corresponding exception class. If the exception is a subclass of HTTPException, the method also returns its HTTP status code; otherwise, it returns None for the status code.\n\nArgs:\n    exc_class_or_code: The exception class or an HTTP status code as an integer.\n\nReturns:\n    tuple: A tuple containing the exception class and its HTTP status code (or None if not applicable).\n\"\"\"",
                    "method_name": "_get_exc_class_and_code",
                    "second_doc": "\"\"\"\nDetermines the appropriate exception class and its HTTP status code for error handling within the framework.\n\nBy resolving either an exception class or a numeric HTTP status code to their canonical forms, this method ensures consistent processing of error conditions and facilitates proper HTTP response generation for the application.\n\nArgs:\n    exc_class_or_code: Either an exception class or an integer HTTP status code to be mapped.\n\nReturns:\n    tuple: A tuple containing the resolved exception class and its corresponding HTTP status code (or None if not an HTTPException).\n\"\"\"",
                    "source_code": "if isinstance(exc_class_or_code, int):\n            exc_class = default_exceptions[exc_class_or_code]\n        else:\n            exc_class = exc_class_or_code\n\n        assert issubclass(\n            exc_class, Exception\n        ), \"Custom exceptions must be subclasses of Exception.\"\n\n        if issubclass(exc_class, HTTPException):\n            return exc_class, exc_class.code\n        else:\n            return exc_class, None"
                },
                {
                    "docstring": "\"\"\"Register a function to handle errors by code or exception class.\n\n        A decorator that is used to register a function given an\n        error code.  Example::\n\n            @app.errorhandler(404)\n            def page_not_found(error):\n                return 'This page does not exist', 404\n\n        You can also register handlers for arbitrary exceptions::\n\n            @app.errorhandler(DatabaseError)\n            def special_exception_handler(error):\n                return 'Database connection failed', 500\n\n        .. versionadded:: 0.7\n            Use :meth:`register_error_handler` instead of modifying\n            :attr:`error_handler_spec` directly, for application wide error\n            handlers.\n\n        .. versionadded:: 0.7\n           One can now additionally also register custom exception types\n           that do not necessarily have to be a subclass of the\n           :class:`~werkzeug.exceptions.HTTPException` class.\n\n        :param code_or_exception: the code as integer for the handler, or\n                                  an arbitrary exception\n        \"\"\"",
                    "first_doc": "\"\"\"\nRegisters a function to handle errors by error code or exception class.\n\nThis method serves as a decorator to associate a custom error handler function with a specific HTTP error code or exception class. The decorated function will be invoked whenever the specified error or exception is encountered during request processing. This enables custom responses for various errors or exceptions within the application.\n\nArgs:\n    code_or_exception: The error code as an integer, or an exception class for which the handler should be registered.\n\nReturns:\n    A decorator that, when applied to a function, registers it as an error handler for the provided error code or exception.\n\"\"\"",
                    "method_name": "errorhandler",
                    "second_doc": "\"\"\"\nAssociates a custom error handler function with a given HTTP status code or exception class to control how errors are managed during request handling.\n\nBy registering specific error handlers, this method enables fine-grained control over the application's behavior in the event of errors or exceptions. This approach enhances the reliability and user experience of the web application by allowing clear, consistent, and customized responses to a broad range of error conditions.\n\nArgs:\n    code_or_exception: An HTTP status code as an integer, or an exception class, indicating the error type the handler should manage.\n\nReturns:\n    A decorator function that registers the decorated function as the error handler for the specified error code or exception class.\n\"\"\"",
                    "source_code": "def decorator(f):\n            self._register_error_handler(None, code_or_exception, f)\n            return f\n\n        return decorator"
                },
                {
                    "docstring": "\"\"\"Alternative error attach function to the :meth:`errorhandler`\n        decorator that is more straightforward to use for non decorator\n        usage.\n\n        .. versionadded:: 0.7\n        \"\"\"",
                    "first_doc": "\"\"\"\nRegisters an error handler function for a specific exception or HTTP status code.\n\nThis method attaches an error handler function in a straightforward way for non-decorator usage, providing an alternative to the errorhandler decorator.\n\nArgs:\n    code_or_exception: The exception class or HTTP status code to handle. If None, the handler applies to all exceptions.\n    f: The function to handle the error, which takes the error as its argument.\n\nReturns:\n    None: This method does not return a value; it registers the handler for future error handling.\n\"\"\"",
                    "method_name": "register_error_handler",
                    "second_doc": "\"\"\"\nAssociates a specific exception or HTTP status code with a custom error handler function. This allows tailored error responses or recovery logic when certain errors occur during request processing.\n\nBy enabling this registration, developers can define centralized error management strategies, improving application robustness and offering better user and debugging experiences.\n\nArgs:\n    code_or_exception: The exception class or HTTP status code to handle. If None, the handler applies to all exceptions.\n    f: The error handler function, which takes the error as its argument.\n\nReturns:\n    None: Registers the handler for future use; does not return a value.\n\"\"\"",
                    "source_code": "self._register_error_handler(None, code_or_exception, f)"
                },
                {
                    "docstring": "\"\"\"\n        :type key: None|str\n        :type code_or_exception: int|T<=Exception\n        :type f: callable\n        \"\"\"",
                    "first_doc": "\"\"\"\nRegisters a custom error handler for a specific exception or HTTP status code.\n\nThis method allows you to associate a handler function with a particular error condition by specifying either an HTTP status code or an exception class.\n\nArgs:\n    key: The scope or blueprint name used to register the handler; can be None for the application-level.\n    code_or_exception: An HTTP status code (integer) or an exception class for which the handler should be registered.\n    f: The handler function to be invoked when the specified error or exception occurs.\n\nReturns:\n    None. Registers the handler internally for later error handling.\n\"\"\"",
                    "method_name": "_register_error_handler",
                    "second_doc": "\"\"\"\nAssociates a specific handler function with an error condition, identified by an HTTP status code or exception class, within a certain application or blueprint context.\n\nBy registering custom error handlers, this method enables the application to respond in a controlled manner to errors and exceptions that occur during request processing, thereby improving reliability and the user experience.\n\nArgs:\n    key (str or None): The application or blueprint scope in which the handler will be registered. Use None to register at the application level.\n    code_or_exception (int or type): The HTTP status code (integer) or exception class for which the handler should be registered.\n    f (callable): The function to handle the error when the specified condition arises.\n\nReturns:\n    None: The handler function is stored internally and will be invoked automatically when the corresponding error occurs.\n\"\"\"",
                    "source_code": "if isinstance(code_or_exception, HTTPException):  # old broken behavior\n            raise ValueError(\n                \"Tried to register a handler for an exception instance\"\n                f\" {code_or_exception!r}. Handlers can only be\"\n                \" registered for exception classes or HTTP error codes.\"\n            )\n\n        try:\n            exc_class, code = self._get_exc_class_and_code(code_or_exception)\n        except KeyError:\n            raise KeyError(\n                f\"'{code_or_exception}' is not a recognized HTTP error\"\n                \" code. Use a subclass of HTTPException with that code\"\n                \" instead.\"\n            )\n\n        handlers = self.error_handler_spec.setdefault(key, {}).setdefault(code, {})\n        handlers[exc_class] = f"
                },
                {
                    "docstring": "\"\"\"A decorator that is used to register custom template filter.\n        You can specify a name for the filter, otherwise the function\n        name will be used. Example::\n\n          @app.template_filter()\n          def reverse(s):\n              return s[::-1]\n\n        :param name: the optional name of the filter, otherwise the\n                     function name will be used.\n        \"\"\"",
                    "first_doc": "\"\"\"\nA decorator for registering a custom template filter.\n\nThis method allows you to register a function as a template filter. You can optionally provide a custom name for the filter; if no name is provided, the function's name will be used as the filter name.\n\nArgs:\n    self: The instance of the class on which this method is called.\n\nReturns:\n    function: A decorator that registers the function as a template filter.\n\"\"\"",
                    "method_name": "template_filter",
                    "second_doc": "\"\"\"\nRegisters a function as a custom template filter, making it available for use within template expressions. By allowing the addition of custom filters, this decorator enables developers to extend template rendering capabilities and tailor outputs to specific application requirements.\n\nArgs:\n    self: The Flask application instance.\n    name (str, optional): Custom name for the filter. If not provided, the function's own name will be used.\n\nReturns:\n    function: A decorator that, when applied to a function, registers it as a template filter.\n\"\"\"",
                    "source_code": "def decorator(f):\n            self.add_template_filter(f, name=name)\n            return f\n\n        return decorator"
                },
                {
                    "docstring": "\"\"\"Register a custom template filter.  Works exactly like the\n        :meth:`template_filter` decorator.\n\n        :param name: the optional name of the filter, otherwise the\n                     function name will be used.\n        \"\"\"",
                    "first_doc": "\"\"\"\nRegisters a custom template filter to the Jinja environment.\n\nThis method allows you to add a custom filter function that can be used within your Jinja templates. If a name is not specified, the filter function's own name will be used as the filter name.\n\nArgs:\n    self: The instance of the class.\n    f: The filter function to be registered.\n\nReturns:\n    None: This method does not return a value.\n\"\"\"",
                    "method_name": "add_template_filter",
                    "second_doc": "\"\"\"\nAdds a new filter function to the Jinja template environment, making it available for use within templates rendered by the application.\n\nBy registering custom filters, this method enables developers to extend template behavior, allowing for presentation logic or formatting to be encapsulated within reusable functions. This contributes to cleaner templates and more maintainable web application code.\n\nArgs:\n    self: The Flask application instance.\n    f: The filter function to register.\n    name (optional): The name under which the filter will be available in templates. If not provided, the function's own name is used.\n\nReturns:\n    None: This method modifies the template environment in place and does not return a value.\n\"\"\"",
                    "source_code": "self.jinja_env.filters[name or f.__name__] = f"
                },
                {
                    "docstring": "\"\"\"A decorator that is used to register custom template test.\n        You can specify a name for the test, otherwise the function\n        name will be used. Example::\n\n          @app.template_test()\n          def is_prime(n):\n              if n == 2:\n                  return True\n              for i in range(2, int(math.ceil(math.sqrt(n))) + 1):\n                  if n % i == 0:\n                      return False\n              return True\n\n        .. versionadded:: 0.10\n\n        :param name: the optional name of the test, otherwise the\n                     function name will be used.\n        \"\"\"",
                    "first_doc": "\"\"\"\nRegisters a custom template test as a decorator.\n\nThis method allows you to register a custom test function for use within templates.\nIf no name is provided, the function's name will be used as the test name.\n\nArgs:\n    name: The optional name to register the test as. If not provided, the test function's name will be used.\n\nReturns:\n    function: The decorator that registers the template test.\n\"\"\"",
                    "method_name": "template_test",
                    "second_doc": "\"\"\"\nRegisters a function as a template test decorator, enabling custom filtering logic within templates.\n\nBy allowing the registration of custom tests, this method supports advanced template rendering scenarios, where template logic needs to be extended or tailored to specific application needs. Registering tests via a decorator streamlines integration and promotes reusable, maintainable template code.\n\nArgs:\n    name (str, optional): The identifier under which the test will be available in templates. If not specified, the function's name is used.\n\nReturns:\n    function: A decorator that registers the provided function as a template test.\n\"\"\"",
                    "source_code": "def decorator(f):\n            self.add_template_test(f, name=name)\n            return f\n\n        return decorator"
                },
                {
                    "docstring": "\"\"\"Register a custom template test.  Works exactly like the\n        :meth:`template_test` decorator.\n\n        .. versionadded:: 0.10\n\n        :param name: the optional name of the test, otherwise the\n                     function name will be used.\n        \"\"\"",
                    "first_doc": "\"\"\"\nRegisters a custom template test with the Jinja environment.\n\nThis method allows you to add a new test function that can be used within Jinja templates. The test is registered using either the specified name or the function's own name if no name is provided. Functionality is analogous to the `template_test` decorator.\n\nArgs:\n    f: The test function to register as a template test.\n\nReturns:\n    None: This method does not return a value; it registers the test function for use in templates.\n\"\"\"",
                    "method_name": "add_template_test",
                    "second_doc": "\"\"\"\nEnables the addition of custom test functions to the Jinja template environment.\n\nBy allowing registration of custom test functions, this method extends the template language's expressive power, enabling developers to define reusable logic for conditions directly within templates. The function is added under a specified name, or under the function's own name if no name is given, making customized template behavior straightforward and maintainable.\n\nArgs:\n    f (callable): The test function to be registered as a template test.\n    name (str, optional): The name under which the test function will be registered. If not provided, the function's __name__ is used.\n\nReturns:\n    None: Registers the test function for use in templates without returning a value.\n\"\"\"",
                    "source_code": "self.jinja_env.tests[name or f.__name__] = f"
                },
                {
                    "docstring": "\"\"\"A decorator that is used to register a custom template global function.\n        You can specify a name for the global function, otherwise the function\n        name will be used. Example::\n\n            @app.template_global()\n            def double(n):\n                return 2 * n\n\n        .. versionadded:: 0.10\n\n        :param name: the optional name of the global function, otherwise the\n                     function name will be used.\n        \"\"\"",
                    "first_doc": "\"\"\"\nRegisters a custom template global function to be used in templates.\n\nThis method is a decorator that allows you to add a Python function as a global variable in the template context. You can provide a custom name for the function; otherwise, the function's name will be used.\n\nArgs:\n    name: The optional name of the template global function. If not provided, the original function name is used.\n\nReturns:\n    A decorator that registers the given function as a template global and returns the function itself.\n\"\"\"",
                    "method_name": "template_global",
                    "second_doc": "\"\"\"\nAllows you to register a Python function as a global variable accessible within templates using a decorator. By making the function available in the template context, you can simplify the integration of custom logic or helpers directly in your templates.\n\nArgs:\n    name (str, optional): The name under which the function will be available in templates. Defaults to the function's own name if not provided.\n\nReturns:\n    function: A decorator that registers the given function as a template global, ensuring it can be used in any template rendered by the application.\n    \nWhy:\n    Making helper functions available as template globals streamlines template development by allowing reusable logic and utilities to be directly accessed during template rendering. This enhances flexibility and maintainability in template design.\n\"\"\"",
                    "source_code": "def decorator(f):\n            self.add_template_global(f, name=name)\n            return f\n\n        return decorator"
                },
                {
                    "docstring": "\"\"\"Register a custom template global function. Works exactly like the\n        :meth:`template_global` decorator.\n\n        .. versionadded:: 0.10\n\n        :param name: the optional name of the global function, otherwise the\n                     function name will be used.\n        \"\"\"",
                    "first_doc": "\"\"\"\nRegisters a custom function as a global in the Jinja template environment.\n\nThis method allows you to add a global function that can be accessed from any template. It works the same way as the `template_global` decorator.\n\nArgs:\n    f: The function to be added as a global to the template environment.\n\nReturns:\n    None: This method does not return a value; it updates the template environment's global functions.\n\"\"\"",
                    "method_name": "add_template_global",
                    "second_doc": "\"\"\"\nMakes a Python function accessible as a global within the application's Jinja template environment, so it can be called directly from any template during rendering.\n\nThis supports dynamic and reusable logic in templates, allowing templates to leverage application-defined functionality for generating content or handling complex presentation needs.\n\nArgs:\n    f: The function to register as a global in the template environment.\n    name (optional): The name under which the function will be available in templates. If not provided, uses the function's own __name__.\n\nReturns:\n    None: Updates the template environment by adding the function to its globals; does not return a value.\n\"\"\"",
                    "source_code": "self.jinja_env.globals[name or f.__name__] = f"
                },
                {
                    "docstring": "\"\"\"Registers a function to run before each request.\n\n        For example, this can be used to open a database connection, or to load\n        the logged in user from the session.\n\n        The function will be called without any arguments. If it returns a\n        non-None value, the value is handled as if it was the return value from\n        the view, and further request handling is stopped.\n        \"\"\"",
                    "first_doc": "\"\"\"\nRegisters a function to execute before each HTTP request.\n\nThis method allows you to specify a function that is executed prior to handling any incoming request. Typically, this can be used for operations such as opening database connections or loading user information from the session. The registered function is called without arguments for every request. If the function returns a non-None value, that response is sent to the client directly, and further request processing is halted.\n\nArgs:\n    f: The function to be registered and executed before each request.\n\nReturns:\n    The same function passed as the argument, after it has been registered.\n\nClass Fields Initialized:\n    before_request_funcs: A dictionary that stores lists of functions to be called before requests, grouped by blueprint name.\n\"\"\"",
                    "method_name": "before_request",
                    "second_doc": "\"\"\"\nRegisters a function to be executed before each HTTP request is processed.\n\nBy associating a function to run prior to request handling, this method provides a way to execute preparatory tasks, such as setting up environment state, performing access checks, or initializing resources needed during the handling of the incoming request. Running such code early allows the application to control or short-circuit request processing as needed.\n\nArgs:\n    f: A function to be executed before each incoming request. This function takes no arguments.\n\nReturns:\n    The same function passed in (f), after registering it to run before every request. If this function returns a non-None value when called, that response will be sent to the client, and no further route handling will occur.\n\"\"\"",
                    "source_code": "self.before_request_funcs.setdefault(None, []).append(f)\n        return f"
                },
                {
                    "docstring": "\"\"\"Registers a function to be run before the first request to this\n        instance of the application.\n\n        The function will be called without any arguments and its return\n        value is ignored.\n\n        .. versionadded:: 0.8\n        \"\"\"",
                    "first_doc": "\"\"\"\nRegisters a function to be executed before the first request is processed by this application instance.\n\nArgs:\n    self: The instance of the class.\n    f: The function to be registered. This function will be called before the first request and should not accept any arguments. The return value of the function is ignored.\n\nReturns:\n    The registered function `f`.\n\"\"\"",
                    "method_name": "before_first_request",
                    "second_doc": "\"\"\"\nRegisters a function to be run before the server handles any requests, allowing initialization or setup steps to be performed once per application startup.\n\nArgs:\n    self: The current application instance.\n    f: A function with no parameters to execute before processing the initial request. Its return value is ignored.\n\nReturns:\n    The same function `f` that was registered.\n\"\"\"",
                    "source_code": "self.before_first_request_funcs.append(f)\n        return f"
                },
                {
                    "docstring": "\"\"\"Register a function to be run after each request.\n\n        Your function must take one parameter, an instance of\n        :attr:`response_class` and return a new response object or the\n        same (see :meth:`process_response`).\n\n        As of Flask 0.7 this function might not be executed at the end of the\n        request in case an unhandled exception occurred.\n        \"\"\"",
                    "first_doc": "\"\"\"\nRegisters a function to be executed after each request is processed.\n\nThe provided function will be called with the response object after each request. It should accept a single parameter, which is an instance of the response class, and return a response object (which can be new or the same). Note that, as of Flask 0.7, this function may not be executed if an unhandled exception occurs during request processing.\n\nArgs:\n    f: The function to be called after each request. This function must take one parameter (the response object) and return a response.\n\nReturns:\n    The registered function. This allows the decorator pattern or further manipulation.\n\"\"\"",
                    "method_name": "after_request",
                    "second_doc": "\"\"\"\nRegisters a function to be executed after every request to allow unified processing or modification of responses before they are sent to the client.\n\nThis mechanism enables systematic response adjustments, such as setting custom headers or logging, ensuring post-processing logic is consistently applied across all outgoing responses.\n\nArgs:\n    f: A callable that takes a single parameter (the response object) and returns a response instance. The function will be invoked after each request with the current response object.\n\nReturns:\n    The original function 'f', facilitating decorator usage or further manipulation.\n\"\"\"",
                    "source_code": "self.after_request_funcs.setdefault(None, []).append(f)\n        return f"
                },
                {
                    "docstring": "\"\"\"Register a function to be run at the end of each request,\n        regardless of whether there was an exception or not.  These functions\n        are executed when the request context is popped, even if not an\n        actual request was performed.\n\n        Example::\n\n            ctx = app.test_request_context()\n            ctx.push()\n            ...\n            ctx.pop()\n\n        When ``ctx.pop()`` is executed in the above example, the teardown\n        functions are called just before the request context moves from the\n        stack of active contexts.  This becomes relevant if you are using\n        such constructs in tests.\n\n        Generally teardown functions must take every necessary step to avoid\n        that they will fail.  If they do execute code that might fail they\n        will have to surround the execution of these code by try/except\n        statements and log occurring errors.\n\n        When a teardown function was called because of an exception it will\n        be passed an error object.\n\n        The return values of teardown functions are ignored.\n\n        .. admonition:: Debug Note\n\n           In debug mode Flask will not tear down a request on an exception\n           immediately.  Instead it will keep it alive so that the interactive\n           debugger can still access it.  This behavior can be controlled\n           by the ``PRESERVE_CONTEXT_ON_EXCEPTION`` configuration variable.\n        \"\"\"",
                    "first_doc": "\"\"\"\nRegisters a function to be executed at the end of each request, regardless of whether an exception occurred during the request. The registered function is called when the request context is popped from the stack, making it useful in both actual requests and testing scenarios.\n\nArgs:\n    f: The function to register. This function will be called when the request context ends. If the teardown occurs due to an exception, the function will be passed the error object. The return value of this function is ignored.\n\nReturns:\n    The original function that was registered.\n\"\"\"",
                    "method_name": "teardown_request",
                    "second_doc": "\"\"\"\nAssociates a function to run automatically at the conclusion of each request, regardless of success or error, ensuring necessary cleanup or context-specific logic is always performed. By registering these functions, the application can maintain consistent operations and resource management at the end of every request lifecycle.\n\nArgs:\n    f: The function to register. This function will be called when the request context terminates. It will receive the error object if one occurred; otherwise, it receives None. The return value of this function is ignored.\n\nReturns:\n    The original function that was registered.\n\"\"\"",
                    "source_code": "self.teardown_request_funcs.setdefault(None, []).append(f)\n        return f"
                },
                {
                    "docstring": "\"\"\"Registers a function to be called when the application context\n        ends.  These functions are typically also called when the request\n        context is popped.\n\n        Example::\n\n            ctx = app.app_context()\n            ctx.push()\n            ...\n            ctx.pop()\n\n        When ``ctx.pop()`` is executed in the above example, the teardown\n        functions are called just before the app context moves from the\n        stack of active contexts.  This becomes relevant if you are using\n        such constructs in tests.\n\n        Since a request context typically also manages an application\n        context it would also be called when you pop a request context.\n\n        When a teardown function was called because of an unhandled exception\n        it will be passed an error object. If an :meth:`errorhandler` is\n        registered, it will handle the exception and the teardown will not\n        receive it.\n\n        The return values of teardown functions are ignored.\n\n        .. versionadded:: 0.9\n        \"\"\"",
                    "first_doc": "\"\"\"\nRegisters a function to be called when the application context ends.\n\nThis method allows you to register a function that will be executed when the application context is torn down, such as when the context is popped. This is commonly used for cleanup tasks and is relevant for managing resources during application and request context lifecycles. The registered function will receive an error object if called due to an unhandled exception, unless an error handler manages the exception.\n\nArgs:\n    f: The function to be called when the application context ends.\n\nReturns:\n    The registered function. The return value of the registered function itself is ignored.\n\"\"\"",
                    "method_name": "teardown_appcontext",
                    "second_doc": "\"\"\"\nRegisters a function to execute automatically when the application context is torn down, ensuring that custom cleanup or resource management logic can be performed at the appropriate phase of the application lifecycle. This registration mechanism allows developers to maintain application stability and efficiency by reliably releasing resources, such as closing database connections or undoing temporary configurations, whenever the context concludes\u2014regardless of how or why the context ends.\n\nArgs:\n    f (callable): A function to be invoked when the application context ends. This function will be passed an error argument if an exception caused the teardown; otherwise, it receives None.\n\nReturns:\n    callable: The same function that was registered. The return value of the registered function is intentionally ignored.\n\"\"\"",
                    "source_code": "self.teardown_appcontext_funcs.append(f)\n        return f"
                },
                {
                    "docstring": "\"\"\"Registers a template context processor function.\"\"\"",
                    "first_doc": "\"\"\"\nRegisters a template context processor function.\n\nArgs:\n    self: The instance of the class.\n    f: The function to register as a template context processor.\n\nReturns:\n    The registered template context processor function.\n\"\"\"",
                    "method_name": "context_processor",
                    "second_doc": "\"\"\"\nRegisters a function that will inject additional variables into the template rendering context, making dynamic data accessible in all templates.\n\nArgs:\n    self: The Flask application instance.\n    f: A function that returns a dictionary of context variables to be added to each template context.\n\nReturns:\n    function: The same function that was registered as a template context processor.\n\"\"\"",
                    "source_code": "self.template_context_processors[None].append(f)\n        return f"
                },
                {
                    "docstring": "\"\"\"Registers a shell context processor function.\n\n        .. versionadded:: 0.11\n        \"\"\"",
                    "first_doc": "\"\"\"\nRegisters a function as a shell context processor.\n\nThis method adds the provided function to the list of shell context processor functions. These processors are used to extend or modify the context available in the interactive shell session.\n\nArgs:\n    self: The instance of the class.\n    f: The function to register as a shell context processor.\n\nReturns:\n    The registered function. This allows the decorator to be used directly on the target function.\n\"\"\"",
                    "method_name": "shell_context_processor",
                    "second_doc": "\"\"\"\nRegisters a function to enrich the context available in the interactive shell session.\n\nBy maintaining a list of shell context processor functions, this method allows developers to customize the set of variables and objects automatically accessible when using the Flask interactive shell. This facilitates easier debugging and testing by pre-loading useful resources into the shell environment.\n\nArgs:\n    self: The Flask application instance.\n    f: A function to register as a shell context processor. This function should return a dictionary of items to include in the shell context.\n\nReturns:\n    The registered function, allowing this method to be used as a decorator.\n\"\"\"",
                    "source_code": "self.shell_context_processors.append(f)\n        return f"
                },
                {
                    "docstring": "\"\"\"Register a URL value preprocessor function for all view\n        functions in the application. These functions will be called before the\n        :meth:`before_request` functions.\n\n        The function can modify the values captured from the matched url before\n        they are passed to the view. For example, this can be used to pop a\n        common language code value and place it in ``g`` rather than pass it to\n        every view.\n\n        The function is passed the endpoint name and values dict. The return\n        value is ignored.\n        \"\"\"",
                    "first_doc": "\"\"\"\nRegisters a URL value preprocessor function for all view functions in the application.\n\nThis method adds a function that will be called before the :meth:`before_request` functions. The registered function can modify the values captured from the matched URL before they are passed to the view. This can be used, for example, to extract a common value such as a language code and store it elsewhere, rather than passing it as a parameter to every view.\n\nArgs:\n    f: The function to be registered as a URL value preprocessor. The function should accept the endpoint name and a values dictionary as arguments. Its return value is ignored.\n\nReturns:\n    The function `f` that was registered.\n\nAttributes initialized:\n    url_value_preprocessors: A dictionary mapping endpoint names to lists of preprocessor functions. The function `f` will be appended to the list for the `None` endpoint, registering it globally.\n\"\"\"",
                    "method_name": "url_value_preprocessor",
                    "second_doc": "\"\"\"\nRegisters a URL value preprocessor function to be invoked before view functions receive parameters captured from a matched URL route.\n\nBy allowing modification of URL parameters prior to request processing, this method enables preprocessing or normalization of data extracted from the URL. This supports advanced request handling scenarios, such as extracting or transforming route parameters consistently across the application.\n\nArgs:\n    f: A function that takes two arguments\u2014`endpoint` (the name of the matched endpoint) and `values` (a dictionary of arguments captured from the URL). The function can modify `values` in-place. Its return value is ignored.\n\nReturns:\n    The registered preprocessor function `f`.\n\nAttributes initialized:\n    url_value_preprocessors: A mapping of endpoint names to lists of preprocessor functions. The provided function is appended to the list for the global (None) endpoint, making it active for all routes.\n\"\"\"",
                    "source_code": "self.url_value_preprocessors.setdefault(None, []).append(f)\n        return f"
                },
                {
                    "docstring": "\"\"\"Callback function for URL defaults for all view functions of the\n        application.  It's called with the endpoint and values and should\n        update the values passed in place.\n        \"\"\"",
                    "first_doc": "\"\"\"\nRegisters a callback function to set default URL values for all view functions in the application.\n\nArgs:\n    f: The callback function to be invoked for providing default values to the URL for all view functions.\n\nReturns:\n    The callback function that was registered.\n\nClass Fields Initialized:\n    url_default_functions: A dictionary that maps endpoint names to lists of callback functions for setting URL defaults. Used to register and manage URL default functions in the application.\n\"\"\"",
                    "method_name": "url_defaults",
                    "second_doc": "\"\"\"\nAssociates a callback function that will be invoked to supply default values for URL building across all application view functions. This mechanism ensures consistent population of URL arguments whenever URLs are generated, streamlining link creation and reducing the need for repetitive code.\n\nArgs:\n    f (callable): The callback function to be called when setting default URL values for all view functions. This function should accept the endpoint and values as arguments and modify the values dictionary in place as needed.\n\nReturns:\n    callable: The same callback function that was registered, enabling decorator usage and possible chaining.\n\"\"\"",
                    "source_code": "self.url_default_functions.setdefault(None, []).append(f)\n        return f"
                },
                {
                    "docstring": "\"\"\"Return a registered error handler for an exception in this order:\n        blueprint handler for a specific code, app handler for a specific code,\n        blueprint handler for an exception class, app handler for an exception\n        class, or ``None`` if a suitable handler is not found.\n        \"\"\"",
                    "first_doc": "\"\"\"\nFinds and returns a registered error handler for a given exception.\n\nSearches for an appropriate error handler in the following order: blueprint handler for a specific code, app handler for a specific code, blueprint handler for an exception class, app handler for an exception class. If no suitable handler is found, returns None.\n\nArgs:\n    self: The instance of the class containing error handler specifications.\n    e: The exception instance for which to find a handler.\n\nReturns:\n    The error handler callable associated with the exception or error code if found; otherwise, None.\n\"\"\"",
                    "method_name": "_find_error_handler",
                    "second_doc": "\"\"\"\nSelects the most suitable error handler for a given exception based on the error handler resolution rules.\n\nThe method looks up the error handler that best matches the provided exception by prioritizing handlers registered for specific response codes and exception classes, taking into account both application-wide and blueprint-specific configurations. This ensures that exceptions are processed in a manner consistent with the application's error handling policies, leading to appropriate user responses or logging when errors occur.\n\nArgs:\n    self: The Flask instance containing registered error handler specifications.\n    e: The exception instance that triggered error handling.\n\nReturns:\n    Callable: The error handler function associated with the exception or its code if found; otherwise, None.\n\"\"\"",
                    "source_code": "exc_class, code = self._get_exc_class_and_code(type(e))\n\n        for name, c in (\n            (request.blueprint, code),\n            (None, code),\n            (request.blueprint, None),\n            (None, None),\n        ):\n            handler_map = self.error_handler_spec.setdefault(name, {}).get(c)\n\n            if not handler_map:\n                continue\n\n            for cls in exc_class.__mro__:\n                handler = handler_map.get(cls)\n\n                if handler is not None:\n                    return handler"
                },
                {
                    "docstring": "\"\"\"Handles an HTTP exception.  By default this will invoke the\n        registered error handlers and fall back to returning the\n        exception as response.\n\n        .. versionchanged:: 1.0.3\n            ``RoutingException``, used internally for actions such as\n             slash redirects during routing, is not passed to error\n             handlers.\n\n        .. versionchanged:: 1.0\n            Exceptions are looked up by code *and* by MRO, so\n            ``HTTPExcpetion`` subclasses can be handled with a catch-all\n            handler for the base ``HTTPException``.\n\n        .. versionadded:: 0.3\n        \"\"\"",
                    "first_doc": "\"\"\"\nHandles an HTTP exception by invoking registered error handlers or returning the exception as a response.\n\nThis method processes HTTP exceptions raised during request handling. It checks for a matching error handler registered for the exception. If a handler is found, it will be called and its return value is used; otherwise, the exception itself is returned. Some exceptions, such as routing exceptions or those without error codes, are always returned unchanged.\n\nArgs:\n    self: The instance of the class.\n    e: The HTTP exception instance to be handled.\n\nReturns:\n    The result from the error handler if found; otherwise, returns the exception itself.\n\"\"\"",
                    "method_name": "handle_http_exception",
                    "second_doc": "\"\"\"\nDetermines the appropriate way to handle an HTTP exception encountered during request processing, either by delegating to a registered error handler or returning the exception itself.\n\nThis method ensures that exceptions generated during HTTP request handling are processed in a consistent manner: if they correspond to specific application logic (such as redirections or internal routing mechanisms) or lack an HTTP status code, they are immediately returned. Otherwise, the method attempts to match the exception with a user-defined error handler to provide customized handling or responses, falling back to the original exception if no handler exists.\n\nArgs:\n    self: The Flask application instance.\n    e: The HTTP exception instance encountered during request handling.\n\nReturns:\n    The response generated by a matching error handler if one is registered; otherwise, the original exception instance.\n\"\"\"",
                    "source_code": "# Proxy exceptions don't have error codes.  We want to always return\n        # those unchanged as errors\n        if e.code is None:\n            return e\n\n        # RoutingExceptions are used internally to trigger routing\n        # actions, such as slash redirects raising RequestRedirect. They\n        # are not raised or handled in user code.\n        if isinstance(e, RoutingException):\n            return e\n\n        handler = self._find_error_handler(e)\n        if handler is None:\n            return e\n        return handler(e)"
                },
                {
                    "docstring": "\"\"\"Checks if an HTTP exception should be trapped or not.  By default\n        this will return ``False`` for all exceptions except for a bad request\n        key error if ``TRAP_BAD_REQUEST_ERRORS`` is set to ``True``.  It\n        also returns ``True`` if ``TRAP_HTTP_EXCEPTIONS`` is set to ``True``.\n\n        This is called for all HTTP exceptions raised by a view function.\n        If it returns ``True`` for any exception the error handler for this\n        exception is not called and it shows up as regular exception in the\n        traceback.  This is helpful for debugging implicitly raised HTTP\n        exceptions.\n\n        .. versionchanged:: 1.0\n            Bad request errors are not trapped by default in debug mode.\n\n        .. versionadded:: 0.8\n        \"\"\"",
                    "first_doc": "\"\"\"\nDetermines whether an HTTP exception should be trapped or passed through to the error handler.\n\nThis method checks configuration settings to decide if an HTTP exception, such as a bad request or a general HTTP error, should be trapped. Trapped exceptions are shown as regular exceptions in tracebacks, which is useful for debugging. The method considers application-level configuration options to make this decision, specifically `TRAP_HTTP_EXCEPTIONS` and `TRAP_BAD_REQUEST_ERRORS`.\n\nArgs:\n    self: The instance of the class containing configuration and debug state.\n    e: The HTTP exception instance being evaluated for trapping.\n\nReturns:\n    bool: True if the HTTP exception should be trapped (i.e., shown as a normal exception in the traceback); False if it should be handled by the registered error handler.\n\"\"\"",
                    "method_name": "trap_http_exception",
                    "second_doc": "\"\"\"\nDetermines whether an HTTP exception should be displayed as a standard exception or handled by the application's error handlers.\n\nThe method evaluates application configuration and runtime conditions to decide how specific HTTP errors are surfaced during request handling. By allowing certain exceptions to be shown as regular Python errors, it supports easier identification and debugging of issues encountered during development or testing.\n\nArgs:\n    self: The Flask application instance, providing configuration and debug state.\n    e: The HTTP exception instance under consideration.\n\nReturns:\n    bool: True if the HTTP exception should be displayed as a standard exception (for traceback and debugging); False if it should be processed by the application's error handling workflow.\n\"\"\"",
                    "source_code": "if self.config[\"TRAP_HTTP_EXCEPTIONS\"]:\n            return True\n\n        trap_bad_request = self.config[\"TRAP_BAD_REQUEST_ERRORS\"]\n\n        # if unset, trap key errors in debug mode\n        if (\n            trap_bad_request is None\n            and self.debug\n            and isinstance(e, BadRequestKeyError)\n        ):\n            return True\n\n        if trap_bad_request:\n            return isinstance(e, BadRequest)\n\n        return False"
                },
                {
                    "docstring": "\"\"\"This method is called whenever an exception occurs that\n        should be handled. A special case is :class:`~werkzeug\n        .exceptions.HTTPException` which is forwarded to the\n        :meth:`handle_http_exception` method. This function will either\n        return a response value or reraise the exception with the same\n        traceback.\n\n        .. versionchanged:: 1.0\n            Key errors raised from request data like ``form`` show the\n            bad key in debug mode rather than a generic bad request\n            message.\n\n        .. versionadded:: 0.7\n        \"\"\"",
                    "first_doc": "\"\"\"\nHandles exceptions raised during request handling, forwarding specific HTTP exceptions and applying custom error handlers as needed.\n\nArgs:\n    self: The instance of the class handling exceptions.\n    e: The exception instance to process.\n\nReturns:\n    The response value resulting from the error handler, the HTTP exception handler, or reraises the original exception with the same traceback if no handler is found.\n\"\"\"",
                    "method_name": "handle_user_exception",
                    "second_doc": "\"\"\"\nInterprets and manages exceptions occurring during a web request, forwarding standard HTTP exceptions or delegating to user-defined error handlers. This ensures that meaningful error responses are generated or the original error is propagated if no handler can be found.\n\nArgs:\n    self: The Flask application instance.\n    e: The exception instance that was raised during request processing.\n\nReturns:\n    A response generated by a custom error handler, the default HTTP exception response, or raises the original exception with its traceback if an appropriate handler does not exist.\n\nWhy:\n    This mechanism provides robust and flexible error management within web applications, allowing for detailed error responses, improved debugging during development, and graceful degradation in production environments.\n\"\"\"",
                    "source_code": "if isinstance(e, BadRequestKeyError):\n            if self.debug or self.config[\"TRAP_BAD_REQUEST_ERRORS\"]:\n                e.show_exception = True\n\n                # Werkzeug < 0.15 doesn't add the KeyError to the 400\n                # message, add it in manually.\n                # TODO: clean up once Werkzeug >= 0.15.5 is required\n                if e.args[0] not in e.get_description():\n                    e.description = f\"KeyError: {e.args[0]!r}\"\n            elif not hasattr(BadRequestKeyError, \"show_exception\"):\n                e.args = ()\n\n        if isinstance(e, HTTPException) and not self.trap_http_exception(e):\n            return self.handle_http_exception(e)\n\n        handler = self._find_error_handler(e)\n\n        if handler is None:\n            raise\n\n        return handler(e)"
                },
                {
                    "docstring": "\"\"\"Handle an exception that did not have an error handler\n        associated with it, or that was raised from an error handler.\n        This always causes a 500 ``InternalServerError``.\n\n        Always sends the :data:`got_request_exception` signal.\n\n        If :attr:`propagate_exceptions` is ``True``, such as in debug\n        mode, the error will be re-raised so that the debugger can\n        display it. Otherwise, the original exception is logged, and\n        an :exc:`~werkzeug.exceptions.InternalServerError` is returned.\n\n        If an error handler is registered for ``InternalServerError`` or\n        ``500``, it will be used. For consistency, the handler will\n        always receive the ``InternalServerError``. The original\n        unhandled exception is available as ``e.original_exception``.\n\n        .. note::\n            Prior to Werkzeug 1.0.0, ``InternalServerError`` will not\n            always have an ``original_exception`` attribute. Use\n            ``getattr(e, \"original_exception\", None)`` to simulate the\n            behavior for compatibility.\n\n        .. versionchanged:: 1.1.0\n            Always passes the ``InternalServerError`` instance to the\n            handler, setting ``original_exception`` to the unhandled\n            error.\n\n        .. versionchanged:: 1.1.0\n            ``after_request`` functions and other finalization is done\n            even for the default 500 response when there is no handler.\n\n        .. versionadded:: 0.3\n        \"\"\"",
                    "first_doc": "\"\"\"\nHandles an exception that occurred without an associated error handler or was raised from an error handler, resulting in a 500 Internal Server Error.\n\nSends the got_request_exception signal for the given exception. If the propagate_exceptions attribute is True (such as in debug mode), the given exception is re-raised to allow debugging. Otherwise, the original exception is logged, and a Werkzeug InternalServerError is returned. If an error handler is registered for InternalServerError or HTTP code 500, it will be used and always receive an InternalServerError instance with the original exception attached as original_exception.\n\nArgs:\n    self: The instance of the class.\n    e: The original unhandled exception to handle.\n\nReturns:\n    A response object generated from the finalized request for the error, usually a Werkzeug InternalServerError response or a custom handler's result.\n\"\"\"",
                    "method_name": "handle_exception",
                    "second_doc": "\"\"\"\nHandles unexpected exceptions that occur during the processing of a client request when no specific error handler is available, ensuring that the application remains responsive by generating an appropriate error response.\n\nThis method notifies the system of the unhandled exception, determines whether to propagate the exception for debugging purposes, logs the error if not propagating, and constructs an InternalServerError response. If a custom handler for such errors exists, it is invoked to process the error response. This approach maintains reliability and provides developers with valuable error signals, supporting both robust error reporting in production and detailed debugging during development.\n\nArgs:\n    self: The Flask application instance.\n    e: Exception\n        The unhandled exception that triggered the error handling mechanism.\n\nReturns:\n    Response\n        An HTTP response object representing a 500 Internal Server Error, either the default provided by Werkzeug or the result of a registered custom error handler.\n\"\"\"",
                    "source_code": "exc_info = sys.exc_info()\n        got_request_exception.send(self, exception=e)\n\n        if self.propagate_exceptions:\n            # Re-raise if called with an active exception, otherwise\n            # raise the passed in exception.\n            if exc_info[1] is e:\n                raise\n\n            raise e\n\n        self.log_exception(exc_info)\n        server_error = InternalServerError()\n        # TODO: pass as param when Werkzeug>=1.0.0 is required\n        # TODO: also remove note about this from docstring and docs\n        server_error.original_exception = e\n        handler = self._find_error_handler(server_error)\n\n        if handler is not None:\n            server_error = handler(server_error)\n\n        return self.finalize_request(server_error, from_error_handler=True)"
                },
                {
                    "docstring": "\"\"\"Logs an exception.  This is called by :meth:`handle_exception`\n        if debugging is disabled and right before the handler is called.\n        The default implementation logs the exception as error on the\n        :attr:`logger`.\n\n        .. versionadded:: 0.8\n        \"\"\"",
                    "first_doc": "\"\"\"\nLogs an exception using the configured logger.\n\nLogs details about an exception that occurred during the handling of a request. This method is typically called when debugging is disabled, and immediately before the registered exception handler is invoked.\n\nArgs:\n    exc_info: The exception information tuple, as returned by sys.exc_info(), describing the current exception to be logged.\n\nReturns:\n    None: This method does not return a value.\n\"\"\"",
                    "method_name": "log_exception",
                    "second_doc": "\"\"\"\nRecords detailed information about an exception that occurred during request processing, using the application's logger. This helps maintain clear error tracking and facilitates issue diagnosis in production environments where debugging is turned off.\n\nArgs:\n    exc_info: A tuple containing exception information (type, value, traceback), typically as returned by sys.exc_info(), representing the current exception to be logged.\n\nReturns:\n    None: This method performs logging and does not return any value.\n\"\"\"",
                    "source_code": "self.logger.error(\n            f\"Exception on {request.path} [{request.method}]\", exc_info=exc_info\n        )"
                },
                {
                    "docstring": "\"\"\"Exceptions that are recording during routing are reraised with\n        this method.  During debug we are not reraising redirect requests\n        for non ``GET``, ``HEAD``, or ``OPTIONS`` requests and we're raising\n        a different error instead to help debug situations.\n\n        :internal:\n        \"\"\"",
                    "first_doc": "\"\"\"\nRaises the appropriate routing exception encountered during request routing.\n\nDuring debug mode, this method adjusts the behavior when reraising routing exceptions to aid in debugging. Specifically, it prevents reraising redirect requests for non-``GET``, ``HEAD``, or ``OPTIONS`` methods and raises a different exception to help diagnose issues.\n\nArgs:\n    self: The instance of the class.\n    request: The current request object that may contain a routing exception.\n\nReturns:\n    None. This method raises an exception and does not return a value.\n\"\"\"",
                    "method_name": "raise_routing_exception",
                    "second_doc": "\"\"\"\nHandles exceptions that occur during URL routing by selectively raising them to ensure appropriate feedback based on the request type and environment.\n\nThis method adapts its behavior for debug scenarios to provide more informative error messages, especially when redirects result from non-``GET``, ``HEAD``, or ``OPTIONS`` requests. By raising specialized exceptions in these cases, it supports easier identification and resolution of routing issues.\n\nArgs:\n    self: The Flask application instance.\n    request: The current request object containing routing information and potential exceptions.\n\nReturns:\n    None. This method does not return a value; instead, it raises an exception depending on the routing context.\n\"\"\"",
                    "source_code": "if (\n            not self.debug\n            or not isinstance(request.routing_exception, RequestRedirect)\n            or request.method in (\"GET\", \"HEAD\", \"OPTIONS\")\n        ):\n            raise request.routing_exception\n\n        from .debughelpers import FormDataRoutingRedirect\n\n        raise FormDataRoutingRedirect(request)"
                },
                {
                    "docstring": "\"\"\"Does the request dispatching.  Matches the URL and returns the\n        return value of the view or error handler.  This does not have to\n        be a response object.  In order to convert the return value to a\n        proper response object, call :func:`make_response`.\n\n        .. versionchanged:: 0.7\n           This no longer does the exception handling, this code was\n           moved to the new :meth:`full_dispatch_request`.\n        \"\"\"",
                    "first_doc": "\"\"\"\nDispatches the incoming request by matching the URL to an endpoint and invoking the corresponding view or error handler.\n\nThis method selects the appropriate view function or error handler based on the request's URL and parameters. If the request is an OPTIONS method and the URL rule is configured to provide automatic options, a default options response is returned. Otherwise, the corresponding view function is called with the URL arguments. Any routing exceptions are handled prior to dispatch.\n\nArgs:\n    self: The instance of the class.\n\nReturns:\n    The return value of the view function or error handler associated with the matched URL rule. This is not necessarily a response object; use make_response to convert it to a proper response object if needed.\n\"\"\"",
                    "method_name": "dispatch_request",
                    "second_doc": "\"\"\"\nProcesses an incoming HTTP request by selecting the appropriate function to handle the request based on the matched URL pattern or manages exceptions occurring during routing. If an automatic response to OPTIONS requests is configured for the matched route, it is generated and returned; otherwise, the designated handler for the endpoint is invoked with the extracted arguments. This approach ensures that each request is directed to the correct processing logic according to the application's URL mapping, improving modularity and flexibility in response handling.\n\nArgs:\n    self: The Flask application instance.\n\nReturns:\n    The result of the matched view function, error handler, or an automatic OPTIONS response based on the incoming request's URL and method. The returned value may not be a complete response object; use make_response to convert it into a response if needed.\n\"\"\"",
                    "source_code": "req = _request_ctx_stack.top.request\n        if req.routing_exception is not None:\n            self.raise_routing_exception(req)\n        rule = req.url_rule\n        # if we provide automatic options for this URL and the\n        # request came with the OPTIONS method, reply automatically\n        if (\n            getattr(rule, \"provide_automatic_options\", False)\n            and req.method == \"OPTIONS\"\n        ):\n            return self.make_default_options_response()\n        # otherwise dispatch to the handler for that endpoint\n        return self.view_functions[rule.endpoint](**req.view_args)"
                },
                {
                    "docstring": "\"\"\"Dispatches the request and on top of that performs request\n        pre and postprocessing as well as HTTP exception catching and\n        error handling.\n\n        .. versionadded:: 0.7\n        \"\"\"",
                    "first_doc": "\"\"\"\nDispatches the request with preprocessing and postprocessing, including HTTP exception catching and error handling.\n\nThis method orchestrates the full request dispatch cycle. It triggers any \"before first request\" functions, sends the request started signal, handles request preprocessing, dispatches the request if necessary, and manages exception catching and error handling before finalizing and returning the response.\n\nArgs:\n    self: The instance of the class.\n\nReturns:\n    The finalized response after the request has been fully dispatched, including any preprocessing, exception handling, and postprocessing steps.\n\"\"\"",
                    "method_name": "full_dispatch_request",
                    "second_doc": "\"\"\"\nHandles the complete cycle of processing a web request, coordinating initialization, request preprocessing, routing, exception handling, and response finalization.\n\nThis method ensures each incoming request is properly prepared, processed, and concluded, so responses are correctly generated and all application hooks, error management, and extension signals are respected. By centralizing these steps, it maintains application consistency and robust error handling for each client interaction.\n\nArgs:\n    self: Instance of the web framework application handling the request.\n\nReturns:\n    A finalized response object that incorporates preprocessing, routed handling, exception management, and any after-request operations.\n\"\"\"",
                    "source_code": "self.try_trigger_before_first_request_functions()\n        try:\n            request_started.send(self)\n            rv = self.preprocess_request()\n            if rv is None:\n                rv = self.dispatch_request()\n        except Exception as e:\n            rv = self.handle_user_exception(e)\n        return self.finalize_request(rv)"
                },
                {
                    "docstring": "\"\"\"Given the return value from a view function this finalizes\n        the request by converting it into a response and invoking the\n        postprocessing functions.  This is invoked for both normal\n        request dispatching as well as error handlers.\n\n        Because this means that it might be called as a result of a\n        failure a special safe mode is available which can be enabled\n        with the `from_error_handler` flag.  If enabled, failures in\n        response processing will be logged and otherwise ignored.\n\n        :internal:\n        \"\"\"",
                    "first_doc": "\"\"\"\nFinalizes the request by converting the return value from a view function into a response and invoking postprocessing functions.\n\nThis method handles the finalization for both normal request dispatching and error handlers. If called as a result of an error, set the `from_error_handler` flag to enable a safe mode where failures in response processing are logged and ignored rather than raised.\n\nArgs:\n    rv: The return value from a view function to be converted into a response.\n\nReturns:\n    The finalized response object after processing and postprocessing steps.\n\"\"\"",
                    "method_name": "finalize_request",
                    "second_doc": "\"\"\"\nTransforms the return value from a view function into an HTTP response and applies postprocessing to ensure the response is ready for transmission to the client.\n\nThis method centralizes the final step of the request-handling lifecycle, guaranteeing that any return value is properly adapted for client communication and that relevant cleanup or signaling (such as notifying request completion) occurs. In the context of error handling, it ensures application stability by logging and suppressing response postprocessing failures instead of letting them cause further disruption.\n\nArgs:\n    rv: The return value produced by a view function, which will be converted into a standardized HTTP response.\n    from_error_handler (bool): Indicates if the method is being called during error handling, in which case response processing failures are logged instead of raised.\n\nReturns:\n    A fully processed and postprocessed response object, ready to be returned to the client.\n\"\"\"",
                    "source_code": "response = self.make_response(rv)\n        try:\n            response = self.process_response(response)\n            request_finished.send(self, response=response)\n        except Exception:\n            if not from_error_handler:\n                raise\n            self.logger.exception(\n                \"Request finalizing failed with an error while handling an error\"\n            )\n        return response"
                },
                {
                    "docstring": "\"\"\"Called before each request and will ensure that it triggers\n        the :attr:`before_first_request_funcs` and only exactly once per\n        application instance (which means process usually).\n\n        :internal:\n        \"\"\"",
                    "first_doc": "\"\"\"\nEnsures that the functions registered to run before the first request are triggered exactly once per application instance.\n\nArgs:\n    self: The instance of the class.\n\nReturns:\n    None: This method does not return a value.\n\nAttributes initialized:\n    self._got_first_request: A flag indicating whether the before-first-request functions have already been triggered. Set to True after execution.\n    self._before_request_lock: A lock used to ensure thread safety when checking or updating the first request trigger state.\n    self.before_first_request_funcs: A list of functions to be executed before processing the first request.\n\"\"\"",
                    "method_name": "try_trigger_before_first_request_functions",
                    "second_doc": "\"\"\"\nExecutes all functions registered to run before the application's first request, ensuring this initialization step occurs only once per application instance, even in multi-threaded environments.\n\nThis mechanism guarantees that necessary setup routines are completed just before the application processes its first client request, helping maintain proper application state and readiness.\n\nArgs:\n    self: The Flask application instance.\n\nReturns:\n    None: This method does not return a value.\n\nAttributes initialized:\n    self._got_first_request: A boolean flag indicating if the pre-request functions have been executed; set to True after invocation.\n    self._before_request_lock: A threading lock used to prevent multiple threads from triggering the initialization routines concurrently.\n    self.before_first_request_funcs: A list of callables to be executed before handling the first incoming request.\n\"\"\"",
                    "source_code": "if self._got_first_request:\n            return\n        with self._before_request_lock:\n            if self._got_first_request:\n                return\n            for func in self.before_first_request_funcs:\n                func()\n            self._got_first_request = True"
                },
                {
                    "docstring": "\"\"\"This method is called to create the default ``OPTIONS`` response.\n        This can be changed through subclassing to change the default\n        behavior of ``OPTIONS`` responses.\n\n        .. versionadded:: 0.7\n        \"\"\"",
                    "first_doc": "\"\"\"\nGenerates the default HTTP OPTIONS response for the current request.\n\nThis method creates a response object representing allowed HTTP methods for the requested resource. It is typically used to provide information about which HTTP methods are supported by an endpoint. Subclass this method to customize the behavior of OPTIONS responses.\n\nArgs:\n    self: The instance of the class.\n\nReturns:\n    A response object pre-populated with the allowed HTTP methods in the \"Allow\" header.\n\"\"\"",
                    "method_name": "make_default_options_response",
                    "second_doc": "\"\"\"\nConstructs a default HTTP OPTIONS response to inform clients of the HTTP methods permitted for the current request's route.\n\nThis method is used so that clients can automatically discover valid actions for a resource, enabling correct and safe interaction with the API or web application.\n\nArgs:\n    self: The current instance of the Flask application handling the request.\n\nReturns:\n    A response object with the \"Allow\" header listing the HTTP methods permitted for the requested resource.\n\"\"\"",
                    "source_code": "adapter = _request_ctx_stack.top.url_adapter\n        methods = adapter.allowed_methods()\n        rv = self.response_class()\n        rv.allow.update(methods)\n        return rv"
                },
                {
                    "docstring": "\"\"\"This is called to figure out if an error should be ignored\n        or not as far as the teardown system is concerned.  If this\n        function returns ``True`` then the teardown handlers will not be\n        passed the error.\n\n        .. versionadded:: 0.10\n        \"\"\"",
                    "first_doc": "\"\"\"\nDetermines whether a given error should be ignored by the teardown system.\n\nIf this method returns True, the teardown handlers will not be passed the provided error.\n\nArgs:\n    self: The instance of the class.\n    error: The error to be evaluated for ignoring during teardown.\n\nReturns:\n    bool: True if the error should be ignored by teardown handlers; otherwise, False.\n\"\"\"",
                    "method_name": "should_ignore_error",
                    "second_doc": "\"\"\"\nEvaluates if a given error should be processed during the teardown phase of a request-response cycle. By default, all errors are considered for teardown handling to ensure robust application cleanup and consistent error management.\n\nArgs:\n    self: The Flask application instance.\n    error: The exception object to be evaluated.\n\nReturns:\n    bool: False, indicating that the error will not be ignored and should be handled by teardown handlers.\n\"\"\"",
                    "source_code": "return False"
                },
                {
                    "docstring": "\"\"\"Convert the return value from a view function to an instance of\n        :attr:`response_class`.\n\n        :param rv: the return value from the view function. The view function\n            must return a response. Returning ``None``, or the view ending\n            without returning, is not allowed. The following types are allowed\n            for ``view_rv``:\n\n            ``str``\n                A response object is created with the string encoded to UTF-8\n                as the body.\n\n            ``bytes``\n                A response object is created with the bytes as the body.\n\n            ``dict``\n                A dictionary that will be jsonify'd before being returned.\n\n            ``tuple``\n                Either ``(body, status, headers)``, ``(body, status)``, or\n                ``(body, headers)``, where ``body`` is any of the other types\n                allowed here, ``status`` is a string or an integer, and\n                ``headers`` is a dictionary or a list of ``(key, value)``\n                tuples. If ``body`` is a :attr:`response_class` instance,\n                ``status`` overwrites the exiting value and ``headers`` are\n                extended.\n\n            :attr:`response_class`\n                The object is returned unchanged.\n\n            other :class:`~werkzeug.wrappers.Response` class\n                The object is coerced to :attr:`response_class`.\n\n            :func:`callable`\n                The function is called as a WSGI application. The result is\n                used to create a response object.\n\n        .. versionchanged:: 0.9\n           Previously a tuple was interpreted as the arguments for the\n           response object.\n        \"\"\"",
                    "first_doc": "\"\"\"\nConverts the return value from a view function into an instance of the response class.\n\nThis method takes the return value from a view function and ensures it is converted into an appropriate response object, depending on its type. Supported return types include strings, bytes, dictionaries, tuples with response information, instances of the configured response class, or WSGI callables. Tuples may specify body, status, and headers, and these are unpacked and applied to the response as needed. If the return value is invalid or None, an error is raised.\n\nArgs:\n    self: The instance of the class.\n    rv: The return value from the view function, which may be of several allowed types including str, bytes, dict, tuple, the response class, or a WSGI callable.\n\nReturns:\n    An instance of the response class with status and headers applied as needed, suitable for returning to the client.\n\"\"\"",
                    "method_name": "make_response",
                    "second_doc": "\"\"\"\nTransforms the output from a route handler into a standardized response object that can be sent to the client.\n\nThis method analyzes the value returned by a route function, handling different possible formats (such as strings, dictionaries, tuples, WSGI callables, or response objects), and converts them into a consistent response type. This ensures flexibility for the developer while maintaining a uniform response interface required by the server, correctly applying status codes and headers when specified. It raises errors if an unsupported or no value is returned, enforcing robust handler design.\n\nArgs:\n    self: The Flask application instance.\n    rv: The value returned from a view function, which may be a string, bytes, dict, tuple, a response object, or a WSGI callable.\n\nReturns:\n    An instance of the configured response class, populated with the appropriate body, status, and headers to be delivered to the client.\n\"\"\"",
                    "source_code": "status = headers = None\n\n        # unpack tuple returns\n        if isinstance(rv, tuple):\n            len_rv = len(rv)\n\n            # a 3-tuple is unpacked directly\n            if len_rv == 3:\n                rv, status, headers = rv\n            # decide if a 2-tuple has status or headers\n            elif len_rv == 2:\n                if isinstance(rv[1], (Headers, dict, tuple, list)):\n                    rv, headers = rv\n                else:\n                    rv, status = rv\n            # other sized tuples are not allowed\n            else:\n                raise TypeError(\n                    \"The view function did not return a valid response tuple.\"\n                    \" The tuple must have the form (body, status, headers),\"\n                    \" (body, status), or (body, headers).\"\n                )\n\n        # the body must not be None\n        if rv is None:\n            raise TypeError(\n                f\"The view function for {request.endpoint!r} did not\"\n                \" return a valid response. The function either returned\"\n                \" None or ended without a return statement.\"\n            )\n\n        # make sure the body is an instance of the response class\n        if not isinstance(rv, self.response_class):\n            if isinstance(rv, (str, bytes, bytearray)):\n                # let the response class set the status and headers instead of\n                # waiting to do it manually, so that the class can handle any\n                # special logic\n                rv = self.response_class(rv, status=status, headers=headers)\n                status = headers = None\n            elif isinstance(rv, dict):\n                rv = jsonify(rv)\n            elif isinstance(rv, BaseResponse) or callable(rv):\n                # evaluate a WSGI callable, or coerce a different response\n                # class to the correct type\n                try:\n                    rv = self.response_class.force_type(rv, request.environ)\n                except TypeError as e:\n                    raise TypeError(\n                        f\"{e}\\nThe view function did not return a valid\"\n                        \" response. The return type must be a string,\"\n                        \" dict, tuple, Response instance, or WSGI\"\n                        f\" callable, but it was a {type(rv).__name__}.\"\n                    ).with_traceback(sys.exc_info()[2])\n            else:\n                raise TypeError(\n                    \"The view function did not return a valid\"\n                    \" response. The return type must be a string,\"\n                    \" dict, tuple, Response instance, or WSGI\"\n                    f\" callable, but it was a {type(rv).__name__}.\"\n                )\n\n        # prefer the status if it was provided\n        if status is not None:\n            if isinstance(status, (str, bytes, bytearray)):\n                rv.status = status\n            else:\n                rv.status_code = status\n\n        # extend existing headers with provided headers\n        if headers:\n            rv.headers.extend(headers)\n\n        return rv"
                },
                {
                    "docstring": "\"\"\"Creates a URL adapter for the given request. The URL adapter\n        is created at a point where the request context is not yet set\n        up so the request is passed explicitly.\n\n        .. versionadded:: 0.6\n\n        .. versionchanged:: 0.9\n           This can now also be called without a request object when the\n           URL adapter is created for the application context.\n\n        .. versionchanged:: 1.0\n            :data:`SERVER_NAME` no longer implicitly enables subdomain\n            matching. Use :attr:`subdomain_matching` instead.\n        \"\"\"",
                    "first_doc": "\"\"\"\nCreates and returns a URL adapter for the provided request or for the application context.\n\nA URL adapter is responsible for URL matching and generation based on the application's configuration. When a request is provided, the adapter binds to its environment; otherwise, it binds using application-level settings. Behavior may vary based on subdomain matching and server configuration.\n\nArgs:\n    self: The instance of the class containing this method.\n    request: An optional request object whose environment is used to bind the URL adapter if provided.\n\nReturns:\n    A URL adapter object configured for either the provided request or the overall application context, depending on the presence of the request.\n\"\"\"",
                    "method_name": "create_url_adapter",
                    "second_doc": "\"\"\"\nCreates and returns a URL adapter configured for the given request or application-level context.\n\nThis method determines the appropriate parameters and environment context for URL matching and generation, ensuring that URLs are correctly interpreted and constructed based on incoming HTTP requests or the application's configuration. This is essential for resolving request paths to handlers and generating correct URLs for responses, supporting reliable routing and URL building throughout the application's lifecycle.\n\nArgs:\n    self: The Flask application instance.\n    request: An optional request object. If provided, the URL adapter binds to the request's environment; otherwise, it binds using the application's configuration.\n\nReturns:\n    A URL adapter object bound to either the request-specific environment or the application's default settings, which is used for matching incoming URLs to endpoints and for generating URLs within the application.\n\"\"\"",
                    "source_code": "if request is not None:\n            # If subdomain matching is disabled (the default), use the\n            # default subdomain in all cases. This should be the default\n            # in Werkzeug but it currently does not have that feature.\n            if not self.subdomain_matching:\n                subdomain = self.url_map.default_subdomain or None\n            else:\n                subdomain = None\n\n            return self.url_map.bind_to_environ(\n                request.environ,\n                server_name=self.config[\"SERVER_NAME\"],\n                subdomain=subdomain,\n            )\n        # We need at the very least the server name to be set for this\n        # to work.\n        if self.config[\"SERVER_NAME\"] is not None:\n            return self.url_map.bind(\n                self.config[\"SERVER_NAME\"],\n                script_name=self.config[\"APPLICATION_ROOT\"],\n                url_scheme=self.config[\"PREFERRED_URL_SCHEME\"],\n            )"
                },
                {
                    "docstring": "\"\"\"Injects the URL defaults for the given endpoint directly into\n        the values dictionary passed.  This is used internally and\n        automatically called on URL building.\n\n        .. versionadded:: 0.7\n        \"\"\"",
                    "first_doc": "\"\"\"\nInjects default URL values for a given endpoint into the provided dictionary.\n\nThis method is called internally during URL construction to ensure that any default values associated with the specified endpoint are inserted into the values dictionary. It processes default functions registered for the global scope or for the blueprint associated with the endpoint, calling each to possibly modify the values in place.\n\nArgs:\n    endpoint: The name of the endpoint for which URL defaults should be injected.\n    values: A dictionary representing URL values to which defaults may be applied or added.\n\nReturns:\n    None: This method modifies the values dictionary in place and does not return anything.\n\"\"\"",
                    "method_name": "inject_url_defaults",
                    "second_doc": "\"\"\"\nUpdates the provided URL values dictionary with default parameters defined for a given endpoint.\n\nBy applying registered default value functions based on the endpoint and any associated blueprint, this method ensures that all necessary routing defaults are present before constructing a URL. This facilitates consistent and reliable URL generation, even when some parameters are not provided explicitly.\n\nArgs:\n    endpoint (str): The name of the endpoint whose defaults should be applied.\n    values (dict): The dictionary of URL parameter values to update with defaults as needed.\n\nReturns:\n    None: This method modifies the values dictionary in place.\n\"\"\"",
                    "source_code": "funcs = self.url_default_functions.get(None, ())\n        if \".\" in endpoint:\n            bp = endpoint.rsplit(\".\", 1)[0]\n            funcs = chain(funcs, self.url_default_functions.get(bp, ()))\n        for func in funcs:\n            func(endpoint, values)"
                },
                {
                    "docstring": "\"\"\"Handle :class:`~werkzeug.routing.BuildError` on\n        :meth:`url_for`.\n        \"\"\"",
                    "first_doc": "\"\"\"\nHandles a BuildError raised during URL building with url_for by invoking registered error handlers.\n\nArgs:\n    error: The original BuildError exception encountered during URL creation.\n    endpoint: The endpoint for which the URL was being generated.\n    values: The values provided for the URL variables.\n\nReturns:\n    The result of a custom error handler if one successfully handles the error and returns a value; otherwise, re-raises the BuildError exception.\n\"\"\"",
                    "method_name": "handle_url_build_error",
                    "second_doc": "\"\"\"\nAttempts to resolve URL building errors by delegating to registered handlers, allowing for customized recovery or messaging when URL creation fails.\n\nArgs:\n    error (BuildError): The exception triggered during URL generation.\n    endpoint (str): The targeted endpoint for the URL being constructed.\n    values (dict): Parameters supplied for variable parts of the URL.\n\nReturns:\n    Any: The return value from a handler that successfully addresses the error, or re-raises the original BuildError if unhandled.\n\nWhy:\n    This mechanism enables the application to gracefully handle routing or parameter mismatches during URL generation, supporting more robust and user-friendly error handling.\n\"\"\"",
                    "source_code": "for handler in self.url_build_error_handlers:\n            try:\n                rv = handler(error, endpoint, values)\n            except BuildError as e:\n                # make error available outside except block\n                error = e\n            else:\n                if rv is not None:\n                    return rv\n\n        # Re-raise if called with an active exception, otherwise raise\n        # the passed in exception.\n        if error is sys.exc_info()[1]:\n            raise\n\n        raise error"
                },
                {
                    "docstring": "\"\"\"Called before the request is dispatched. Calls\n        :attr:`url_value_preprocessors` registered with the app and the\n        current blueprint (if any). Then calls :attr:`before_request_funcs`\n        registered with the app and the blueprint.\n\n        If any :meth:`before_request` handler returns a non-None value, the\n        value is handled as if it was the return value from the view, and\n        further request handling is stopped.\n        \"\"\"",
                    "first_doc": "\"\"\"\nExecutes all registered URL value preprocessors and before-request functions for the current request.\n\nThis method is called before a request is dispatched. It first invokes any functions registered as URL value preprocessors for the application and the current blueprint (if one is active). Next, it invokes any before-request functions registered at both the application and blueprint levels. If any before-request function returns a non-None value, no further request processing occurs, and the returned value is treated as the response.\n\nArgs:\n    self: The instance of the application.\n\nReturns:\n    The first non-None value returned by a before-request handler, which will be treated as the response for this request. If all handlers return None, returns None.\n\"\"\"",
                    "method_name": "preprocess_request",
                    "second_doc": "\"\"\"\nRuns all registered URL value preprocessors and before-request functions for the current request context to set up the request and allow early intervention if needed.\n\nThis method ensures that any preprocessing of URL parameters and request-level setup or validation is performed before the request is handled. This allows the application to establish necessary conditions, modify request data, or short-circuit the request with a custom response before passing control to the main handler.\n\nArgs:\n    self: The Flask application instance handling the incoming request.\n\nReturns:\n    The response value returned by the first before-request handler that does not return None, which will be used as the final response for the current request. Returns None if all handlers return None, indicating that request processing should continue as normal.\n\"\"\"",
                    "source_code": "bp = _request_ctx_stack.top.request.blueprint\n\n        funcs = self.url_value_preprocessors.get(None, ())\n        if bp is not None and bp in self.url_value_preprocessors:\n            funcs = chain(funcs, self.url_value_preprocessors[bp])\n        for func in funcs:\n            func(request.endpoint, request.view_args)\n\n        funcs = self.before_request_funcs.get(None, ())\n        if bp is not None and bp in self.before_request_funcs:\n            funcs = chain(funcs, self.before_request_funcs[bp])\n        for func in funcs:\n            rv = func()\n            if rv is not None:\n                return rv"
                },
                {
                    "docstring": "\"\"\"Can be overridden in order to modify the response object\n        before it's sent to the WSGI server.  By default this will\n        call all the :meth:`after_request` decorated functions.\n\n        .. versionchanged:: 0.5\n           As of Flask 0.5 the functions registered for after request\n           execution are called in reverse order of registration.\n\n        :param response: a :attr:`response_class` object.\n        :return: a new response object or the same, has to be an\n                 instance of :attr:`response_class`.\n        \"\"\"",
                    "first_doc": "\"\"\"\nProcesses the response object before it is sent to the WSGI server.\n\nThis method can be overridden to modify the response object before returning it to the client. By default, it calls all functions decorated with `after_request`, in the reverse order of their registration. Additionally, it manages session saving unless a null session is detected.\n\nArgs:\n    self: The instance of the class.\n    response: The response object to be processed before sending to the client.\n\nReturns:\n    The processed response object, typically an instance of the class's `response_class`. This may be a new or modified response, or the original response.\n\"\"\"",
                    "method_name": "process_response",
                    "second_doc": "\"\"\"\nApplies post-processing functions to the HTTP response object before it is sent to the client.\n\nThis method ensures any registered post-request handlers are executed and that session data is properly managed and saved with the response. This allows for consistent execution of application hooks\u2014such as modifying headers, cookies, or logging\u2014and guarantees session integrity at the end of each request.\n\nArgs:\n    self: The Flask application instance.\n    response: The response object generated by the application, to be potentially modified before sending to the client.\n\nReturns:\n    The finalized response object after all post-processing handlers have been invoked and session data has been persisted. This is typically an instance of the application's `response_class`.\n\"\"\"",
                    "source_code": "ctx = _request_ctx_stack.top\n        bp = ctx.request.blueprint\n        funcs = ctx._after_request_functions\n        if bp is not None and bp in self.after_request_funcs:\n            funcs = chain(funcs, reversed(self.after_request_funcs[bp]))\n        if None in self.after_request_funcs:\n            funcs = chain(funcs, reversed(self.after_request_funcs[None]))\n        for handler in funcs:\n            response = handler(response)\n        if not self.session_interface.is_null_session(ctx.session):\n            self.session_interface.save_session(self, ctx.session, response)\n        return response"
                },
                {
                    "docstring": "\"\"\"Called after the request is dispatched and the response is\n        returned, right before the request context is popped.\n\n        This calls all functions decorated with\n        :meth:`teardown_request`, and :meth:`Blueprint.teardown_request`\n        if a blueprint handled the request. Finally, the\n        :data:`request_tearing_down` signal is sent.\n\n        This is called by\n        :meth:`RequestContext.pop() <flask.ctx.RequestContext.pop>`,\n        which may be delayed during testing to maintain access to\n        resources.\n\n        :param exc: An unhandled exception raised while dispatching the\n            request. Detected from the current exception information if\n            not passed. Passed to each teardown function.\n\n        .. versionchanged:: 0.9\n            Added the ``exc`` argument.\n        \"\"\"",
                    "first_doc": "\"\"\"\nPerforms teardown operations after a request has been dispatched and a response has been returned, just before the request context is removed.\n\nThis method calls all registered teardown functions for the request, including both app-wide and blueprint-specific handlers. It then emits the request_tearing_down signal. Typically, this is triggered by the RequestContext.pop() method, although this call can be delayed during testing to allow continued access to resources.\n\nArgs:\n    exc: An unhandled exception raised during request dispatch, or None if no such exception occurred. If not provided, the current exception information will be used. This exception is passed to each teardown function.\n\nReturns:\n    None. This method is used for side effects, specifically calling teardown handlers and sending the request_tearing_down signal.\n\nClass Fields Initialized:\n    None. This method does not initialize any object properties.\n\"\"\"",
                    "method_name": "do_teardown_request",
                    "second_doc": "\"\"\"\nHandles cleanup tasks after a request cycle has finished, ensuring that any resources tied to the request are properly released and that teardown handlers are called in a predictable manner.\n\nThis method invokes all registered teardown functions for the current request, both globally and for the relevant blueprint, and emits a signal indicating the request is ending. This process ensures that resources such as database connections, temporary files, or other context-dependent objects are appropriately finalized, reducing the risk of resource leaks or inconsistent application state.\n\nArgs:\n    exc: An unhandled exception raised during request processing, or None if no exception occurred. If not provided, the current exception will be used. This value is passed to each teardown function to allow customized cleanup based on error state.\n\nReturns:\n    None. This method performs side effects by calling teardown handlers and emitting the request_tearing_down signal.\n\"\"\"",
                    "source_code": "if exc is _sentinel:\n            exc = sys.exc_info()[1]\n        funcs = reversed(self.teardown_request_funcs.get(None, ()))\n        bp = _request_ctx_stack.top.request.blueprint\n        if bp is not None and bp in self.teardown_request_funcs:\n            funcs = chain(funcs, reversed(self.teardown_request_funcs[bp]))\n        for func in funcs:\n            func(exc)\n        request_tearing_down.send(self, exc=exc)"
                },
                {
                    "docstring": "\"\"\"Called right before the application context is popped.\n\n        When handling a request, the application context is popped\n        after the request context. See :meth:`do_teardown_request`.\n\n        This calls all functions decorated with\n        :meth:`teardown_appcontext`. Then the\n        :data:`appcontext_tearing_down` signal is sent.\n\n        This is called by\n        :meth:`AppContext.pop() <flask.ctx.AppContext.pop>`.\n\n        .. versionadded:: 0.9\n        \"\"\"",
                    "first_doc": "\"\"\"\nPerforms teardown tasks right before the application context is removed.\n\nThis method is called before the application context is popped, typically at the end of a request. It invokes all functions registered with the teardown_appcontext mechanism, passing any exception that occurred, and emits the appcontext_tearing_down signal to notify interested parties.\n\nArgs:\n    self: The instance of the object invoking this method.\n\nReturns:\n    None: This method does not return a value; it performs teardown side effects such as calling registered handlers and sending signals.\n\"\"\"",
                    "method_name": "do_teardown_appcontext",
                    "second_doc": "\"\"\"\nCleans up and finalizes resources associated with the application context before it is discarded.\n\nThis method ensures that any functions registered to run when the application context is about to be removed are executed, allowing proper resource management, clean closure of resources, and consistent notification to components interested in the teardown process. By passing along any active exception to these handlers, the application can react appropriately to errors or cleanup requirements as the context ends.\n\nArgs:\n    self: The Flask application instance invoking this method.\n    exc: The exception that occurred during request handling, or None if no exception occurred.\n\nReturns:\n    None: This method returns nothing; it triggers teardown callbacks and signals as part of the application's lifecycle management.\n\"\"\"",
                    "source_code": "if exc is _sentinel:\n            exc = sys.exc_info()[1]\n        for func in reversed(self.teardown_appcontext_funcs):\n            func(exc)\n        appcontext_tearing_down.send(self, exc=exc)"
                },
                {
                    "docstring": "\"\"\"Create an :class:`~flask.ctx.AppContext`. Use as a ``with``\n        block to push the context, which will make :data:`current_app`\n        point at this application.\n\n        An application context is automatically pushed by\n        :meth:`RequestContext.push() <flask.ctx.RequestContext.push>`\n        when handling a request, and when running a CLI command. Use\n        this to manually create a context outside of these situations.\n\n        ::\n\n            with app.app_context():\n                init_db()\n\n        See :doc:`/appcontext`.\n\n        .. versionadded:: 0.9\n        \"\"\"",
                    "first_doc": "\"\"\"\nCreates an application context for the current Flask application.\n\nThis method can be used as a context manager (with a ``with`` block) to push the application context, which sets the :data:`current_app` proxy to point to this application. While request and CLI command contexts are automatically handled by Flask, this method allows manual context creation when needed (e.g., for running commands or tasks outside normal request handling).\n\nArgs:\n    self: The Flask application instance for which the context is to be created.\n\nReturns:\n    AppContext: An application context object associated with this Flask application, which can be used as a context manager.\n\"\"\"",
                    "method_name": "app_context",
                    "second_doc": "\"\"\"\nEstablishes and returns a context manager that activates the application's context stack.\n\nBy manually creating an application context, this method ensures that context-dependent features\u2014such as configuration, application-level variables, or extensions\u2014are accessible, even outside standard request or CLI command flows. This supports scenarios like background tasks, interactive shells, or scripts that rely on application state when there is no active request.\n\nArgs:\n    self: The Flask application instance for which to create the context manager.\n\nReturns:\n    AppContext: A context manager that, when entered, pushes the application context, making application-specific data and resources available for use within its scope.\n\"\"\"",
                    "source_code": "return AppContext(self)"
                },
                {
                    "docstring": "\"\"\"Create a :class:`~flask.ctx.RequestContext` representing a\n        WSGI environment. Use a ``with`` block to push the context,\n        which will make :data:`request` point at this request.\n\n        See :doc:`/reqcontext`.\n\n        Typically you should not call this from your own code. A request\n        context is automatically pushed by the :meth:`wsgi_app` when\n        handling a request. Use :meth:`test_request_context` to create\n        an environment and context instead of this method.\n\n        :param environ: a WSGI environment\n        \"\"\"",
                    "first_doc": "\"\"\"\nCreates a RequestContext object representing a WSGI environment for handling a request.\n\nThis method generates a request context that can be used to temporarily make the request object point to the current request within a with block. Generally, you do not need to call this directly\u2014contexts are managed automatically when handling requests, or you can use test_request_context to create one for testing.\n\nArgs:\n    self: The Flask application instance to associate with the request context.\n    environ: The WSGI environment dict representing the current request environment.\n\nReturns:\n    RequestContext: A RequestContext object configured for the provided WSGI environment and Flask application.\n\"\"\"",
                    "method_name": "request_context",
                    "second_doc": "\"\"\"\nCreates and returns a RequestContext object for the given WSGI environment, allowing the application to process the current request within a specific context.\n\nThis method constructs a context that enables tracking and managing application and request-specific data during the handling of a web request. By isolating request state, it helps ensure correct behavior when serving multiple requests concurrently.\n\nArgs:\n    self: The Flask application instance to associate with the new request context.\n    environ: A dictionary containing the WSGI environment for the current web request.\n\nReturns:\n    RequestContext: An object that manages the lifetime and scope of the request-specific state for the application.\n\"\"\"",
                    "source_code": "return RequestContext(self, environ)"
                },
                {
                    "docstring": "\"\"\"Create a :class:`~flask.ctx.RequestContext` for a WSGI\n        environment created from the given values. This is mostly useful\n        during testing, where you may want to run a function that uses\n        request data without dispatching a full request.\n\n        See :doc:`/reqcontext`.\n\n        Use a ``with`` block to push the context, which will make\n        :data:`request` point at the request for the created\n        environment. ::\n\n            with test_request_context(...):\n                generate_report()\n\n        When using the shell, it may be easier to push and pop the\n        context manually to avoid indentation. ::\n\n            ctx = app.test_request_context(...)\n            ctx.push()\n            ...\n            ctx.pop()\n\n        Takes the same arguments as Werkzeug's\n        :class:`~werkzeug.test.EnvironBuilder`, with some defaults from\n        the application. See the linked Werkzeug docs for most of the\n        available arguments. Flask-specific behavior is listed here.\n\n        :param path: URL path being requested.\n        :param base_url: Base URL where the app is being served, which\n            ``path`` is relative to. If not given, built from\n            :data:`PREFERRED_URL_SCHEME`, ``subdomain``,\n            :data:`SERVER_NAME`, and :data:`APPLICATION_ROOT`.\n        :param subdomain: Subdomain name to append to\n            :data:`SERVER_NAME`.\n        :param url_scheme: Scheme to use instead of\n            :data:`PREFERRED_URL_SCHEME`.\n        :param data: The request body, either as a string or a dict of\n            form keys and values.\n        :param json: If given, this is serialized as JSON and passed as\n            ``data``. Also defaults ``content_type`` to\n            ``application/json``.\n        :param args: other positional arguments passed to\n            :class:`~werkzeug.test.EnvironBuilder`.\n        :param kwargs: other keyword arguments passed to\n            :class:`~werkzeug.test.EnvironBuilder`.\n        \"\"\"",
                    "first_doc": "\"\"\"\nCreates a Flask RequestContext for a WSGI environment derived from the provided parameters.\n\nThis method is primarily used for testing purposes, enabling the creation and manipulation of request contexts without dispatching an actual HTTP request. It allows you to run functions that require the request context, such as accessing `request`, in isolation within a test. The method accepts the same parameters as Werkzeug's EnvironBuilder, with some defaults and additional behaviors specific to Flask.\n\nArgs:\n    self: The Flask application instance.\n\nReturns:\n    A RequestContext object initialized with the constructed WSGI environment, which can be used as a context manager or pushed/popped manually to manage the active request context.\n\"\"\"",
                    "method_name": "test_request_context",
                    "second_doc": "\"\"\"\nEstablishes a temporary Flask request context using a dynamically constructed WSGI environment, allowing code that depends on request-specific data to be executed outside of an actual HTTP request cycle. This facilitates isolated testing of components that require request context by simulating the necessary environment internally.\n\nArgs:\n    self: The Flask application instance.\n    *args: Positional arguments forwarded to the EnvironBuilder, defining properties of the simulated request (e.g., method, path, headers).\n    **kwargs: Keyword arguments forwarded to the EnvironBuilder to further customize the mock request environment.\n\nReturns:\n    RequestContext: An instance representing the simulated request context, suitable for use as a context manager or manual activation/deactivation.\n\"\"\"",
                    "source_code": "from .testing import EnvironBuilder\n\n        builder = EnvironBuilder(self, *args, **kwargs)\n\n        try:\n            return self.request_context(builder.get_environ())\n        finally:\n            builder.close()"
                },
                {
                    "docstring": "\"\"\"The actual WSGI application. This is not implemented in\n        :meth:`__call__` so that middlewares can be applied without\n        losing a reference to the app object. Instead of doing this::\n\n            app = MyMiddleware(app)\n\n        It's a better idea to do this instead::\n\n            app.wsgi_app = MyMiddleware(app.wsgi_app)\n\n        Then you still have the original application object around and\n        can continue to call methods on it.\n\n        .. versionchanged:: 0.7\n            Teardown events for the request and app contexts are called\n            even if an unhandled error occurs. Other events may not be\n            called depending on when an error occurs during dispatch.\n            See :ref:`callbacks-and-errors`.\n\n        :param environ: A WSGI environment.\n        :param start_response: A callable accepting a status code,\n            a list of headers, and an optional exception context to\n            start the response.\n        \"\"\"",
                    "first_doc": "\"\"\"\nThe actual WSGI application entry point for handling HTTP requests.\n\nThis method serves as the main WSGI application callable. It manages the request context, dispatches the request to the appropriate handler, invokes error handling if needed, and ensures proper teardown of contexts. This allows for middleware to be applied directly to this method while preserving the original application object.\n\nArgs:\n    environ: The WSGI environment dictionary containing request information.\n    start_response: A callable provided by the WSGI server to start the HTTP response.\n\nReturns:\n    A WSGI-compatible response iterable to be sent back to the client.\n\"\"\"",
                    "method_name": "wsgi_app",
                    "second_doc": "\"\"\"\nProcesses an incoming HTTP request using the WSGI protocol, establishing a request context, dispatching to the appropriate route or error handler if needed, and cleaning up after the request is handled. This ensures the application reliably responds to web requests, maintains correct context management, and integrates effectively with WSGI middleware.\n\nArgs:\n    environ: A dictionary containing WSGI environment variables with request data.\n    start_response: A WSGI server-provided callable to initiate the HTTP response.\n\nReturns:\n    An iterable yielding the response body to be sent to the client, conforming to the WSGI specification.\n\"\"\"",
                    "source_code": "ctx = self.request_context(environ)\n        error = None\n        try:\n            try:\n                ctx.push()\n                response = self.full_dispatch_request()\n            except Exception as e:\n                error = e\n                response = self.handle_exception(e)\n            except:  # noqa: B001\n                error = sys.exc_info()[1]\n                raise\n            return response(environ, start_response)\n        finally:\n            if self.should_ignore_error(error):\n                error = None\n            ctx.auto_pop(error)"
                },
                {
                    "docstring": "\"\"\"The WSGI server calls the Flask application object as the\n        WSGI application. This calls :meth:`wsgi_app` which can be\n        wrapped to applying middleware.\"\"\"",
                    "first_doc": "\"\"\"\nEnables the Flask application instance to be called as a WSGI application.\n\nThis method allows a WSGI server to use the Flask app instance directly as a callable. It delegates handling of the WSGI request to the wsgi_app method, which can be wrapped to apply middleware.\n\nArgs:\n    environ: A dictionary containing CGI-style environment variables for the request.\n    start_response: A callable provided by the WSGI server to start the HTTP response.\n\nReturns:\n    The response iterable generated by the application for the given environment and start_response.\n\"\"\"",
                    "method_name": "__call__",
                    "second_doc": "\"\"\"\nAllows the Flask application instance to process incoming HTTP requests when used with a WSGI server.\n\nBy forwarding the request environment and response starter to the internal wsgi_app method, this enables the application to integrate seamlessly with WSGI-compatible servers and middleware, ensuring requests are handled according to defined application logic.\n\nArgs:\n    environ (dict): A dictionary of CGI-style environment variables representing the request context.\n    start_response (callable): A function provided by the WSGI server to initiate the HTTP response.\n\nReturns:\n    iterable: The response generated by the application for the received request.\n\"\"\"",
                    "source_code": "return self.wsgi_app(environ, start_response)"
                },
                {
                    "docstring": null,
                    "method_name": "__repr__",
                    "second_doc": "\"\"\"\nReturn a string representation of the Flask application instance, showing its class name and the application's name.\n\nThis aids in debugging and logging by providing a clear, human-readable identifier for the application instance.\n\nReturns:\n    str: A formatted string with the class name and the application's name.\n\"\"\"",
                    "source_code": "return f\"<{type(self).__name__} {self.name!r}>\""
                }
            ],
            "name": "Flask",
            "type": "class"
        }
    ],
    "flask/src/flask/blueprints.py": [
        {
            "methods": [
                {
                    "docstring": null,
                    "method_name": "__init__",
                    "second_doc": "\"\"\"\nInitializes the setup state for registering a blueprint with a Flask application, storing references and relevant configuration options needed to apply the blueprint's settings such as subdomain, URL prefix, and URL defaults.\n\nArgs:\n    app: The Flask application instance with which the blueprint is being registered.\n    blueprint: The blueprint instance being registered.\n    options: A dictionary of options provided during the blueprint registration, such as 'subdomain', 'url_prefix', and 'url_defaults'.\n    first_registration: A boolean indicating if this is the first time the blueprint is being registered on the application.\n\nReturns:\n    None. This constructor sets up instance attributes to manage blueprint registration and configuration.\n\"\"\"",
                    "source_code": "self.app = app\n\n        #: a reference to the blueprint that created this setup state.\n        self.blueprint = blueprint\n\n        #: a dictionary with all options that were passed to the\n        #: :meth:`~flask.Flask.register_blueprint` method.\n        self.options = options\n\n        #: as blueprints can be registered multiple times with the\n        #: application and not everything wants to be registered\n        #: multiple times on it, this attribute can be used to figure\n        #: out if the blueprint was registered in the past already.\n        self.first_registration = first_registration\n\n        subdomain = self.options.get(\"subdomain\")\n        if subdomain is None:\n            subdomain = self.blueprint.subdomain\n\n        #: The subdomain that the blueprint should be active for, ``None``\n        #: otherwise.\n        self.subdomain = subdomain\n\n        url_prefix = self.options.get(\"url_prefix\")\n        if url_prefix is None:\n            url_prefix = self.blueprint.url_prefix\n        #: The prefix that should be used for all URLs defined on the\n        #: blueprint.\n        self.url_prefix = url_prefix\n\n        #: A dictionary with URL defaults that is added to each and every\n        #: URL that was defined with the blueprint.\n        self.url_defaults = dict(self.blueprint.url_values_defaults)\n        self.url_defaults.update(self.options.get(\"url_defaults\", ()))"
                },
                {
                    "docstring": "\"\"\"A helper method to register a rule (and optionally a view function)\n        to the application.  The endpoint is automatically prefixed with the\n        blueprint's name.\n        \"\"\"",
                    "first_doc": "\"\"\"\nRegisters a URL rule (and optionally a view function) to the application, with the endpoint name automatically prefixed by the blueprint's name.\n\nArgs:\n    self: The blueprint instance to which the rule is being added.\n    rule: The URL pattern to associate with the view function.\n\nReturns:\n    None. This method modifies the application by adding the new URL rule.\n\"\"\"",
                    "method_name": "add_url_rule",
                    "second_doc": "\"\"\"\nAssociates a URL pattern with a view function within a modular application component, ensuring correct URL and endpoint naming conventions are applied automatically. This facilitates organized routing and namespace management for scalable and maintainable web applications.\n\nArgs:\n    self: The BlueprintSetupState instance managing blueprint registration.\n    rule (str): The URL pattern to register.\n    endpoint (str, optional): The endpoint name for the URL rule. If not provided, it is derived from the view function.\n    view_func (callable, optional): The function to handle requests to this URL rule.\n    options (dict): Additional options for the URL rule, such as HTTP methods and custom defaults.\n\nReturns:\n    None: The method modifies the application instance by adding the specified URL rule.\n\"\"\"",
                    "source_code": "if self.url_prefix is not None:\n            if rule:\n                rule = \"/\".join((self.url_prefix.rstrip(\"/\"), rule.lstrip(\"/\")))\n            else:\n                rule = self.url_prefix\n        options.setdefault(\"subdomain\", self.subdomain)\n        if endpoint is None:\n            endpoint = _endpoint_from_view_func(view_func)\n        defaults = self.url_defaults\n        if \"defaults\" in options:\n            defaults = dict(defaults, **options.pop(\"defaults\"))\n        self.app.add_url_rule(\n            rule,\n            f\"{self.blueprint.name}.{endpoint}\",\n            view_func,\n            defaults=defaults,\n            **options,\n        )"
                }
            ],
            "name": "BlueprintSetupState",
            "type": "class"
        },
        {
            "methods": [
                {
                    "docstring": null,
                    "method_name": "__init__",
                    "second_doc": "\"\"\"\nInitializes a new blueprint instance, configuring its identity, routes, and optional resource folders for integration into an application. This allows the application to organize related routes, static files, templates, and command-line commands in a modular fashion.\n\nArgs:\n    name (str): The name of the blueprint.\n    import_name (str): The name of the application package or module this blueprint is part of.\n    static_folder (Optional[str]): Path to the blueprint\u2019s static files.\n    static_url_path (Optional[str]): URL path for serving static files.\n    template_folder (Optional[str]): Path to the blueprint\u2019s template files.\n    url_prefix (Optional[str]): Prefix to add to all blueprint routes.\n    subdomain (Optional[str]): Subdomain to use for the blueprint's routes.\n    url_defaults (Optional[dict]): Default values for the blueprint\u2019s routes.\n    root_path (Optional[str]): Filesystem path to the blueprint\u2019s root.\n    cli_group (Optional[str]): Name for the CLI command group.\n\nReturns:\n    None\n\"\"\"",
                    "source_code": "_PackageBoundObject.__init__(\n            self, import_name, template_folder, root_path=root_path\n        )\n        self.name = name\n        self.url_prefix = url_prefix\n        self.subdomain = subdomain\n        self.static_folder = static_folder\n        self.static_url_path = static_url_path\n        self.deferred_functions = []\n        if url_defaults is None:\n            url_defaults = {}\n        self.url_values_defaults = url_defaults\n        self.cli_group = cli_group"
                },
                {
                    "docstring": "\"\"\"Registers a function that is called when the blueprint is\n        registered on the application.  This function is called with the\n        state as argument as returned by the :meth:`make_setup_state`\n        method.\n        \"\"\"",
                    "first_doc": "\"\"\"\nRegisters a function to be called when the blueprint is registered on the application.\n\nThis method allows you to specify a function that will be executed with the blueprint's state as its argument when the blueprint is registered via the application. If the blueprint has already been registered and modifications are being made, a warning is issued indicating that these modifications may not take effect.\n\nArgs:\n    func: The function to be called when the blueprint is registered. This function will receive the blueprint setup state as its only argument.\n\nReturns:\n    None: This method does not return a value.\n\"\"\"",
                    "method_name": "record",
                    "second_doc": "\"\"\"\nSchedules a function to be executed when the blueprint is registered onto an application, ensuring any setup or configuration tied to registration is deferred until the appropriate context is available. A warning is issued if registration has already occurred and changes may not be applied, helping maintain application consistency.\n\nArgs:\n    func (callable): The function to be executed upon blueprint registration. It receives the blueprint setup state as its only argument.\n\nReturns:\n    None: This method does not return a value.\n\"\"\"",
                    "source_code": "if self._got_registered_once and self.warn_on_modifications:\n            from warnings import warn\n\n            warn(\n                Warning(\n                    \"The blueprint was already registered once \"\n                    \"but is getting modified now.  These changes \"\n                    \"will not show up.\"\n                )\n            )\n        self.deferred_functions.append(func)"
                },
                {
                    "docstring": "\"\"\"Works like :meth:`record` but wraps the function in another\n        function that will ensure the function is only called once.  If the\n        blueprint is registered a second time on the application, the\n        function passed is not called.\n        \"\"\"",
                    "first_doc": "\"\"\"\nRegisters a function to be called only once when the blueprint is registered with the application.\n\nThe wrapped function will execute during the first registration and will not be called again for subsequent registrations of the blueprint.\n\nArgs:\n    func: The function to be wrapped and registered to execute on blueprint registration.\n\nReturns:\n    A callable that registers the one-time execution function with the blueprint.\n\"\"\"",
                    "method_name": "record_once",
                    "second_doc": "\"\"\"\nEnsures that a given function is executed only once during the initial registration phase of a blueprint with an application. This helps maintain consistent setup or configuration steps that should not be repeated during subsequent blueprint registrations.\n\nArgs:\n    func: A callable that takes a single argument (the state) and performs setup tasks upon blueprint registration.\n\nReturns:\n    A callable that, when provided to the blueprint, guarantees the one-time execution of the specified function during the first registration event.\n\"\"\"",
                    "source_code": "def wrapper(state):\n            if state.first_registration:\n                func(state)\n\n        return self.record(update_wrapper(wrapper, func))"
                },
                {
                    "docstring": "\"\"\"Creates an instance of :meth:`~flask.blueprints.BlueprintSetupState`\n        object that is later passed to the register callback functions.\n        Subclasses can override this to return a subclass of the setup state.\n        \"\"\"",
                    "first_doc": "\"\"\"\nCreates and returns a BlueprintSetupState instance for registering blueprint callbacks.\n\nThis method creates an instance of BlueprintSetupState that will be passed to blueprint register callback functions. Subclasses may override this method to return a custom setup state subclass if needed.\n\nArgs:\n    self: The blueprint instance for which the setup state is being created.\n    app: The Flask application object the blueprint is being registered with.\n    options: A dictionary of options passed to the blueprint during registration.\n\nReturns:\n    BlueprintSetupState: The setup state object that will be provided to register callback functions.\n\"\"\"",
                    "method_name": "make_setup_state",
                    "second_doc": "\"\"\"\nPrepares and returns the setup state required for blueprint registration within an application.\n\nThis method instantiates a BlueprintSetupState object, encapsulating all necessary information for configuring and finalizing a blueprint as it is registered with an application. This ensures that the blueprint has the correct context and options for initialization and integration with the application's components.\n\nArgs:\n    self: The blueprint instance for which the setup state is being created.\n    app: The Flask application object with which the blueprint is being registered.\n    options: A dictionary containing options passed during registration.\n    first_registration: A boolean indicating if this is the blueprint's first registration with the application.\n\nReturns:\n    BlueprintSetupState: An object representing the context and configuration for registering the blueprint, used by registration callbacks.\n\"\"\"",
                    "source_code": "return BlueprintSetupState(self, app, options, first_registration)"
                },
                {
                    "docstring": "\"\"\"Called by :meth:`Flask.register_blueprint` to register all views\n        and callbacks registered on the blueprint with the application. Creates\n        a :class:`.BlueprintSetupState` and calls each :meth:`record` callback\n        with it.\n\n        :param app: The application this blueprint is being registered with.\n        :param options: Keyword arguments forwarded from\n            :meth:`~Flask.register_blueprint`.\n        :param first_registration: Whether this is the first time this\n            blueprint has been registered on the application.\n        \"\"\"",
                    "first_doc": "\"\"\"\nRegisters all views and callbacks associated with the blueprint to the given application. This method creates a BlueprintSetupState and applies any recorded functions, sets up static file serving if configured, and manages CLI command registration based on provided options.\n\nArgs:\n    self: The blueprint instance being registered.\n    app: The application instance with which the blueprint is being registered.\n    options: Dictionary of keyword arguments forwarded from Flask.register_blueprint.\n\nClass Fields Initialized:\n    _got_registered_once: Boolean flag set to True indicating that the blueprint has been registered at least once.\n\nReturns:\n    None: This method does not return a value; it performs side effects on the blueprint and application.\n\"\"\"",
                    "method_name": "register",
                    "second_doc": "\"\"\"\nIntegrates all the views, callbacks, static file routes, and CLI commands associated with the blueprint into the given application context. This allows modular application components to be seamlessly attached and initialized, ensuring their routes, assets, and auxiliary features become active as part of the registered app. The method ensures all deferred configurations and command-line utilities linked to the blueprint are properly set up according to their specified options.\n\nArgs:\n    self: The blueprint instance being registered.\n    app: The application instance with which the blueprint is being registered.\n    options: Dictionary of keyword arguments affecting blueprint registration, such as custom CLI group configuration.\n    first_registration: A flag indicating whether this is the blueprint's first registration to the application.\n\nReturns:\n    None: This method executes registration side effects on the blueprint and the application, without returning a value.\n\"\"\"",
                    "source_code": "self._got_registered_once = True\n        state = self.make_setup_state(app, options, first_registration)\n\n        if self.has_static_folder:\n            state.add_url_rule(\n                f\"{self.static_url_path}/<path:filename>\",\n                view_func=self.send_static_file,\n                endpoint=\"static\",\n            )\n\n        for deferred in self.deferred_functions:\n            deferred(state)\n\n        cli_resolved_group = options.get(\"cli_group\", self.cli_group)\n\n        if not self.cli.commands:\n            return\n\n        if cli_resolved_group is None:\n            app.cli.commands.update(self.cli.commands)\n        elif cli_resolved_group is _sentinel:\n            self.cli.name = self.name\n            app.cli.add_command(self.cli)\n        else:\n            self.cli.name = cli_resolved_group\n            app.cli.add_command(self.cli)"
                },
                {
                    "docstring": "\"\"\"Like :meth:`Flask.route` but for a blueprint.  The endpoint for the\n        :func:`url_for` function is prefixed with the name of the blueprint.\n        \"\"\"",
                    "first_doc": "\"\"\"\nRegisters a new route specific to the blueprint.\n\nThis method creates a decorator that can be used to associate a view function with a URL rule. The endpoint for the view will be automatically prefixed with the blueprint's name, distinguishing routes across different blueprints.\n\nArgs:\n    self: The blueprint instance to which the route will be added.\n    rule: The URL rule as string to associate with the view function.\n\nReturns:\n    function: A decorator that registers the view function for the specified route.\n\"\"\"",
                    "method_name": "route",
                    "second_doc": "\"\"\"\nAssociates a URL rule with a view function under the blueprint context through a decorator.\n\nThis method enables modular organization by allowing view functions to be registered with specific URL patterns, ensuring route uniqueness and encapsulation within the blueprint's namespace.\n\nArgs:\n    self: The blueprint instance to which the route will be added.\n    rule (str): The URL pattern to bind to the view function.\n\nReturns:\n    function: A decorator that registers the view function to the route, ensuring it is invoked when the URL rule is matched.\n\"\"\"",
                    "source_code": "def decorator(f):\n            endpoint = options.pop(\"endpoint\", f.__name__)\n            self.add_url_rule(rule, endpoint, f, **options)\n            return f\n\n        return decorator"
                },
                {
                    "docstring": "\"\"\"Like :meth:`Flask.add_url_rule` but for a blueprint.  The endpoint for\n        the :func:`url_for` function is prefixed with the name of the blueprint.\n        \"\"\"",
                    "first_doc": "\"\"\"\nAdds a URL rule to the blueprint, similar to Flask's `add_url_rule`.\n\nThis method registers a new rule with the blueprint that will be available when the blueprint is registered on the application. The endpoint for the `url_for` function is automatically prefixed with the blueprint's name.\n\nArgs:\n    self: The blueprint instance to which the URL rule is added.\n    rule: The URL rule as string to be associated with the blueprint.\n\nReturns:\n    None: This method does not return a value.\n\"\"\"",
                    "method_name": "add_url_rule",
                    "second_doc": "\"\"\"\nRegisters a new URL rule with the blueprint, ensuring that routes associated with the blueprint are tracked and correctly configured for integration into the overall application routing system. This helps maintain modular organization of different application components by encapsulating their routes and related behaviors.\n\nArgs:\n    self: The instance of the blueprint to add the URL rule to.\n    rule (str): The URL pattern to associate with the blueprint.\n    endpoint (str, optional): The endpoint name for the route. Defaults to None.\n    view_func (callable, optional): The view function to handle requests to the given rule. Defaults to None.\n    **options: Additional options passed to the underlying route registration logic.\n\nReturns:\n    None: This method does not return a value, but updates the blueprint's internal route registry for later application integration.\n\"\"\"",
                    "source_code": "if endpoint:\n            assert \".\" not in endpoint, \"Blueprint endpoints should not contain dots\"\n        if view_func and hasattr(view_func, \"__name__\"):\n            assert (\n                \".\" not in view_func.__name__\n            ), \"Blueprint view function name should not contain dots\"\n        self.record(lambda s: s.add_url_rule(rule, endpoint, view_func, **options))"
                },
                {
                    "docstring": "\"\"\"Like :meth:`Flask.endpoint` but for a blueprint.  This does not\n        prefix the endpoint with the blueprint name, this has to be done\n        explicitly by the user of this method.  If the endpoint is prefixed\n        with a `.` it will be registered to the current blueprint, otherwise\n        it's an application independent endpoint.\n        \"\"\"",
                    "first_doc": "\"\"\"\nRegisters a function as an endpoint for the blueprint without automatically prefixing the endpoint name with the blueprint name.\n\nArgs:\n    self: The blueprint instance on which the endpoint is being registered.\n    endpoint: The name of the endpoint. If prefixed with a '.', the endpoint is registered for the current blueprint; otherwise, it is registered as an application-independent endpoint.\n\nReturns:\n    function: A decorator that registers the given function as a view function for the specified endpoint.\n\"\"\"",
                    "method_name": "endpoint",
                    "second_doc": "\"\"\"\nAssociates a function with a specific endpoint within the blueprint, enabling modular registration of application views without enforcing global endpoint naming conventions.\n\nArgs:\n    self: The blueprint instance where the endpoint is being defined.\n    endpoint (str): Identifier for the route. If prefixed with '.', it applies specifically to this blueprint; otherwise, it becomes a global endpoint.\n\nReturns:\n    function: A decorator that, when applied to a function, registers it as a view handler for the specified endpoint within the blueprint.\n\"\"\"",
                    "source_code": "def decorator(f):\n            def register_endpoint(state):\n                state.app.view_functions[endpoint] = f\n\n            self.record_once(register_endpoint)\n            return f\n\n        return decorator"
                },
                {
                    "docstring": "\"\"\"Register a custom template filter, available application wide.  Like\n        :meth:`Flask.template_filter` but for a blueprint.\n\n        :param name: the optional name of the filter, otherwise the\n                     function name will be used.\n        \"\"\"",
                    "first_doc": "\"\"\"\nRegisters a custom template filter for use application-wide with the blueprint.\n\nThis method allows you to define a decorator that registers a function as a Jinja2 template filter, making it available throughout the application via the blueprint.\n\nArgs:\n    self: The blueprint instance for which the template filter is being registered.\n\nReturns:\n    function: A decorator function that registers the given callable as a template filter.\n\"\"\"",
                    "method_name": "app_template_filter",
                    "second_doc": "\"\"\"\nCreates a decorator to register a custom template filter within the blueprint, ensuring the filter is accessible in templates rendered application-wide. This streamlines the integration of reusable data formatting and transformation logic directly into the template rendering workflow.\n\nArgs:\n    self: The Blueprint instance where the filter will be registered.\n    name (optional): An explicit name for the filter; if not provided, the function\u2019s name is used.\n\nReturns:\n    function: A decorator that, when applied to a function, registers it as a template filter for use in the blueprint\u2019s context.\n\"\"\"",
                    "source_code": "def decorator(f):\n            self.add_app_template_filter(f, name=name)\n            return f\n\n        return decorator"
                },
                {
                    "docstring": "\"\"\"Register a custom template filter, available application wide.  Like\n        :meth:`Flask.add_template_filter` but for a blueprint.  Works exactly\n        like the :meth:`app_template_filter` decorator.\n\n        :param name: the optional name of the filter, otherwise the\n                     function name will be used.\n        \"\"\"",
                    "first_doc": "\"\"\"\nRegisters a custom template filter that is available application-wide for all templates rendered by the application. This method is similar to Flask's add_template_filter but is intended for use within a blueprint, functioning like the app_template_filter decorator.\n\nArgs:\n    f: The function that implements the custom template filter.\n\nReturns:\n    None. The method registers the filter for use with the application's Jinja environment.\n\nClass Fields Initialized:\n    None. This method does not initialize any class fields.\n\"\"\"",
                    "method_name": "add_app_template_filter",
                    "second_doc": "\"\"\"\nRegisters a custom template filter for use across all templates rendered by the application from this blueprint. By enabling filter registration at the blueprint level, this method helps maintain modular and reusable template logic, ensuring that template customization remains organized even as applications grow in complexity.\n\nArgs:\n    f: The function that defines the custom template filter.\n    name (optional): A string representing the name for the filter in templates. If not provided, the function's name is used.\n\nReturns:\n    None. The filter is registered within the application's Jinja environment for use in template rendering.\n\"\"\"",
                    "source_code": "def register_template(state):\n            state.app.jinja_env.filters[name or f.__name__] = f\n\n        self.record_once(register_template)"
                },
                {
                    "docstring": "\"\"\"Register a custom template test, available application wide.  Like\n        :meth:`Flask.template_test` but for a blueprint.\n\n        .. versionadded:: 0.10\n\n        :param name: the optional name of the test, otherwise the\n                     function name will be used.\n        \"\"\"",
                    "first_doc": "\"\"\"\nRegisters a custom template test function for application-wide use within a blueprint.\n\nThis method creates a decorator that, when applied to a function, registers that function as a template test accessible throughout the application. If no name is provided, the original function name is used as the test name.\n\nArgs:\n    self: The blueprint instance on which the template test is being registered.\n\nReturns:\n    function: A decorator that registers the decorated function as an application-wide template test.\n\"\"\"",
                    "method_name": "app_template_test",
                    "second_doc": "\"\"\"\nEnables developers to create reusable, custom template test functions that can be registered at the blueprint level and made available across the application. This supports consistent logic in template rendering by allowing shared tests for use in Jinja templates.\n\nArgs:\n    self: The Blueprint instance on which the template test is being registered.\n    name (str, optional): The name under which the test will be registered. If not provided, the function's own name is used.\n\nReturns:\n    function: A decorator that, when applied to a function, registers it as an application-wide template test accessible in templates.\n\"\"\"",
                    "source_code": "def decorator(f):\n            self.add_app_template_test(f, name=name)\n            return f\n\n        return decorator"
                },
                {
                    "docstring": "\"\"\"Register a custom template test, available application wide.  Like\n        :meth:`Flask.add_template_test` but for a blueprint.  Works exactly\n        like the :meth:`app_template_test` decorator.\n\n        .. versionadded:: 0.10\n\n        :param name: the optional name of the test, otherwise the\n                     function name will be used.\n        \"\"\"",
                    "first_doc": "\"\"\"\nRegisters a custom template test to be available application-wide within the blueprint context.\n\nAdds the provided test function to the Jinja environment under the specified name, allowing it to be used in templates rendered by the application. This method works similarly to Flask's add_template_test but is specific to blueprints.\n\nArgs:\n    f: The test function to register as a Jinja template test.\n\nFields Initialized:\n    None.\n\nReturns:\n    None. Registers the template test for use within the application\u2019s Jinja environment.\n\"\"\"",
                    "method_name": "add_app_template_test",
                    "second_doc": "\"\"\"\nMakes a custom test function accessible to all templates associated with this blueprint.\n\nBy registering a test in the Jinja environment under a specified name, templates can perform condition checks directly, promoting modularity and reusability in template logic. This enhances the flexibility with which developers can tailor template behavior.\n\nArgs:\n    f (callable): The test function to be registered for Jinja template use.\n\nReturns:\n    None: The test is added to the template environment for use during rendering.\n\"\"\"",
                    "source_code": "def register_template(state):\n            state.app.jinja_env.tests[name or f.__name__] = f\n\n        self.record_once(register_template)"
                },
                {
                    "docstring": "\"\"\"Register a custom template global, available application wide.  Like\n        :meth:`Flask.template_global` but for a blueprint.\n\n        .. versionadded:: 0.10\n\n        :param name: the optional name of the global, otherwise the\n                     function name will be used.\n        \"\"\"",
                    "first_doc": "\"\"\"\nRegisters a custom template global that is available application-wide for the blueprint.\n\nThis method functions similarly to Flask's `template_global`, allowing you to make a function accessible in Jinja templates, but applies it specifically for blueprints.\n\nArgs:\n    self: The blueprint instance on which to register the global.\n\nReturns:\n    function: A decorator that registers the decorated function as a global template variable.\n\"\"\"",
                    "method_name": "app_template_global",
                    "second_doc": "\"\"\"\nAllows you to register a function as a template global, making it accessible across all templates rendered by the blueprint. This enables template customization and the reuse of common utilities or variables across different parts of the application's user interface.\n\nArgs:\n    self: The Blueprint instance on which to register the template global.\n    name (str, optional): The name to use for the template global. If not provided, the function's name is used.\n\nReturns:\n    function: A decorator that, when applied to a function, registers it as a global template variable for this blueprint.\n\"\"\"",
                    "source_code": "def decorator(f):\n            self.add_app_template_global(f, name=name)\n            return f\n\n        return decorator"
                },
                {
                    "docstring": "\"\"\"Register a custom template global, available application wide.  Like\n        :meth:`Flask.add_template_global` but for a blueprint.  Works exactly\n        like the :meth:`app_template_global` decorator.\n\n        .. versionadded:: 0.10\n\n        :param name: the optional name of the global, otherwise the\n                     function name will be used.\n        \"\"\"",
                    "first_doc": "\"\"\"\nRegisters a custom template global function to be available application-wide for all templates rendered by the blueprint.\n\nThis method allows adding a global template function, similar to Flask's `add_template_global`, but scoped to the blueprint. If no name is provided, the function's own name will be used as the template global name.\n\nArgs:\n    f: The function to register as a template global. This function will be accessible within the template context.\n\nReturns:\n    The original function `f` after registration as a template global.\n\"\"\"",
                    "method_name": "add_app_template_global",
                    "second_doc": "\"\"\"\nAllows the registration of a function as a global template helper, making it accessible in the template environment of all views associated with this blueprint. This enables consistent presentation logic and shared utilities to be easily available throughout your application's templates.\n\nArgs:\n    f: The function to be registered as a template global. This function can then be called directly from any template rendered within the blueprint.\n    name (optional): The name under which the function will be available in templates. If not provided, the function\u2019s own name is used.\n\nReturns:\n    The original function `f`, after it has been registered as a global template helper.\n\"\"\"",
                    "source_code": "def register_template(state):\n            state.app.jinja_env.globals[name or f.__name__] = f\n\n        self.record_once(register_template)"
                },
                {
                    "docstring": "\"\"\"Like :meth:`Flask.before_request` but for a blueprint.  This function\n        is only executed before each request that is handled by a function of\n        that blueprint.\n        \"\"\"",
                    "first_doc": "\"\"\"\nRegisters a function to be executed before each request handled by this blueprint.\n\nThis method allows you to specify a callback function that runs before requests associated with the blueprint are processed. The callback is only executed for requests that are routed to this blueprint.\n\nArgs:\n    f: The function to register as a before request callback. This function should take no arguments and will be invoked before request processing begins.\n\nReturns:\n    The registered callback function.\n\"\"\"",
                    "method_name": "before_request",
                    "second_doc": "\"\"\"\nRegisters a callback to execute before each request associated with this blueprint.\n\nThis method ensures that specified setup or processing steps are performed before handling any request routed to the blueprint, allowing for consistent pre-processing logic such as authentication or logging.\n\nArgs:\n    f: The function to register as a pre-request callback. This function should not accept any arguments and will be called before each request is processed by routes within the blueprint.\n\nReturns:\n    The registered callback function.\n\"\"\"",
                    "source_code": "self.record_once(\n            lambda s: s.app.before_request_funcs.setdefault(self.name, []).append(f)\n        )\n        return f"
                },
                {
                    "docstring": "\"\"\"Like :meth:`Flask.before_request`.  Such a function is executed\n        before each request, even if outside of a blueprint.\n        \"\"\"",
                    "first_doc": "\"\"\"\nRegisters a function to be executed before each request, regardless of blueprint context.\n\nThis method allows you to specify a function that will run prior to each incoming request to the application, similar to Flask's `before_request`. The registered function is added to the application's list of functions to execute before handling a request.\n\nArgs:\n    f: The function to register to be executed before each request.\n\nReturns:\n    The registered function `f`.\n\"\"\"",
                    "method_name": "before_app_request",
                    "second_doc": "\"\"\"\nEnsures that a specified function is executed prior to handling each incoming request to the application, independent of blueprint configuration.\n\nBy allowing registration of pre-request functions, this method enables preparatory actions such as resource initialization, request validation, or context setup to occur consistently for every request processed by the application.\n\nArgs:\n    f: A callable representing the function to be run before each request is handled.\n\nReturns:\n    The original function `f` that was registered.\n\"\"\"",
                    "source_code": "self.record_once(\n            lambda s: s.app.before_request_funcs.setdefault(None, []).append(f)\n        )\n        return f"
                },
                {
                    "docstring": "\"\"\"Like :meth:`Flask.before_first_request`.  Such a function is\n        executed before the first request to the application.\n        \"\"\"",
                    "first_doc": "\"\"\"\nRegisters a function to be executed before the first request to the application.\n\nArgs:\n    f: The function to be called before handling the first request.\n\nReturns:\n    The provided function f.\n\"\"\"",
                    "method_name": "before_app_first_request",
                    "second_doc": "\"\"\"\nRegisters a function to be called before the application's first request is handled, allowing initialization or setup tasks to occur exactly once before serving any requests.\n\nArgs:\n    f: The function to execute before the first request to the application.\n\nReturns:\n    The same function f, enabling decorator usage and further chaining.\n\"\"\"",
                    "source_code": "self.record_once(lambda s: s.app.before_first_request_funcs.append(f))\n        return f"
                },
                {
                    "docstring": "\"\"\"Like :meth:`Flask.after_request` but for a blueprint.  This function\n        is only executed after each request that is handled by a function of\n        that blueprint.\n        \"\"\"",
                    "first_doc": "\"\"\"\nRegisters a function to be called after each request handled by this blueprint.\n\nThis method attaches the given function so it is executed after each request that is routed through and handled by the blueprint's view functions. The function can be used for response post-processing, such as modifying headers.\n\nArgs:\n    f: The function to be registered and executed after each request for this blueprint.\n\nReturns:\n    The same function that was passed in as an argument.\n\"\"\"",
                    "method_name": "after_request",
                    "second_doc": "\"\"\"\nRegisters a function to run after each request processed by this blueprint.\n\nEnabling post-processing of responses after every request handled by this blueprint allows for tasks such as modifying headers, logging, or cleanup, enhancing flexibility and consistency in how responses are finalized for grouped views.\n\nArgs:\n    f (callable): The function to register. It will be called with the response object after each request handled by this blueprint.\n\nReturns:\n    callable: The same function that was registered, allowing for decorator usage.\n\"\"\"",
                    "source_code": "self.record_once(\n            lambda s: s.app.after_request_funcs.setdefault(self.name, []).append(f)\n        )\n        return f"
                },
                {
                    "docstring": "\"\"\"Like :meth:`Flask.after_request` but for a blueprint.  Such a function\n        is executed after each request, even if outside of the blueprint.\n        \"\"\"",
                    "first_doc": "\"\"\"\nRegisters a function to be executed after each request, similar to Flask's `after_request`, but specifically for a blueprint.\n\nArgs:\n    f: The function to be registered to run after each request. This function should take a single argument, the response object, and return a response object.\n\nReturns:\n    The registered function `f`.\n\"\"\"",
                    "method_name": "after_app_request",
                    "second_doc": "\"\"\"\nRegisters a function to be executed after each request handled by the application, but only when this blueprint is active.\n\nThis is useful for adding additional processing or cleanup steps to all responses associated with this blueprint, ensuring consistent behavior after each relevant request.\n\nArgs:\n    f: A callable that accepts a single argument (the response object) and returns a response object. This function will be invoked after processing a request tied to this blueprint.\n\nReturns:\n    The original function `f`, allowing it to be referenced or decorated further if needed.\n\"\"\"",
                    "source_code": "self.record_once(\n            lambda s: s.app.after_request_funcs.setdefault(None, []).append(f)\n        )\n        return f"
                },
                {
                    "docstring": "\"\"\"Like :meth:`Flask.teardown_request` but for a blueprint.  This\n        function is only executed when tearing down requests handled by a\n        function of that blueprint.  Teardown request functions are executed\n        when the request context is popped, even when no actual request was\n        performed.\n        \"\"\"",
                    "first_doc": "\"\"\"\nRegisters a teardown function to be called when a request in this blueprint is torn down.\n\nThis method allows you to add a function that will be executed after the response has been constructed for any request handled by this blueprint. The teardown function will be invoked when the request context is popped, regardless of whether an actual request was handled.\n\nArgs:\n    f: The function to be registered as a teardown handler. It should accept an exception argument and will be called after the request ends.\n\nReturns:\n    The same function `f` that was passed in, after being registered as a teardown request handler for this blueprint.\n\"\"\"",
                    "method_name": "teardown_request",
                    "second_doc": "\"\"\"\nRegisters a function to be executed after a request associated with this component has concluded.\n\nBy registering a teardown function, this method ensures that necessary cleanup actions or finalization logic can reliably occur after a request cycle ends, regardless of whether the request was successfully processed or encountered an error. This promotes stability and consistency in the handling of resources specific to the blueprint.\n\nArgs:\n    f: A callable that accepts a single argument, which is an exception (if any occurred during the request). The function will be called after the request finishes.\n\nReturns:\n    The original function `f` after it has been registered as a teardown request handler for this blueprint.\n\"\"\"",
                    "source_code": "self.record_once(\n            lambda s: s.app.teardown_request_funcs.setdefault(self.name, []).append(f)\n        )\n        return f"
                },
                {
                    "docstring": "\"\"\"Like :meth:`Flask.teardown_request` but for a blueprint.  Such a\n        function is executed when tearing down each request, even if outside of\n        the blueprint.\n        \"\"\"",
                    "first_doc": "\"\"\"\nRegisters a function to be called when tearing down each request for the blueprint.\n\nThis method allows you to specify a function that will be executed after every request, even if the request did not originate from the blueprint. It is similar to Flask's `teardown_request`, but applies to blueprints.\n\nArgs:\n    f: The function to be registered for execution on teardown of each request.\n\nReturns:\n    The same function that was passed in as an argument.\n\"\"\"",
                    "method_name": "teardown_app_request",
                    "second_doc": "\"\"\"\nAssociates a function to be executed after the completion of each request in the application context when this blueprint is active.\n\nThis allows developers to perform necessary cleanup, resource management, or logging actions after every request lifecycle, ensuring that such operations are consistently handled regardless of where the request originated.\n\nArgs:\n    f: A callable to be triggered upon teardown of each request.\n\nReturns:\n    The original function `f`, to facilitate decorator usage and further chaining.\n\"\"\"",
                    "source_code": "self.record_once(\n            lambda s: s.app.teardown_request_funcs.setdefault(None, []).append(f)\n        )\n        return f"
                },
                {
                    "docstring": "\"\"\"Like :meth:`Flask.context_processor` but for a blueprint.  This\n        function is only executed for requests handled by a blueprint.\n        \"\"\"",
                    "first_doc": "\"\"\"\nRegisters a template context processor function for the blueprint.\n\nThis method is similar to Flask's context_processor but only applies the processor to requests handled by this specific blueprint. The given function is registered to add context to templates rendered as part of this blueprint's request handling.\n\nArgs:\n    f: The function to be registered as a template context processor. This function should return a dictionary of variables to inject into the template context.\n\nReturns:\n    The function f that was registered as a template context processor.\n\"\"\"",
                    "method_name": "context_processor",
                    "second_doc": "\"\"\"\nRegisters a function to supply extra variables to the template context specifically for templates rendered from this blueprint.\n\nBy associating context processors on a per-blueprint basis, this method ensures that only relevant context data is available when rendering templates linked to routes of this blueprint, supporting better separation of concerns and modularity within the application.\n\nArgs:\n    f: A function that returns a dictionary of variables to inject into the template context for this blueprint\u2019s templates.\n\nReturns:\n    The same function f that was registered as a context processor.\n\"\"\"",
                    "source_code": "self.record_once(\n            lambda s: s.app.template_context_processors.setdefault(\n                self.name, []\n            ).append(f)\n        )\n        return f"
                },
                {
                    "docstring": "\"\"\"Like :meth:`Flask.context_processor` but for a blueprint.  Such a\n        function is executed each request, even if outside of the blueprint.\n        \"\"\"",
                    "first_doc": "\"\"\"\nRegisters a function as an application-wide template context processor for the blueprint.\n\nThis method ensures that the provided function is executed to inject variables into the template context on each request, regardless of whether the request is associated with the blueprint.\n\nArgs:\n    self: The blueprint instance to which the context processor is being registered.\n    f: The function that will be used to inject variables into the template context.\n\nReturns:\n    The provided function f, after registering it as an application context processor.\n\"\"\"",
                    "method_name": "app_context_processor",
                    "second_doc": "\"\"\"\nRegisters a function to inject custom variables into the template context for all requests throughout the application, enabling dynamic modification of rendered templates.\n\nThis mechanism allows developers to consistently provide context data to templates, supporting flexible and reusable user interface rendering across different views.\n\nArgs:\n    self: The Blueprint instance to which the context processor function is being added.\n    f: A callable that returns a dictionary of variables to be made available in the template context.\n\nReturns:\n    The function f, after registering it as an application-wide template context processor.\n\"\"\"",
                    "source_code": "self.record_once(\n            lambda s: s.app.template_context_processors.setdefault(None, []).append(f)\n        )\n        return f"
                },
                {
                    "docstring": "\"\"\"Like :meth:`Flask.errorhandler` but for a blueprint.  This\n        handler is used for all requests, even if outside of the blueprint.\n        \"\"\"",
                    "first_doc": "\"\"\"\nRegisters an error handler for the given error code that applies to all requests, including those outside the current blueprint.\n\nArgs:\n    self: The blueprint instance to which the error handler is being attached.\n    code: The error code or exception class to associate with the error handler.\n\nReturns:\n    function: A decorator that registers the given function as an error handler for the specified code.\n\"\"\"",
                    "method_name": "app_errorhandler",
                    "second_doc": "\"\"\"\nAssociates a custom error handler with the specified error code, ensuring that the handler is registered globally across the application, not just within the current blueprint. This allows uniform handling of errors irrespective of their source, promoting consistent error responses and behavior throughout the web application.\n\nArgs:\n    self: The Blueprint instance to which the error handler is being attached.\n    code: The HTTP error code or exception class to link to the custom error handler.\n\nReturns:\n    function: A decorator for registering a function as a global error handler for the specified code.\n\"\"\"",
                    "source_code": "def decorator(f):\n            self.record_once(lambda s: s.app.errorhandler(code)(f))\n            return f\n\n        return decorator"
                },
                {
                    "docstring": "\"\"\"Registers a function as URL value preprocessor for this\n        blueprint.  It's called before the view functions are called and\n        can modify the url values provided.\n        \"\"\"",
                    "first_doc": "\"\"\"\nRegisters a function to preprocess URL values for this blueprint.\n\nThis method allows you to register a function that will be called before any view function is executed. The registered function can modify the URL values provided to the view, enabling preprocessing or adjustment of request parameters specific to this blueprint.\n\nArgs:\n    self: The blueprint instance to which the URL value preprocessor is being added.\n    f: The function to register as the URL value preprocessor. This function should accept the blueprint and the values parsed from the URL.\n\nReturns:\n    The function f that was registered as the URL value preprocessor.\n\"\"\"",
                    "method_name": "url_value_preprocessor",
                    "second_doc": "\"\"\"\nRegisters a function to preprocess URL values for this blueprint before the matching view function is called.\n\nThis mechanism enables developers to intercept and adjust the parameters parsed from the URL prior to their delivery to the intended view, thereby allowing for custom request handling logic at the blueprint level. By facilitating early intervention in the request processing cycle, this helps coordinate consistent parameter handling or setup across multiple views within the blueprint.\n\nArgs:\n    self: The blueprint instance where the URL value preprocessor is being registered.\n    f: A callable that takes the blueprint instance and a dictionary of parsed URL values, modifying them as needed.\n\nReturns:\n    The function f after registering it as a URL value preprocessor for this blueprint.\n\"\"\"",
                    "source_code": "self.record_once(\n            lambda s: s.app.url_value_preprocessors.setdefault(self.name, []).append(f)\n        )\n        return f"
                },
                {
                    "docstring": "\"\"\"Callback function for URL defaults for this blueprint.  It's called\n        with the endpoint and values and should update the values passed\n        in place.\n        \"\"\"",
                    "first_doc": "\"\"\"\nRegisters a callback function to provide default URL values for this blueprint.\n\nThis method adds the given callback function to the list of URL default functions\nassociated with this blueprint. The callback will be invoked with the endpoint and\nvalues and can update the values in place.\n\nArgs:\n    f: The callback function to handle URL defaults. It should accept an endpoint and a values dictionary as parameters.\n\nReturns:\n    The callback function f that was registered.\n\"\"\"",
                    "method_name": "url_defaults",
                    "second_doc": "\"\"\"\nAssociates a callback function that sets default values for URL building within this blueprint.\n\nBy registering this callback, you ensure that consistent or contextual URL defaults are automatically provided for routes associated with the blueprint. This facilitates URL generation that adapts based on application state or blueprint configuration.\n\nArgs:\n    f (callable): A callback function that takes an endpoint name and a dictionary of values, allowing the values to be modified in place to supply or adjust URL defaults.\n\nReturns:\n    callable: The callback function f that was registered.\n\"\"\"",
                    "source_code": "self.record_once(\n            lambda s: s.app.url_default_functions.setdefault(self.name, []).append(f)\n        )\n        return f"
                },
                {
                    "docstring": "\"\"\"Same as :meth:`url_value_preprocessor` but application wide.\n        \"\"\"",
                    "first_doc": "\"\"\"\nRegisters a function as an application-wide URL value preprocessor.\n\nThis method adds the provided function to the list of preprocessors that are invoked before any view function is called, allowing modification of the URL values for the entire application.\n\nArgs:\n    f: The function to be registered as a URL value preprocessor.\n\nReturns:\n    The same function that was passed in, after registering it as an application-wide URL value preprocessor.\n\"\"\"",
                    "method_name": "app_url_value_preprocessor",
                    "second_doc": "\"\"\"\nRegisters the given function to preprocess URL values before any view within this blueprint runs.\n\nThis allows developers to systematically intercept and adapt URL parameters for all views associated with the blueprint, facilitating cross-cutting concerns such as modifying, validating, or extracting data from URLs consistently before request handling.\n\nArgs:\n    f: A function to be called as a URL value preprocessor, which receives the blueprint and the URL values dictionary.\n\nReturns:\n    The original function, after it has been registered as a URL value preprocessor for all routes in the blueprint.\n\"\"\"",
                    "source_code": "self.record_once(\n            lambda s: s.app.url_value_preprocessors.setdefault(None, []).append(f)\n        )\n        return f"
                },
                {
                    "docstring": "\"\"\"Same as :meth:`url_defaults` but application wide.\n        \"\"\"",
                    "first_doc": "\"\"\"\nRegisters a URL default function for the entire application.\n\nThis method allows specifying a function that can modify or provide default URL values for all routes in the application, rather than being limited to a blueprint scope.\n\nArgs:\n    self: The instance of the class.\n    f: The function to be registered as a URL default function.\n\nReturns:\n    The function f that was registered as a URL default function.\n\"\"\"",
                    "method_name": "app_url_defaults",
                    "second_doc": "\"\"\"\nAssociates a function to supply or modify default values for URL building operations across all application routes, not just within a specific blueprint.\n\nThis is useful for ensuring consistent URL parameter handling or dynamic value injection application-wide, enabling more centralized and scalable configuration of route defaults.\n\nArgs:\n    self: The Blueprint instance on which this method is called.\n    f (callable): A function that determines default values for URL generation throughout the application.\n\nReturns:\n    callable: The registered function f.\n\"\"\"",
                    "source_code": "self.record_once(\n            lambda s: s.app.url_default_functions.setdefault(None, []).append(f)\n        )\n        return f"
                },
                {
                    "docstring": "\"\"\"Registers an error handler that becomes active for this blueprint\n        only.  Please be aware that routing does not happen local to a\n        blueprint so an error handler for 404 usually is not handled by\n        a blueprint unless it is caused inside a view function.  Another\n        special case is the 500 internal server error which is always looked\n        up from the application.\n\n        Otherwise works as the :meth:`~flask.Flask.errorhandler` decorator\n        of the :class:`~flask.Flask` object.\n        \"\"\"",
                    "first_doc": "\"\"\"\nRegisters an error handler specific to this blueprint.\n\nRegisters a decorator that associates an error handler function with a specific error code or exception, but only for errors raised within view functions of this blueprint. Be aware that 404 and 500 errors are handled as special cases: 404 errors are only caught if caused inside a view function, and 500 errors are always handled at the application level. Otherwise, the behavior mirrors that of Flask's errorhandler decorator at the application level.\n\nArgs:\n    code_or_exception: The error code or exception to be handled by the decorator.\n\nReturns:\n    A decorator that associates the passed-in function as the error handler for the specified code or exception within this blueprint.\n\"\"\"",
                    "method_name": "errorhandler",
                    "second_doc": "\"\"\"\nAssociates a specific error handler function with an error code or exception, but limits the scope of the handler to only the routes registered under this blueprint.\n\nThis method enables modular and localized error handling in your application, so you can define custom responses for errors that occur within a specific part of your project. It helps keep error management organized and prevents global error handlers from interfering where specific behavior is desired.\n\nArgs:\n    code_or_exception: An HTTP status code or exception class for which the decorated function will serve as the error handler within this blueprint.\n\nReturns:\n    function: A decorator that registers the given function as the error handler for the specified error or exception type, scoped to this blueprint's routes.\n\"\"\"",
                    "source_code": "def decorator(f):\n            self.record_once(\n                lambda s: s.app._register_error_handler(self.name, code_or_exception, f)\n            )\n            return f\n\n        return decorator"
                },
                {
                    "docstring": "\"\"\"Non-decorator version of the :meth:`errorhandler` error attach\n        function, akin to the :meth:`~flask.Flask.register_error_handler`\n        application-wide function of the :class:`~flask.Flask` object but\n        for error handlers limited to this blueprint.\n\n        .. versionadded:: 0.11\n        \"\"\"",
                    "first_doc": "\"\"\"\nRegisters an error handler for a specific exception or status code within this blueprint.\n\nThis method allows you to attach a custom error handler limited to the current blueprint, similar to Flask's application-wide error handler registration.\n\nArgs:\n    code_or_exception: The exception class or HTTP status code to handle.\n    f: The function to handle the specified error or exception.\n\nReturns:\n    None: This method does not return a value; it registers the handler for later use.\n\"\"\"",
                    "method_name": "register_error_handler",
                    "second_doc": "\"\"\"\nAssociates a custom error handler with a specific exception or HTTP status code for this blueprint instance.\n\nThis enables handling designated errors in a modular way, letting individual parts of the application manage their own error behaviors, rather than relying solely on global application handling. This supports more maintainable and reusable error-handling logic.\n\nArgs:\n    code_or_exception: Exception class or integer HTTP status code indicating which errors the handler should process.\n    f: Function to handle the error, called with the error as an argument when triggered.\n\nReturns:\n    None: Registers the handler for use when relevant errors occur within the blueprint.\n\"\"\"",
                    "source_code": "self.record_once(\n            lambda s: s.app._register_error_handler(self.name, code_or_exception, f)\n        )"
                }
            ],
            "name": "Blueprint",
            "type": "class"
        }
    ],
    "flask/src/flask/cli.py": [
        {
            "methods": [],
            "name": "NoAppException",
            "type": "class"
        },
        {
            "details": {
                "docstring": "\"\"\"Given a module instance this tries to find the best possible\n    application in the module or raises an exception.\n    \"\"\"",
                "first_doc": "\"\"\"\nFinds and returns the best Flask application instance from a given module.\n\nThis method searches the provided module for the most likely Flask application object or factory. It first looks for common attribute names ('app', 'application'), then looks for any Flask instances, and finally searches for recognized factory functions that return a Flask instance.\n\nArgs:\n    script_info: The script information, typically passed to factory functions if needed.\n    module: The Python module to search for a Flask application or factory.\n\nReturns:\n    Flask: The discovered Flask application instance.\n\nRaises:\n    NoAppException: If no Flask application or unambiguous factory can be found in the module.\n\"\"\"",
                "method_name": "find_best_app",
                "second_doc": "\"\"\"\nIdentifies and returns the most appropriate Flask application instance within a given module to ensure commands and operations are executed in the correct application context.\n\nThis method systematically inspects the module for recognizable Flask application attributes, existing app instances, or conventional factory functions, prioritizing clarity and preventing ambiguity when multiple candidates are present.\n\nArgs:\n    script_info: Contextual information or parameters passed to factory functions if instantiating the app dynamically.\n    module: The Python module to inspect for a Flask application instance or factory function.\n\nReturns:\n    Flask: The resolved Flask application instance ready for use.\n\nRaises:\n    NoAppException: If no valid Flask application or a clear factory function can be found, or if multiple ambiguous app objects are detected.\n\"\"\"",
                "source_code": "from . import Flask\n\n    # Search for the most common names first.\n    for attr_name in (\"app\", \"application\"):\n        app = getattr(module, attr_name, None)\n\n        if isinstance(app, Flask):\n            return app\n\n    # Otherwise find the only object that is a Flask instance.\n    matches = [v for v in module.__dict__.values() if isinstance(v, Flask)]\n\n    if len(matches) == 1:\n        return matches[0]\n    elif len(matches) > 1:\n        raise NoAppException(\n            \"Detected multiple Flask applications in module\"\n            f\" {module.__name__!r}. Use 'FLASK_APP={module.__name__}:name'\"\n            f\" to specify the correct one.\"\n        )\n\n    # Search for app factory functions.\n    for attr_name in {\"create_app\", \"make_app\"}:\n        app_factory = getattr(module, attr_name, None)\n\n        if inspect.isfunction(app_factory):\n            try:\n                app = call_factory(script_info, app_factory)\n\n                if isinstance(app, Flask):\n                    return app\n            except TypeError:\n                if not _called_with_wrong_args(app_factory):\n                    raise\n                raise NoAppException(\n                    f\"Detected factory {attr_name!r} in module {module.__name__!r},\"\n                    \" but could not call it without arguments. Use\"\n                    f\" \\\"FLASK_APP='{module.__name__}:{attr_name}(args)'\\\"\"\n                    \" to specify arguments.\"\n                )\n\n    raise NoAppException(\n        \"Failed to find Flask application or factory in module\"\n        f\" {module.__name__!r}. Use 'FLASK_APP={module.__name__}:name'\"\n        \" to specify one.\"\n    )"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": "\"\"\"Takes an app factory, a ``script_info` object and  optionally a tuple\n    of arguments. Checks for the existence of a script_info argument and calls\n    the app_factory depending on that and the arguments provided.\n    \"\"\"",
                "first_doc": "\"\"\"\nCalls the provided application factory function with appropriate arguments, handling deprecation warnings for the 'script_info' parameter.\n\nArgs:\n    script_info: The script information object to pass to the factory, if needed.\n    app_factory: The application factory function to be called.\n\nReturns:\n    The result of calling the application factory function, which is typically an application instance or related object.\n\"\"\"",
                "method_name": "call_factory",
                "second_doc": "\"\"\"\nCalls the given application factory function with dynamically determined arguments, ensuring compatibility with current and upcoming interface requirements by appropriately handling the deprecated 'script_info' parameter. This allows the framework to support both legacy and modern application factory signatures, aiding smooth project upgrades and extensibility.\n\nArgs:\n    script_info: An object containing script execution context, passed for backward compatibility with factories expecting it.\n    app_factory: The user-defined function responsible for creating the application instance.\n    args: Optional list of positional arguments for the factory.\n    kwargs: Optional dictionary of keyword arguments for the factory.\n\nReturns:\n    The object returned by the application factory function, typically the configured application instance.\n\"\"\"",
                "source_code": "sig = inspect.signature(app_factory)\n    args = [] if args is None else args\n    kwargs = {} if kwargs is None else kwargs\n\n    if \"script_info\" in sig.parameters:\n        warnings.warn(\n            \"The 'script_info' argument is deprecated and will not be\"\n            \" passed to the app factory function in 2.1.\",\n            DeprecationWarning,\n        )\n        kwargs[\"script_info\"] = script_info\n\n    if (\n        not args\n        and len(sig.parameters) == 1\n        and next(iter(sig.parameters.values())).default is inspect.Parameter.empty\n    ):\n        warnings.warn(\n            \"Script info is deprecated and will not be passed as the\"\n            \" single argument to the app factory function in 2.1.\",\n            DeprecationWarning,\n        )\n        args.append(script_info)\n\n    return app_factory(*args, **kwargs)"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": "\"\"\"Check whether calling a function raised a ``TypeError`` because\n    the call failed or because something in the factory raised the\n    error.\n\n    :param f: The function that was called.\n    :return: ``True`` if the call failed.\n    \"\"\"",
                "first_doc": "\"\"\"\nDetermines whether a function was called with inappropriate arguments based on the traceback.\n\nArgs:\n    f: The function to check within the current exception traceback.\n\nReturns:\n    bool: True if the function was not reached (i.e., likely called with the wrong arguments), False if it was called successfully.\n\"\"\"",
                "method_name": "_called_with_wrong_args",
                "second_doc": "\"\"\"\nChecks whether the provided function was actually executed before an exception occurred, by examining the traceback. This helps distinguish errors caused by incorrect arguments from those raised within the function body.\n\nArgs:\n    f (function): The function object whose presence in the current exception's traceback is being checked.\n\nReturns:\n    bool: True if the function was not reached (indicating the error likely resulted from invalid arguments or signature mismatch), False if the function was entered and executed before the error.\n\"\"\"",
                "source_code": "tb = sys.exc_info()[2]\n\n    try:\n        while tb is not None:\n            if tb.tb_frame.f_code is f.__code__:\n                # In the function, it was called successfully.\n                return False\n\n            tb = tb.tb_next\n\n        # Didn't reach the function.\n        return True\n    finally:\n        # Delete tb to break a circular reference.\n        # https://docs.python.org/2/library/sys.html#sys.exc_info\n        del tb"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": "\"\"\"Check if the given string is a variable name or a function. Call\n    a function to get the app instance, or return the variable directly.\n    \"\"\"",
                "first_doc": "\"\"\"\nAttempts to locate and return a Flask application object from a module based on a string reference.\n\nThis method parses the app_name as either a simple attribute or a function call, then retrieves and optionally calls the corresponding attribute from the provided module. If a valid Flask app instance is found, it is returned; otherwise, exceptions are raised accordingly.\n\nArgs:\n    script_info: Additional context or information needed when calling a factory function, typically passed to the call_factory helper.\n    module: The imported Python module object in which to search for the application object or factory.\n    app_name: A string expression referencing an attribute or callable (optionally with arguments) within the module, representing the Flask application.\n\nReturns:\n    Flask: The located Flask application instance.\n\nRaises:\n    NoAppException: If the app_name cannot be parsed, if the referenced object does not exist, if arguments are invalid, or if a valid Flask application was not obtained.\n\"\"\"",
                "method_name": "find_app_by_string",
                "second_doc": "\"\"\"\nDynamically locates and returns a Flask application instance from a specified Python module using a string reference for either an attribute or a factory function call.\n\nThis method interprets the provided reference, retrieves the corresponding object from the module, and, if necessary, invokes it. By doing so, it enables dynamic loading and flexible configuration of application instances, ensuring that the correct Flask app is available for use or further management.\n\nArgs:\n    script_info: Contextual information used when invoking a factory function, passed to the call_factory helper if the attribute is callable.\n    module: The imported Python module in which to search for the Flask application object or factory function.\n    app_name: A string specifying an attribute name or function call (with optional arguments) within the module that should yield the Flask application.\n\nReturns:\n    Flask: The obtained Flask application instance.\n\nRaises:\n    NoAppException: If the reference cannot be interpreted, the attribute is missing, provided arguments are invalid, or the resulting object is not a valid Flask application.\n\"\"\"",
                "source_code": "from . import Flask\n\n    # Parse app_name as a single expression to determine if it's a valid\n    # attribute name or function call.\n    try:\n        expr = ast.parse(app_name.strip(), mode=\"eval\").body\n    except SyntaxError:\n        raise NoAppException(\n            f\"Failed to parse {app_name!r} as an attribute name or function call.\"\n        )\n\n    if isinstance(expr, ast.Name):\n        name = expr.id\n        args = kwargs = None\n    elif isinstance(expr, ast.Call):\n        # Ensure the function name is an attribute name only.\n        if not isinstance(expr.func, ast.Name):\n            raise NoAppException(\n                f\"Function reference must be a simple name: {app_name!r}.\"\n            )\n\n        name = expr.func.id\n\n        # Parse the positional and keyword arguments as literals.\n        try:\n            args = [ast.literal_eval(arg) for arg in expr.args]\n            kwargs = {kw.arg: ast.literal_eval(kw.value) for kw in expr.keywords}\n        except ValueError:\n            # literal_eval gives cryptic error messages, show a generic\n            # message with the full expression instead.\n            raise NoAppException(\n                f\"Failed to parse arguments as literal values: {app_name!r}.\"\n            )\n    else:\n        raise NoAppException(\n            f\"Failed to parse {app_name!r} as an attribute name or function call.\"\n        )\n\n    try:\n        attr = getattr(module, name)\n    except AttributeError:\n        raise NoAppException(\n            f\"Failed to find attribute {name!r} in {module.__name__!r}.\"\n        )\n\n    # If the attribute is a function, call it with any args and kwargs\n    # to get the real application.\n    if inspect.isfunction(attr):\n        try:\n            app = call_factory(script_info, attr, args, kwargs)\n        except TypeError:\n            if not _called_with_wrong_args(attr):\n                raise\n\n            raise NoAppException(\n                f\"The factory {app_name!r} in module\"\n                f\" {module.__name__!r} could not be called with the\"\n                \" specified arguments.\"\n            )\n    else:\n        app = attr\n\n    if isinstance(app, Flask):\n        return app\n\n    raise NoAppException(\n        \"A valid Flask application was not obtained from\"\n        f\" '{module.__name__}:{app_name}'.\"\n    )"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": "\"\"\"Given a filename this will try to calculate the python path, add it\n    to the search path and return the actual module name that is expected.\n    \"\"\"",
                "first_doc": "\"\"\"\nPrepares a Python module path for import by processing the given file path.\n\nThis method normalizes the given file path, removes the '.py' extension if present, and traces up the directory structure to build the dotted module name. It also modifies sys.path as necessary to ensure the module can be imported.\n\nArgs:\n    path: The file system path to a Python file or module.\n\nReturns:\n    str: The dotted import path for the specified Python module or package.\n\"\"\"",
                "method_name": "prepare_import",
                "second_doc": "\"\"\"\nConverts a filesystem path to a dotted Python module import path, enabling dynamic importing based on file location.\n\nThis method standardizes the given file path, removes the '.py' extension if applicable, and ascends the directory tree until it is outside any Python package (directories without an `__init__.py` file). It also adjusts `sys.path` to ensure the module is importable. The resulting dotted path reflects the correct importable module structure.\n\nThis process is necessary to reliably import modules regardless of their position in the project's package structure, supporting dynamic and modular development.\n\nArgs:\n    path (str): The absolute or relative filesystem path to a Python file or directory.\n\nReturns:\n    str: The dotted import path corresponding to the module or package derived from the provided file path.\n\"\"\"",
                "source_code": "path = os.path.realpath(path)\n\n    fname, ext = os.path.splitext(path)\n    if ext == \".py\":\n        path = fname\n\n    if os.path.basename(path) == \"__init__\":\n        path = os.path.dirname(path)\n\n    module_name = []\n\n    # move up until outside package structure (no __init__.py)\n    while True:\n        path, name = os.path.split(path)\n        module_name.append(name)\n\n        if not os.path.exists(os.path.join(path, \"__init__.py\")):\n            break\n\n    if sys.path[0] != path:\n        sys.path.insert(0, path)\n\n    return \".\".join(module_name[::-1])"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "locate_app",
                "second_doc": "\"\"\"\nLocate and return a callable web application object within a given Python module, raising precise exceptions when the module or application entry point cannot be found.\n\nThis function attempts to import the specified module and find a suitable application callable. If the import fails due to an error within the module, or if the application cannot be located, it raises an informative exception. This ensures that users receive immediate and clear feedback during application discovery, improving the development and debugging process.\n\nArgs:\n    module_name (str): The name of the module to search for the application object.\n    app_name (Optional[str]): The specific application object name to locate within the module. If None, the function will search for the most likely candidate.\n    script_info: Contextual information used for selecting the application.\n    raise_if_not_found (bool): Whether to raise an exception if the application cannot be found.\n\nReturns:\n    Any: The located application callable if found, otherwise returns None if not found and raise_if_not_found is False.\n\nRaises:\n    NoAppException: If the import fails internally or if the application cannot be found when required.\n\"\"\"",
                "source_code": "__traceback_hide__ = True  # noqa: F841\n\n    try:\n        __import__(module_name)\n    except ImportError:\n        # Reraise the ImportError if it occurred within the imported module.\n        # Determine this by checking whether the trace has a depth > 1.\n        if sys.exc_info()[2].tb_next:\n            raise NoAppException(\n                f\"While importing {module_name!r}, an ImportError was\"\n                f\" raised:\\n\\n{traceback.format_exc()}\"\n            )\n        elif raise_if_not_found:\n            raise NoAppException(f\"Could not import {module_name!r}.\")\n        else:\n            return\n\n    module = sys.modules[module_name]\n\n    if app_name is None:\n        return find_best_app(script_info, module)\n    else:\n        return find_app_by_string(script_info, module, app_name)"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "get_version",
                "second_doc": "\"\"\"\nDisplays the current versions of Python, Flask, and Werkzeug.\n\nThis method outputs version information to assist users in verifying their development environment setup and troubleshooting compatibility issues.\n\nArgs:\n    ctx: The command-line context object.\n    value: Determines whether to trigger version output.\n\nReturns:\n    None. The method outputs version information to the console and exits the application.\n\"\"\"",
                "source_code": "if not value or ctx.resilient_parsing:\n        return\n\n    import werkzeug\n    from . import __version__\n\n    click.echo(\n        f\"Python {platform.python_version()}\\n\"\n        f\"Flask {__version__}\\n\"\n        f\"Werkzeug {werkzeug.__version__}\",\n        color=ctx.color,\n    )\n    ctx.exit()"
            },
            "type": "function"
        },
        {
            "methods": [
                {
                    "docstring": null,
                    "method_name": "__init__",
                    "second_doc": "\"\"\"\nInitializes the DispatchingApp instance, configuring the application loading strategy based on environment settings to ensure efficient startup and responsiveness.\n\nArgs:\n    loader: The object responsible for loading the application.\n    use_eager_loading (bool, optional): Determines whether the application should be loaded immediately (eager loading) or in the background.\n\nReturns:\n    None\n\nWhy:\n    This method sets up the loading mechanism to optimize startup performance, balancing immediate availability and background initialization depending on deployment and operational context.\n\"\"\"",
                    "source_code": "self.loader = loader\n        self._app = None\n        self._lock = Lock()\n        self._bg_loading_exc_info = None\n\n        if use_eager_loading is None:\n            use_eager_loading = os.environ.get(\"WERKZEUG_RUN_MAIN\") != \"true\"\n\n        if use_eager_loading:\n            self._load_unlocked()\n        else:\n            self._load_in_background()"
                },
                {
                    "docstring": null,
                    "method_name": "_load_in_background",
                    "second_doc": "\"\"\"\nLoads the application in a separate background thread while managing thread safety and error tracking.\n\nThis method is designed to allow the application to initialize asynchronously, ensuring that potential errors during loading are captured and stored for later inspection without blocking the main execution flow.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                    "source_code": "def _load_app():\n            __traceback_hide__ = True  # noqa: F841\n            with self._lock:\n                try:\n                    self._load_unlocked()\n                except Exception:\n                    self._bg_loading_exc_info = sys.exc_info()\n\n        t = Thread(target=_load_app, args=())\n        t.start()"
                },
                {
                    "docstring": null,
                    "method_name": "_flush_bg_loading_exception",
                    "second_doc": "\"\"\"\nChecks for any exception that occurred during a background loading task and raises it in the main execution flow, ensuring that such errors are not silently ignored.\n\nThis helps maintain application stability by surfacing background loading errors to the main thread for appropriate handling.\n\nArgs:\n    None\n\nReturns:\n    None\n\nRaises:\n    Exception: If an exception was captured during background loading, it is raised to be handled or reported.\n\"\"\"",
                    "source_code": "__traceback_hide__ = True  # noqa: F841\n        exc_info = self._bg_loading_exc_info\n        if exc_info is not None:\n            self._bg_loading_exc_info = None\n            raise exc_info"
                },
                {
                    "docstring": null,
                    "method_name": "_load_unlocked",
                    "second_doc": "\"\"\"\nLoads the application object using the configured loader, ensuring a fresh app instance is retrieved and any previous background loading exceptions are cleared.\n\nThis method is necessary to ensure that each time the app is (re)loaded, it does so reliably and without residual state from earlier exceptions, supporting consistent runtime behavior.\n\nArgs:\n    None\n\nReturns:\n    The loaded application object as returned by the loader.\n\"\"\"",
                    "source_code": "__traceback_hide__ = True  # noqa: F841\n        self._app = rv = self.loader()\n        self._bg_loading_exc_info = None\n        return rv"
                },
                {
                    "docstring": null,
                    "method_name": "__call__",
                    "second_doc": "\"\"\"\nAllows the instance to act as a WSGI application, dispatching incoming HTTP requests to the appropriate underlying web application object. If the application is not yet loaded, ensures thread-safe initialization before proceeding.\n\nArgs:\n    environ (dict): The WSGI environment dictionary containing request data.\n    start_response (Callable): The callback for starting the HTTP response.\n\nReturns:\n    Any: The WSGI response generated by the underlying application.\n    \nWhy:\n    This method enables the class to serve web requests efficiently and safely, managing application loading and concurrency to guarantee consistent responses under varying runtime conditions.\n\"\"\"",
                    "source_code": "__traceback_hide__ = True  # noqa: F841\n        if self._app is not None:\n            return self._app(environ, start_response)\n        self._flush_bg_loading_exception()\n        with self._lock:\n            if self._app is not None:\n                rv = self._app\n            else:\n                rv = self._load_unlocked()\n            return rv(environ, start_response)"
                }
            ],
            "name": "DispatchingApp",
            "type": "class"
        },
        {
            "methods": [
                {
                    "docstring": null,
                    "method_name": "__init__",
                    "second_doc": "\"\"\"\nInitialize a ScriptInfo instance to store context and configuration necessary for managing a Python web application's execution environment.\n\nArgs:\n    app_import_path (str, optional): The import path to the application's main module or package. Defaults to the value in the FLASK_APP environment variable if not provided.\n    create_app (callable, optional): A factory function that takes this ScriptInfo instance and returns an application instance. Useful for deferred or dynamic app creation.\n    set_debug_flag (callable, optional): A function to set the debug flag on the application, enabling enhanced error messages and reloads during development.\n\nReturns:\n    None\n\nWhy:\n    This method prepares the necessary information and hooks to flexibly load, configure, and operate a Python web application, facilitating convenient development, testing, and deployment workflows.\n\"\"\"",
                    "source_code": "self.app_import_path = app_import_path or os.environ.get(\"FLASK_APP\")\n        #: Optionally a function that is passed the script info to create\n        #: the instance of the application.\n        self.create_app = create_app\n        #: A dictionary with arbitrary data that can be associated with\n        #: this script info.\n        self.data = {}\n        self.set_debug_flag = set_debug_flag\n        self._loaded_app = None"
                },
                {
                    "docstring": "\"\"\"Loads the Flask app (if not yet loaded) and returns it.  Calling\n        this multiple times will just result in the already loaded app to\n        be returned.\n        \"\"\"",
                    "first_doc": "\"\"\"\nLoads and returns the Flask application instance, initializing it if necessary.\n\nIf the application has not been loaded yet, this method attempts to locate and initialize\na Flask app using the provided factory or import path, or by searching for default files.\nSubsequent calls will return the already-loaded application instance without reinitializing.\n\nArgs:\n    self: The instance of the class calling this method.\n\nReturns:\n    The loaded Flask application instance.\n\nInitialized Class Fields:\n    _loaded_app: Caches the Flask application once it is initialized, so subsequent calls return the same instance.\n\"\"\"",
                    "method_name": "load_app",
                    "second_doc": "\"\"\"\nObtains and returns the Flask application instance, initializing it as needed for command-line or programmatic interaction.\n\nThis method ensures that only one application instance is created and reused within the current context. It first checks whether the application is already initialized; if not, it attempts to construct the application using a provided factory method, an explicit import path, or by auto-discovering default entry-point files. App configuration may be adjusted for debugging based on runtime settings. The process guarantees a consistent application object for further operations such as running the server, managing configurations, or executing commands.\n\nArgs:\n    self: The ScriptInfo instance invoking this method.\n\nReturns:\n    Flask: The initialized and loaded Flask application instance.\n\nRaises:\n    NoAppException: If no application can be found or initialized.\n\"\"\"",
                    "source_code": "__traceback_hide__ = True  # noqa: F841\n\n        if self._loaded_app is not None:\n            return self._loaded_app\n\n        if self.create_app is not None:\n            app = call_factory(self, self.create_app)\n        else:\n            if self.app_import_path:\n                path, name = (\n                    re.split(r\":(?![\\\\/])\", self.app_import_path, 1) + [None]\n                )[:2]\n                import_name = prepare_import(path)\n                app = locate_app(self, import_name, name)\n            else:\n                for path in (\"wsgi.py\", \"app.py\"):\n                    import_name = prepare_import(path)\n                    app = locate_app(self, import_name, None, raise_if_not_found=False)\n\n                    if app:\n                        break\n\n        if not app:\n            raise NoAppException(\n                \"Could not locate a Flask application. You did not provide \"\n                'the \"FLASK_APP\" environment variable, and a \"wsgi.py\" or '\n                '\"app.py\" module was not found in the current directory.'\n            )\n\n        if self.set_debug_flag:\n            # Update the app's debug flag through the descriptor so that\n            # other values repopulate as well.\n            app.debug = get_debug_flag()\n\n        self._loaded_app = app\n        return app"
                }
            ],
            "name": "ScriptInfo",
            "type": "class"
        },
        {
            "details": {
                "docstring": "\"\"\"Wraps a callback so that it's guaranteed to be executed with the\n    script's application context.  If callbacks are registered directly\n    to the ``app.cli`` object then they are wrapped with this function\n    by default unless it's disabled.\n    \"\"\"",
                "first_doc": "\"\"\"\nA decorator that ensures the decorated function is invoked within the Flask application context.\n\nThis decorator loads the Flask application and activates its context before calling the decorated function.\n\nArgs:\n    f: The function to decorate so it runs within the application context.\n\nReturns:\n    The output returned by invoking the decorated function within the Flask app context.\n\"\"\"",
                "method_name": "with_appcontext",
                "second_doc": "\"\"\"\nA decorator to ensure that the decorated function executes within the proper application context, allowing it to access resources, configuration, and state tied to the Flask app.\n\nThis is necessary because certain operations require access to objects and configurations that are only available when an application context is active.\n\nArgs:\n    f: The function to decorate. It will be executed with the Flask application context active.\n\nReturns:\n    The result produced by calling the decorated function within the Flask application context.\n\"\"\"",
                "source_code": "@click.pass_context\n    def decorator(__ctx, *args, **kwargs):\n        with __ctx.ensure_object(ScriptInfo).load_app().app_context():\n            return __ctx.invoke(f, *args, **kwargs)\n\n    return update_wrapper(decorator, f)"
            },
            "type": "function"
        },
        {
            "methods": [
                {
                    "docstring": "\"\"\"This works exactly like the method of the same name on a regular\n        :class:`click.Group` but it wraps callbacks in :func:`with_appcontext`\n        unless it's disabled by passing ``with_appcontext=False``.\n        \"\"\"",
                    "first_doc": "\"\"\"\nRegisters a new command with the group, optionally wrapping the callback to ensure it runs within the application context.\n\nArgs:\n    self: The group instance to which the command will be added.\n\nReturns:\n    function: A decorator that registers the provided function as a command of the group. The command's callback will be wrapped with application context if not disabled.\n\"\"\"",
                    "method_name": "command",
                    "second_doc": "\"\"\"\nAdds a new command to the group, with optional automatic wrapping to execute the callback within the appropriate application context. This ensures that resources and configuration specific to the current application instance are accessible when the command runs.\n\nArgs:\n    self: The AppGroup instance to which the command will be added.\n    with_appcontext (bool, optional): Indicates whether the command should be wrapped to run inside the application context. Defaults to True.\n    *args: Positional arguments passed to the underlying click.Group.command.\n    **kwargs: Keyword arguments passed to the underlying click.Group.command.\n\nReturns:\n    function: A decorator for registering the provided function as a group command, with context management applied if enabled.\n\"\"\"",
                    "source_code": "wrap_for_ctx = kwargs.pop(\"with_appcontext\", True)\n\n        def decorator(f):\n            if wrap_for_ctx:\n                f = with_appcontext(f)\n            return click.Group.command(self, *args, **kwargs)(f)\n\n        return decorator"
                },
                {
                    "docstring": "\"\"\"This works exactly like the method of the same name on a regular\n        :class:`click.Group` but it defaults the group class to\n        :class:`AppGroup`.\n        \"\"\"",
                    "first_doc": "\"\"\"\nCreates or retrieves a group command using the specified parameters, defaulting the group class to AppGroup.\n\nArgs:\n    self: The instance of the class on which this method is called.\n\nReturns:\n    A new or existing group command, using AppGroup as the default group class.\n\"\"\"",
                    "method_name": "group",
                    "second_doc": "\"\"\"\nCreates or retrieves a group command with the provided parameters, ensuring that the appropriate command group class is used. This helps organize command-line functionality under logical groupings, streamlining the management and extension of commands within the application.\n\nArgs:\n    self: The instance of the AppGroup class on which this method is called.\n    *args: Positional arguments forwarded to the underlying group creation logic.\n    **kwargs: Keyword arguments forwarded to configure the group; if 'cls' is not specified, it defaults to AppGroup.\n\nReturns:\n    click.Group: A new or existing command group, initialized with the correct group class for further command-line command organization.\n\"\"\"",
                    "source_code": "kwargs.setdefault(\"cls\", AppGroup)\n        return click.Group.group(self, *args, **kwargs)"
                }
            ],
            "name": "AppGroup",
            "type": "class"
        },
        {
            "methods": [
                {
                    "docstring": null,
                    "method_name": "__init__",
                    "second_doc": "\"\"\"\nInitializes the FlaskGroup object with customizable parameters and built-in commands for managing a Flask application's command-line interface.\n\nThis method sets up core attributes, command options, and default CLI commands to facilitate development and management tasks from the command line. The initialization enables dynamic creation and configuration of the application environment, which is essential for tasks such as running the development server, launching an interactive shell, or viewing registered routes.\n\nArgs:\n    create_app (callable, optional): A factory function for creating the Flask app instance.\n    extra (dict): Additional keyword arguments for customizing the command group.\n    add_default_commands (bool, optional): Whether to add default CLI commands (run, shell, routes).\n    add_version_option (bool, optional): Whether to include a version option in the CLI.\n    load_dotenv (bool, optional): Whether to load environment variables from a .env file.\n    set_debug_flag (bool, optional): Whether to configure debug mode based on environment settings.\n\nReturns:\n    None\n\"\"\"",
                    "source_code": "params = list(extra.pop(\"params\", None) or ())\n\n        if add_version_option:\n            params.append(version_option)\n\n        AppGroup.__init__(self, params=params, **extra)\n        self.create_app = create_app\n        self.load_dotenv = load_dotenv\n        self.set_debug_flag = set_debug_flag\n\n        if add_default_commands:\n            self.add_command(run_command)\n            self.add_command(shell_command)\n            self.add_command(routes_command)\n\n        self._loaded_plugin_commands = False"
                },
                {
                    "docstring": null,
                    "method_name": "_load_plugin_commands",
                    "second_doc": "\"\"\"\nLoads and registers additional command-line interface commands provided by external plugins, enabling extensibility through a standard entry point mechanism.\n\nThis method ensures that plugin commands are discovered and integrated only once, leveraging Python's plugin system to allow seamless addition of functionality via external distributions.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                    "source_code": "if self._loaded_plugin_commands:\n            return\n        try:\n            import pkg_resources\n        except ImportError:\n            self._loaded_plugin_commands = True\n            return\n\n        for ep in pkg_resources.iter_entry_points(\"flask.commands\"):\n            self.add_command(ep.load(), ep.name)\n        self._loaded_plugin_commands = True"
                },
                {
                    "docstring": null,
                    "method_name": "get_command",
                    "second_doc": "\"\"\"\nRetrieve a command for the CLI by its name, first checking built-in commands before attempting to load application-specific ones. This ensures that core operations remain accessible even if the application has issues, providing reliability and consistent functionality for command-line interactions.\n\nArgs:\n    ctx: The click execution context, which contains state and information needed to resolve the command.\n    name: The name of the command to retrieve.\n\nReturns:\n    The command object if found, otherwise None.\n\"\"\"",
                    "source_code": "self._load_plugin_commands()\n\n        # We load built-in commands first as these should always be the\n        # same no matter what the app does.  If the app does want to\n        # override this it needs to make a custom instance of this group\n        # and not attach the default commands.\n        #\n        # This also means that the script stays functional in case the\n        # application completely fails.\n        rv = AppGroup.get_command(self, ctx, name)\n        if rv is not None:\n            return rv\n\n        info = ctx.ensure_object(ScriptInfo)\n        try:\n            rv = info.load_app().cli.get_command(ctx, name)\n            if rv is not None:\n                return rv\n        except NoAppException:\n            pass"
                },
                {
                    "docstring": null,
                    "method_name": "list_commands",
                    "second_doc": "\"\"\"\nLists all available CLI commands, combining built-in commands with those provided by the application, to give users a comprehensive set of options for managing and interacting with the project.\n\nArgs:\n    ctx (click.Context): The Click context instance for the current command-line invocation, providing app and script info.\n\nReturns:\n    list: A sorted list of unique command names available for use.\n    \nWhy:\n    By aggregating both framework and app-specific commands, this method ensures users have clear visibility of all management and operational commands, facilitating easier application control and diagnostics.\n\"\"\"",
                    "source_code": "self._load_plugin_commands()\n\n        # The commands available is the list of both the application (if\n        # available) plus the builtin commands.\n        rv = set(click.Group.list_commands(self, ctx))\n        info = ctx.ensure_object(ScriptInfo)\n        try:\n            rv.update(info.load_app().cli.list_commands(ctx))\n        except Exception:\n            # Here we intentionally swallow all exceptions as we don't\n            # want the help page to break if the app does not exist.\n            # If someone attempts to use the command we try to create\n            # the app again and this will give us the error.\n            # However, we will not do so silently because that would confuse\n            # users.\n            traceback.print_exc()\n        return sorted(rv)"
                },
                {
                    "docstring": null,
                    "method_name": "main",
                    "second_doc": "\"\"\"\nExecutes the primary command-line entry point for the Flask application, preparing the environment and loading necessary configuration before delegating to the base command handler.\n\nThis method ensures that environment variables and configuration are loaded appropriately, and that a ScriptInfo object is available for application context and command handling.\n\nArgs:\n    *args: Positional arguments forwarded to the base main method.\n    **kwargs: Keyword arguments, which may include application and environment configuration.\n\nReturns:\n    int: The exit status code resulting from the command's execution.\n\nWhy:\n    This setup enables seamless command-line interaction, ensuring the application context and environment are correctly initialized for performing management tasks, such as running the server or executing custom commands.\n\"\"\"",
                    "source_code": "os.environ[\"FLASK_RUN_FROM_CLI\"] = \"true\"\n\n        if get_load_dotenv(self.load_dotenv):\n            load_dotenv()\n\n        obj = kwargs.get(\"obj\")\n\n        if obj is None:\n            obj = ScriptInfo(\n                create_app=self.create_app, set_debug_flag=self.set_debug_flag\n            )\n\n        kwargs[\"obj\"] = obj\n        kwargs.setdefault(\"auto_envvar_prefix\", \"FLASK\")\n        return super().main(*args, **kwargs)"
                }
            ],
            "name": "FlaskGroup",
            "type": "class"
        },
        {
            "details": {
                "docstring": "\"\"\"Take ``other`` and remove the length of ``path`` from it. Then join it\n    to ``path``. If it is the original value, ``path`` is an ancestor of\n    ``other``.\"\"\"",
                "first_doc": "\"\"\"\nDetermines if the given path is an ancestor directory of another path.\n\nArgs:\n    path: The base directory path to check as a potential ancestor.\n    other: The path to compare against, to determine if 'path' is an ancestor.\n\nReturns:\n    bool: True if 'path' is an ancestor of 'other', otherwise False.\n\"\"\"",
                "method_name": "_path_is_ancestor",
                "second_doc": "\"\"\"\nChecks whether the specified base directory serves as a prefix in the directory hierarchy for a given target path, ensuring accurate interpretation of file or resource organization.\n\nArgs:\n    path (str): The potential ancestor directory to verify.\n    other (str): The target path to check against the ancestor.\n\nReturns:\n    bool: True if the base directory is an ancestor of the target path (i.e., the target path resides within or under the base directory); False otherwise.\n\nWhy:\n    This validation is essential for reliably determining containment relationships between file system paths, often required for tasks such as resource management, route mapping, or security checks within applications.\n\"\"\"",
                "source_code": "return os.path.join(path, other[len(path) :].lstrip(os.sep)) == other"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": "\"\"\"Load \"dotenv\" files in order of precedence to set environment variables.\n\n    If an env var is already set it is not overwritten, so earlier files in the\n    list are preferred over later files.\n\n    Changes the current working directory to the location of the first file\n    found, with the assumption that it is in the top level project directory\n    and will be where the Python path should import local packages from.\n\n    This is a no-op if `python-dotenv`_ is not installed.\n\n    .. _python-dotenv: https://github.com/theskumar/python-dotenv#readme\n\n    :param path: Load the file at this location instead of searching.\n    :return: ``True`` if a file was loaded.\n\n    .. versionchanged:: 1.1.0\n        Returns ``False`` when python-dotenv is not installed, or when\n        the given path isn't a file.\n\n    .. versionadded:: 1.0\n    \"\"\"",
                "first_doc": "\"\"\"\nLoads environment variables from .env or .flaskenv files, if available.\n\nIf the 'python-dotenv' library is installed, attempts to load environment variables from .env or .flaskenv files located in the working directory or a specified path. If the library is not installed and such files are present, a tip is printed to suggest installing 'python-dotenv'. If a specific path is provided and points to a file, only that file is loaded.\n\nReturns:\n    bool: True if one or more environment variable files were successfully located and loaded, otherwise False.\n\"\"\"",
                "method_name": "load_dotenv",
                "second_doc": "\"\"\"\nAttempts to initialize application configuration by loading environment variables from .env or .flaskenv files, supporting dynamic customization of runtime settings without code changes.\n\nThis method helps ensure that application settings defined outside of the source code are available at startup, promoting separation of configuration from code and facilitating environment-specific adjustments.\n\nArgs:\n    path (str, optional): A specific file path to load environment variables from. If not provided, defaults to searching for .env and .flaskenv in the working directory.\n\nReturns:\n    bool: True if at least one environment variable file was found and loaded; False otherwise. If the required 'python-dotenv' package is not installed and such files are present, a tip to install the package is displayed.\n\"\"\"",
                "source_code": "if dotenv is None:\n        if path or os.path.isfile(\".env\") or os.path.isfile(\".flaskenv\"):\n            click.secho(\n                \" * Tip: There are .env or .flaskenv files present.\"\n                ' Do \"pip install python-dotenv\" to use them.',\n                fg=\"yellow\",\n                err=True,\n            )\n\n        return False\n\n    # if the given path specifies the actual file then return True,\n    # else False\n    if path is not None:\n        if os.path.isfile(path):\n            return dotenv.load_dotenv(path)\n\n        return False\n\n    new_dir = None\n\n    for name in (\".env\", \".flaskenv\"):\n        path = dotenv.find_dotenv(name, usecwd=True)\n\n        if not path:\n            continue\n\n        if new_dir is None:\n            new_dir = os.path.dirname(path)\n\n        dotenv.load_dotenv(path)\n\n    if new_dir and os.getcwd() != new_dir:\n        os.chdir(new_dir)\n\n    return new_dir is not None  # at least one file was located and loaded"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": "\"\"\"Show extra startup messages the first time the server is run,\n    ignoring the reloader.\n    \"\"\"",
                "first_doc": "\"\"\"\nDisplays a startup banner in the terminal with information about the Flask application, environment, and debug mode.\n\nArgs:\n    env: The current runtime environment (e.g., 'development', 'production').\n    debug: Indicates whether debug mode is enabled or disabled.\n    app_import_path: The import path or name of the Flask application.\n    eager_loading: Specifies whether the application should be loaded eagerly.\n\nReturns:\n    None: This method does not return any value.\n\"\"\"",
                "method_name": "show_server_banner",
                "second_doc": "\"\"\"\nDisplays a startup banner in the terminal summarizing key details about the application, such as its import path, current runtime environment, and debug status, to inform users of the server's configuration and caution against unsafe deployment modes when appropriate.\n\nArgs:\n    env (str): The current runtime environment (e.g., 'development', 'production').\n    debug (bool or None): Indicates whether debug mode is enabled or disabled.\n    app_import_path (str or None): The import path or name of the application to be displayed.\n    eager_loading (bool): Specifies whether the application should be loaded eagerly.\n\nReturns:\n    None: This function displays information to the terminal and does not return a value.\n\"\"\"",
                "source_code": "if os.environ.get(\"WERKZEUG_RUN_MAIN\") == \"true\":\n        return\n\n    if app_import_path is not None:\n        message = f\" * Serving Flask app {app_import_path!r}\"\n\n        if not eager_loading:\n            message += \" (lazy loading)\"\n\n        click.echo(message)\n\n    click.echo(f\" * Environment: {env}\")\n\n    if env == \"production\":\n        click.secho(\n            \"   WARNING: This is a development server. Do not use it in\"\n            \" a production deployment.\",\n            fg=\"red\",\n        )\n        click.secho(\"   Use a production WSGI server instead.\", dim=True)\n\n    if debug is not None:\n        click.echo(f\" * Debug mode: {'on' if debug else 'off'}\")"
            },
            "type": "function"
        },
        {
            "methods": [
                {
                    "docstring": null,
                    "method_name": "__init__",
                    "second_doc": "\"\"\"\nInitializes the CertParamType class by setting up a file path parameter type that ensures the specified path exists, refers to a file (not a directory), and is resolved to an absolute path.\n\nThis validation is important to guarantee the correctness and reliability of user input when handling file paths, reducing the risk of runtime errors due to invalid or unresolved paths.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                    "source_code": "self.path_type = click.Path(exists=True, dir_okay=False, resolve_path=True)"
                },
                {
                    "docstring": null,
                    "method_name": "convert",
                    "second_doc": "\"\"\"\nConverts the given value into a suitable certificate parameter for secure connections, validating SSL support, accepting paths, special 'adhoc' values, or SSLContext objects as needed.\n\nArgs:\n    value: The input value representing a certificate; may be a file path, 'adhoc', or import path to an SSLContext.\n    param: The Click parameter being processed.\n    ctx: The Click context for command-line parsing.\n\nReturns:\n    The resolved certificate parameter, which may be a file path, the string 'adhoc', or an SSLContext object.\n\nRaises:\n    click.BadParameter: If SSL support is unavailable, if required dependencies are missing, or if the input value cannot be resolved to a valid certificate parameter.\n\nWhy:\n    This method ensures flexible and robust acceptance of different certificate configurations, supporting a variety of secure server deployment scenarios and user preferences in specifying SSL/TLS credentials.\n\"\"\"",
                    "source_code": "if ssl is None:\n            raise click.BadParameter(\n                'Using \"--cert\" requires Python to be compiled with SSL support.',\n                ctx,\n                param,\n            )\n\n        try:\n            return self.path_type(value, param, ctx)\n        except click.BadParameter:\n            value = click.STRING(value, param, ctx).lower()\n\n            if value == \"adhoc\":\n                try:\n                    import cryptography  # noqa: F401\n                except ImportError:\n                    raise click.BadParameter(\n                        \"Using ad-hoc certificates requires the cryptography library.\",\n                        ctx,\n                        param,\n                    )\n\n                return value\n\n            obj = import_string(value, silent=True)\n\n            if isinstance(obj, ssl.SSLContext):\n                return obj\n\n            raise"
                }
            ],
            "name": "CertParamType",
            "type": "class"
        },
        {
            "details": {
                "docstring": "\"\"\"The ``--key`` option must be specified when ``--cert`` is a file.\n    Modifies the ``cert`` param to be a ``(cert, key)`` pair if needed.\n    \"\"\"",
                "first_doc": "\"\"\"\nValidates the usage of the private key option in conjunction with the certificate parameter.\n\nArgs:\n    ctx: The Click context object containing command parameters.\n    param: The Click parameter object corresponding to the key option.\n    value: The provided value for the key parameter.\n\nReturns:\n    The value of the key parameter if validation passes; otherwise, raises an exception if validation fails.\n\"\"\"",
                "method_name": "_validate_key",
                "second_doc": "\"\"\"\nEnsures that the private key parameter is used appropriately based on the provided certificate configuration, maintaining consistency and preventing invalid command-line input.\n\nArgs:\n    ctx: The Click context object containing current command parameters.\n    param: The Click parameter object corresponding to the key option.\n    value: The provided value for the key parameter.\n\nReturns:\n    The validated value of the key parameter if all conditions are met; otherwise, raises a click.BadParameter exception to signal improper usage.\n\"\"\"",
                "source_code": "cert = ctx.params.get(\"cert\")\n    is_adhoc = cert == \"adhoc\"\n    is_context = ssl and isinstance(cert, ssl.SSLContext)\n\n    if value is not None:\n        if is_adhoc:\n            raise click.BadParameter(\n                'When \"--cert\" is \"adhoc\", \"--key\" is not used.', ctx, param\n            )\n\n        if is_context:\n            raise click.BadParameter(\n                'When \"--cert\" is an SSLContext object, \"--key is not used.', ctx, param\n            )\n\n        if not cert:\n            raise click.BadParameter('\"--cert\" must also be specified.', ctx, param)\n\n        ctx.params[\"cert\"] = cert, value\n\n    else:\n        if cert and not (is_adhoc or is_context):\n            raise click.BadParameter('Required when using \"--cert\".', ctx, param)\n\n    return value"
            },
            "type": "function"
        },
        {
            "methods": [
                {
                    "docstring": null,
                    "method_name": "convert",
                    "second_doc": "\"\"\"\nConverts a separated string value into a list of processed items using the parent type's conversion logic. This approach facilitates parsing and handling of multiple related input values specified as a single string, commonly encountered in command-line or configuration scenarios.\n\nArgs:\n    value (str): The input string containing items separated by a specific delimiter.\n    param: The parameter that is being handled (may be None).\n    ctx: The current context (may be None).\n\nReturns:\n    list: A list of processed items, each individually converted using the base type's logic.\n\nWhy:\n    This method enables efficient handling and validation of multiple values provided as a single, delimited string input, allowing for seamless integration of complex or compound configuration and input patterns.\n\"\"\"",
                    "source_code": "items = self.split_envvar_value(value)\n        super_convert = super().convert\n        return [super_convert(item, param, ctx) for item in items]"
                }
            ],
            "name": "SeparatedPathType",
            "type": "class"
        },
        {
            "details": {
                "docstring": "\"\"\"Run a local development server.\n\n    This server is for development purposes only. It does not provide\n    the stability, security, or performance of production WSGI servers.\n\n    The reloader and debugger are enabled by default if\n    FLASK_ENV=development or FLASK_DEBUG=1.\n    \"\"\"",
                "first_doc": "\"\"\"\nRuns a local development server with customizable options for debugging, reloading, SSL, threading, and file watching.\n\nArgs:\n    info: Script information object containing application loading details and import path.\n    host: The interface address to bind the server to.\n    port: The port number to bind the server to.\n    reload: Whether to enable the code reloader; if not specified, defaults to the debug flag.\n    debugger: Whether to enable the interactive debugger; if not specified, defaults to the debug flag.\n    eager_loading: Whether to enable eager application loading; if not specified, eager loading depends on the reloader status.\n    with_threads: Enables or disables multithreading in the server.\n    cert: SSL certificate (and key if required) to enable HTTPS.\n    extra_files: Additional files to watch for changes; changes will trigger a reload.\n\nReturns:\n    None: This function runs the development server and does not return a value.\n\"\"\"",
                "method_name": "run_command",
                "second_doc": "\"\"\"\nStarts a local server instance with configurable options for debugging, live code reloads, SSL security, multithreading, and monitoring additional files for changes.\n\nThis method provides a controlled environment for running and testing web applications during development by allowing easy adjustment of server behavior, enabling rapid feedback and troubleshooting capabilities for developers.\n\nArgs:\n    info: Script information object containing application factory and import path details.\n    host (str): Network interface address to which the server binds.\n    port (int): Network port the server listens on.\n    reload (bool, optional): Whether the server automatically restarts on code changes; defaults to the debug flag if not specified.\n    debugger (bool, optional): Whether to enable an interactive debugger; defaults to the debug flag if not specified.\n    eager_loading (bool, optional): Whether application code should be eagerly loaded at startup. Defaults to True if reloader is disabled.\n    with_threads (bool): Enables or disables multi-threaded request handling.\n    cert (tuple or str, optional): SSL certificate (and optional key) to enable HTTPS connections.\n    extra_files (list, optional): List of file paths to monitor for changes, triggering a reload when modified.\n\nReturns:\n    None: The function launches and maintains the development server process, blocking further code execution until the server is stopped.\n\"\"\"",
                "source_code": "debug = get_debug_flag()\n\n    if reload is None:\n        reload = debug\n\n    if debugger is None:\n        debugger = debug\n\n    show_server_banner(get_env(), debug, info.app_import_path, eager_loading)\n    app = DispatchingApp(info.load_app, use_eager_loading=eager_loading)\n\n    from werkzeug.serving import run_simple\n\n    run_simple(\n        host,\n        port,\n        app,\n        use_reloader=reload,\n        use_debugger=debugger,\n        threaded=with_threads,\n        ssl_context=cert,\n        extra_files=extra_files,\n    )"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": "\"\"\"Run an interactive Python shell in the context of a given\n    Flask application.  The application will populate the default\n    namespace of this shell according to it's configuration.\n\n    This is useful for executing small snippets of management code\n    without having to manually configure the application.\n    \"\"\"",
                "first_doc": "\"\"\"\nStarts an interactive Python shell in the application's context.\n\nThis method launches a Python shell with the current application context loaded. It sets up a custom banner with information about the Python version, platform, application import name, environment, and instance path. The shell context includes variables provided by the application's shell context processor. If a PYTHONSTARTUP script is specified in the environment variables, it is executed before starting the shell.\n\nArgs:\n    None\n\nReturns:\n    None: This method does not return a value; it starts an interactive shell session.\n\"\"\"",
                "method_name": "shell_command",
                "second_doc": "\"\"\"\nLaunches an interactive Python shell preloaded with your application's context and helpful variables.\n\nThis method facilitates quick experimentation and inspection by providing direct access to components and configuration within the application environment, ensuring developers can conveniently interact with the runtime state and perform debugging or exploratory tasks. It sets up the shell with contextual information such as app details and imports additional context variables for convenience. If a PYTHONSTARTUP script is specified, it will be executed prior to starting the shell to maintain consistency with Python's default interactive behavior.\n\nArgs:\n    None\n\nReturns:\n    None: This method initiates an interactive shell session and does not return a value.\n\"\"\"",
                "source_code": "import code\n    from .globals import _app_ctx_stack\n\n    app = _app_ctx_stack.top.app\n    banner = (\n        f\"Python {sys.version} on {sys.platform}\\n\"\n        f\"App: {app.import_name} [{app.env}]\\n\"\n        f\"Instance: {app.instance_path}\"\n    )\n    ctx = {}\n\n    # Support the regular Python interpreter startup script if someone\n    # is using it.\n    startup = os.environ.get(\"PYTHONSTARTUP\")\n    if startup and os.path.isfile(startup):\n        with open(startup) as f:\n            eval(compile(f.read(), startup, \"exec\"), ctx)\n\n    ctx.update(app.make_shell_context())\n\n    code.interact(banner=banner, local=ctx)"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": "\"\"\"Show all registered routes with endpoints and methods.\"\"\"",
                "first_doc": "\"\"\"\nDisplays a formatted list of all the routes registered in the Flask application.\n\nShows detailed information about each route, including its endpoint, the HTTP methods it accepts, and the URL rule. The output can be sorted according to the specified criteria and optionally include HEAD and OPTIONS methods.\n\nArgs:\n    sort: The attribute to sort the displayed routes by. Valid options are \"endpoint\", \"methods\", \"rule\", and \"match\". Default is \"endpoint\".\n    all_methods: If True, includes HEAD and OPTIONS HTTP methods in the output.\n\nReturns:\n    None. Writes the list of routes to the console output.\n\"\"\"",
                "method_name": "routes_command",
                "second_doc": "\"\"\"\nDisplays a table of all registered routes in the application, including each route's endpoint, HTTP methods, and URL pattern.\n\nThis command is intended to help developers inspect and validate the routing configuration, making it easier to understand how different URLs are handled and identify potential routing issues. By providing sorted and customizable views, it facilitates debugging and ensures the routing map aligns with application intentions.\n\nArgs:\n    sort (str): Determines how the routes are sorted in the output. Can be \"endpoint\", \"methods\", \"rule\", or \"match\". Defaults to \"endpoint\".\n    all_methods (bool): If True, includes HEAD and OPTIONS methods for each route in the listing.\n\nReturns:\n    None. The method outputs the formatted list of routes directly to the console.\n\"\"\"",
                "source_code": "rules = list(current_app.url_map.iter_rules())\n    if not rules:\n        click.echo(\"No routes were registered.\")\n        return\n\n    ignored_methods = set(() if all_methods else (\"HEAD\", \"OPTIONS\"))\n\n    if sort in (\"endpoint\", \"rule\"):\n        rules = sorted(rules, key=attrgetter(sort))\n    elif sort == \"methods\":\n        rules = sorted(rules, key=lambda rule: sorted(rule.methods))\n\n    rule_methods = [\", \".join(sorted(rule.methods - ignored_methods)) for rule in rules]\n\n    headers = (\"Endpoint\", \"Methods\", \"Rule\")\n    widths = (\n        max(len(rule.endpoint) for rule in rules),\n        max(len(methods) for methods in rule_methods),\n        max(len(rule.rule) for rule in rules),\n    )\n    widths = [max(len(h), w) for h, w in zip(headers, widths)]\n    row = \"{{0:<{0}}}  {{1:<{1}}}  {{2:<{2}}}\".format(*widths)\n\n    click.echo(row.format(*headers).strip())\n    click.echo(row.format(*(\"-\" * width for width in widths)))\n\n    for rule, methods in zip(rules, rule_methods):\n        click.echo(row.format(rule.endpoint, methods, rule.rule).rstrip())"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "main",
                "second_doc": "\"\"\"\nEntry point for invoking the application's command-line interface, allowing execution and management of tasks such as running the server, managing configuration, or handling custom commands.\n\nArgs:\n    args (List[str], optional): Command-line arguments passed to the application, typically taken from sys.argv.\n    prog_name (str, optional): The name of the program to use in CLI output. Defaults to \"python -m flask\" if invoked as a module.\n\nReturns:\n    None\n\nWhy:\n    This method enables users and developers to interact with the application through a consistent and extensible command-line interface, streamlining common workflows such as starting development servers or performing administrative operations without direct code modification.\n\"\"\"",
                "source_code": "cli.main(args=sys.argv[1:], prog_name=\"python -m flask\" if as_module else None)"
            },
            "type": "function"
        }
    ],
    "flask/src/flask/config.py": [
        {
            "methods": [
                {
                    "docstring": null,
                    "method_name": "__init__",
                    "second_doc": "\"\"\"\nInitializes a configuration attribute instance with a given name and optional value conversion logic.\n\nThis method sets up the foundational properties that allow configuration settings to be accessed and, if necessary, converted before use. It enables flexible and dynamic handling of configuration values in the application.\n\nArgs:\n    name (str): The name identifier for the configuration attribute.\n    get_converter (callable): A function to convert the attribute value, or None if no conversion is needed.\n\nReturns:\n    None\n\"\"\"",
                    "source_code": "self.__name__ = name\n        self.get_converter = get_converter"
                },
                {
                    "docstring": null,
                    "method_name": "__get__",
                    "second_doc": "\"\"\"\nProvides descriptor access to a configuration attribute, enabling retrieval from an instance's configuration dictionary and optional conversion to the desired format.\n\nThis approach allows for transparent and controlled access to configuration values on objects, ensuring consistency and flexibility in how these values are retrieved or transformed.\n\nArgs:\n    obj: The instance from which the configuration attribute is accessed. If None, returns the descriptor itself.\n    objtype: The type of the instance (not used in this implementation).\n\nReturns:\n    The value of the configuration attribute, potentially transformed by a converter function if specified.\n\"\"\"",
                    "source_code": "if obj is None:\n            return self\n        rv = obj.config[self.__name__]\n        if self.get_converter is not None:\n            rv = self.get_converter(rv)\n        return rv"
                },
                {
                    "docstring": null,
                    "method_name": "__set__",
                    "second_doc": "\"\"\"\nSets the configuration value for this attribute on the given object.\n\nArgs:\n    obj: The instance whose configuration should be updated.\n    value: The value to assign to the attribute in the configuration.\n\nReturns:\n    None\n\nThis action is taken to ensure that configuration options are dynamically stored and accessible on the object, allowing for customized behavior per instance.\n\"\"\"",
                    "source_code": "obj.config[self.__name__] = value"
                }
            ],
            "name": "ConfigAttribute",
            "type": "class"
        },
        {
            "methods": [
                {
                    "docstring": null,
                    "method_name": "__init__",
                    "second_doc": "\"\"\"\nInitializes the configuration object by populating it with default values and storing the root application path.\n\nArgs:\n    defaults (dict, optional): A dictionary containing default configuration key-value pairs. If not provided, an empty dictionary is used.\n    root_path (str): The root path of the application.\n\nReturns:\n    None\n\nWhy:\n    Storing default configuration values and the application's root path helps centralize and simplify access to settings and resources needed throughout the application lifecycle.\n\"\"\"",
                    "source_code": "dict.__init__(self, defaults or {})\n        self.root_path = root_path"
                },
                {
                    "docstring": "\"\"\"Loads a configuration from an environment variable pointing to\n        a configuration file.  This is basically just a shortcut with nicer\n        error messages for this line of code::\n\n            app.config.from_pyfile(os.environ['YOURAPPLICATION_SETTINGS'])\n\n        :param variable_name: name of the environment variable\n        :param silent: set to ``True`` if you want silent failure for missing\n                       files.\n        :return: bool. ``True`` if able to load config, ``False`` otherwise.\n        \"\"\"",
                    "first_doc": "\"\"\"\nLoads a configuration from a file specified by an environment variable.\n\nThis method attempts to load the configuration from a file whose path is\nstored in the environment variable provided. It improves usability by\noffering clearer error messages when the environment variable is unset or\nthe file does not exist.\n\nArgs:\n    variable_name: The name of the environment variable that should contain the path to the configuration file.\n    silent: If True, errors caused by missing environment variables or files will fail silently; otherwise, an exception will be raised.\n\nReturns:\n    bool: True if the configuration was successfully loaded, False otherwise.\n\"\"\"",
                    "method_name": "from_envvar",
                    "second_doc": "\"\"\"\nAttempts to load configuration settings from a file path specified by an environment variable. This approach allows dynamic and environment-specific application configuration, enhancing flexibility in deployment and ease of management. It provides informative feedback if the required environment variable is missing or points to a non-existent file, which helps quickly identify configuration issues.\n\nArgs:\n    variable_name (str): Name of the environment variable that should contain the path to the configuration file.\n    silent (bool): If True, suppresses errors related to missing environment variables or files and returns False instead; if False, raises a RuntimeError when such issues are encountered.\n\nReturns:\n    bool: True if the configuration file is successfully loaded, False if the environment variable is unset or the file cannot be loaded and silent is True.\n\"\"\"",
                    "source_code": "rv = os.environ.get(variable_name)\n        if not rv:\n            if silent:\n                return False\n            raise RuntimeError(\n                f\"The environment variable {variable_name!r} is not set\"\n                \" and as such configuration could not be loaded. Set\"\n                \" this variable and make it point to a configuration\"\n                \" file\"\n            )\n        return self.from_pyfile(rv, silent=silent)"
                },
                {
                    "docstring": "\"\"\"Updates the values in the config from a Python file.  This function\n        behaves as if the file was imported as module with the\n        :meth:`from_object` function.\n\n        :param filename: the filename of the config.  This can either be an\n                         absolute filename or a filename relative to the\n                         root path.\n        :param silent: set to ``True`` if you want silent failure for missing\n                       files.\n\n        .. versionadded:: 0.7\n           `silent` parameter.\n        \"\"\"",
                    "first_doc": "\"\"\"\nUpdates the configuration values from a specified Python file.\n\nThis method loads configuration values by executing the given Python file and updating the current configuration with the variables defined in it, as if the file was imported as a module using the from_object method.\n\nArgs:\n    filename: The name of the configuration file to load. This can be an absolute path or a path relative to the root path of the application.\n    silent: Whether to suppress file not found errors. If True, the method returns False and does not raise an exception if the file does not exist, is a directory, or is not a directory.\n\nReturns:\n    bool: True if the configuration file was successfully loaded, False if the file was not found and silent is True.\n\"\"\"",
                    "method_name": "from_pyfile",
                    "second_doc": "\"\"\"\nLoads configuration settings from a specified Python file and integrates them into the current configuration instance.\n\nThis method executes the target file as Python code, extracts its variables, and merges them into the configuration, allowing updates or overrides of existing settings. Handling configuration this way lets developers easily manage and apply project-specific or environment-specific settings, increasing flexibility and separation of concerns.\n\nArgs:\n    filename (str): The path to the configuration file to load. Can be absolute or relative to the application's root path.\n    silent (bool): If True, suppresses errors for missing files or invalid directories, returning False instead of raising an exception.\n\nReturns:\n    bool: True if the configuration file was successfully loaded; False if the file was not found and 'silent' is True.\n\"\"\"",
                    "source_code": "filename = os.path.join(self.root_path, filename)\n        d = types.ModuleType(\"config\")\n        d.__file__ = filename\n        try:\n            with open(filename, mode=\"rb\") as config_file:\n                exec(compile(config_file.read(), filename, \"exec\"), d.__dict__)\n        except OSError as e:\n            if silent and e.errno in (errno.ENOENT, errno.EISDIR, errno.ENOTDIR):\n                return False\n            e.strerror = f\"Unable to load configuration file ({e.strerror})\"\n            raise\n        self.from_object(d)\n        return True"
                },
                {
                    "docstring": "\"\"\"Updates the values from the given object.  An object can be of one\n        of the following two types:\n\n        -   a string: in this case the object with that name will be imported\n        -   an actual object reference: that object is used directly\n\n        Objects are usually either modules or classes. :meth:`from_object`\n        loads only the uppercase attributes of the module/class. A ``dict``\n        object will not work with :meth:`from_object` because the keys of a\n        ``dict`` are not attributes of the ``dict`` class.\n\n        Example of module-based configuration::\n\n            app.config.from_object('yourapplication.default_config')\n            from yourapplication import default_config\n            app.config.from_object(default_config)\n\n        Nothing is done to the object before loading. If the object is a\n        class and has ``@property`` attributes, it needs to be\n        instantiated before being passed to this method.\n\n        You should not use this function to load the actual configuration but\n        rather configuration defaults.  The actual config should be loaded\n        with :meth:`from_pyfile` and ideally from a location not within the\n        package because the package might be installed system wide.\n\n        See :ref:`config-dev-prod` for an example of class-based configuration\n        using :meth:`from_object`.\n\n        :param obj: an import name or object\n        \"\"\"",
                    "first_doc": "\"\"\"\nUpdates the configuration with uppercase attributes from the provided object.\n\nThis method imports attributes from the specified object into the current configuration. The object can either be a string, in which case it is treated as an import name and imported accordingly, or it can be an actual object reference. Only the uppercase attributes of the object, typically modules or classes, are added to the configuration. Note that dict objects are not supported since their keys are not class attributes.\n\nArgs:\n    obj: The object to load configuration from. Can be either a string representing an import name or an object (such as a module or class) with uppercase attributes.\n\nReturns:\n    None. The method updates the current configuration in-place with the selected attributes from the provided object.\n\"\"\"",
                    "method_name": "from_object",
                    "second_doc": "\"\"\"\nLoads configuration values from an external object, importing each uppercase attribute into the current config.\n\nThis method enables dynamic and modular configuration by pulling relevant settings from a given object or import path. When a string is provided, it imports the referenced object. Then, it traverses the object's attributes and applies all uppercase values\u2014a convention for configuration keys\u2014to the current configuration, ensuring a clear separation of code and settings.\n\nArgs:\n    obj: Either a string import path or a module/class object. Uppercase attributes from this object will be added to the configuration.\n\nReturns:\n    None: The configuration is updated in place with the uppercase attributes from the given object.\n\"\"\"",
                    "source_code": "if isinstance(obj, str):\n            obj = import_string(obj)\n        for key in dir(obj):\n            if key.isupper():\n                self[key] = getattr(obj, key)"
                },
                {
                    "docstring": "\"\"\"Update the values in the config from a file that is loaded\n        using the ``load`` parameter. The loaded data is passed to the\n        :meth:`from_mapping` method.\n\n        .. code-block:: python\n\n            import toml\n            app.config.from_file(\"config.toml\", load=toml.load)\n\n        :param filename: The path to the data file. This can be an\n            absolute path or relative to the config root path.\n        :param load: A callable that takes a file handle and returns a\n            mapping of loaded data from the file.\n        :type load: ``Callable[[Reader], Mapping]`` where ``Reader``\n            implements a ``read`` method.\n        :param silent: Ignore the file if it doesn't exist.\n\n        .. versionadded:: 2.0\n        \"\"\"",
                    "first_doc": "\"\"\"\nUpdates the configuration values from a file using a specified loader function.\n\nThis method loads data from the given file using the provided loader callable, then updates the configuration with that data using the from_mapping method. If the file does not exist and silent is True, the operation is ignored and False is returned.\n\nArgs:\n    filename: The path to the configuration file, either absolute or relative to the configuration root path.\n    load: A callable that accepts a file handle and returns a mapping of loaded data from the file.\n    silent: If True, ignores the file if it does not exist or is a directory.\n\nReturns:\n    The result of the from_mapping method after loading the configuration,\n    or False if the file is not found and silent is True.\n\"\"\"",
                    "method_name": "from_file",
                    "second_doc": "\"\"\"\nLoads configuration data from a specified file using a given loader function, then applies the loaded data to the current configuration instance.\n\nThis method enables dynamic and external management of configuration settings by allowing updates directly from formatted files. By accepting a customizable loader function, it supports a variety of file formats and parsing strategies. The approach also helps gracefully handle missing or invalid files when silent mode is enabled, reducing disruptions during application setup or deployment.\n\nArgs:\n    filename (str): The path to the configuration file to load, joined with the configuration's root path.\n    load (callable): A function that takes an open file object and returns a dictionary of configuration values.\n    silent (bool): If True, avoids raising an error when the file does not exist or is a directory; instead, returns False.\n\nReturns:\n    bool or Any: The result of updating the configuration with the loaded mapping, or False if the file is not found and silent is True.\n\"\"\"",
                    "source_code": "filename = os.path.join(self.root_path, filename)\n\n        try:\n            with open(filename) as f:\n                obj = load(f)\n        except OSError as e:\n            if silent and e.errno in (errno.ENOENT, errno.EISDIR):\n                return False\n\n            e.strerror = f\"Unable to load configuration file ({e.strerror})\"\n            raise\n\n        return self.from_mapping(obj)"
                },
                {
                    "docstring": "\"\"\"Updates the config like :meth:`update` ignoring items with non-upper\n        keys.\n\n        .. versionadded:: 0.11\n        \"\"\"",
                    "first_doc": "\"\"\"\nUpdates the configuration by adding items from a mapping or keyword arguments, ignoring any items whose keys are not uppercase.\n\nArgs:\n    self: The instance of the class.\n\nReturns:\n    bool: True if the configuration was updated.\n\"\"\"",
                    "method_name": "from_mapping",
                    "second_doc": "\"\"\"\nProcesses and updates the configuration by merging key-value pairs from a mapping object or keyword arguments, but only accepts configuration keys that are in uppercase. This ensures that only intended configuration values are set, maintaining clarity and consistency when managing application settings.\n\nArgs:\n    self: The instance of the configuration class.\n    mapping: An optional mapping object containing configuration keys and values, or positional arguments convertible to a mapping.\n    **kwargs: Additional configuration key-value pairs as keyword arguments.\n\nReturns:\n    bool: True if the configuration was updated successfully; otherwise, raises an error for invalid input.\n\"\"\"",
                    "source_code": "mappings = []\n        if len(mapping) == 1:\n            if hasattr(mapping[0], \"items\"):\n                mappings.append(mapping[0].items())\n            else:\n                mappings.append(mapping[0])\n        elif len(mapping) > 1:\n            raise TypeError(\n                f\"expected at most 1 positional argument, got {len(mapping)}\"\n            )\n        mappings.append(kwargs.items())\n        for mapping in mappings:\n            for (key, value) in mapping:\n                if key.isupper():\n                    self[key] = value\n        return True"
                },
                {
                    "docstring": "\"\"\"Returns a dictionary containing a subset of configuration options\n        that match the specified namespace/prefix. Example usage::\n\n            app.config['IMAGE_STORE_TYPE'] = 'fs'\n            app.config['IMAGE_STORE_PATH'] = '/var/app/images'\n            app.config['IMAGE_STORE_BASE_URL'] = 'http://img.website.com'\n            image_store_config = app.config.get_namespace('IMAGE_STORE_')\n\n        The resulting dictionary `image_store_config` would look like::\n\n            {\n                'type': 'fs',\n                'path': '/var/app/images',\n                'base_url': 'http://img.website.com'\n            }\n\n        This is often useful when configuration options map directly to\n        keyword arguments in functions or class constructors.\n\n        :param namespace: a configuration namespace\n        :param lowercase: a flag indicating if the keys of the resulting\n                          dictionary should be lowercase\n        :param trim_namespace: a flag indicating if the keys of the resulting\n                          dictionary should not include the namespace\n\n        .. versionadded:: 0.11\n        \"\"\"",
                    "first_doc": "\"\"\"\nReturns a dictionary containing configuration options that match the specified namespace.\n\nThis method iterates over the current configuration and extracts all key-value pairs where the keys start with the given namespace. Optionally, the keys in the resulting dictionary can be transformed to lowercase and/or have the namespace trimmed from the key name. This is often useful when configuration options are intended to map directly to function or constructor keyword arguments.\n\nArgs:\n    namespace: The configuration namespace (prefix) to filter keys by.\n\nReturns:\n    dict: A dictionary containing matching configuration options, possibly with keys lowercased and/or namespace-trimmed, depending on configuration.\n\"\"\"",
                    "method_name": "get_namespace",
                    "second_doc": "\"\"\"\nExtracts and returns configuration options that share a given namespace prefix from the configuration mapping, optionally modifying their keys.\n\nThis method facilitates organized grouping and retrieval of related settings by filtering configuration items based on a specified prefix. The returned keys can be adjusted for convenience, such as removing the namespace or converting them to lowercase, to support flexible mappings to code constructs like function arguments.\n\nArgs:\n    namespace (str): The string prefix to match against configuration keys.\n    trim_namespace (bool, optional): If True, removes the namespace prefix from the returned keys. Defaults to False.\n    lowercase (bool, optional): If True, converts the returned keys to lowercase. Defaults to False.\n\nReturns:\n    dict: A dictionary of configuration items whose keys start with the given namespace, with optional key transformations.\n\"\"\"",
                    "source_code": "rv = {}\n        for k, v in self.items():\n            if not k.startswith(namespace):\n                continue\n            if trim_namespace:\n                key = k[len(namespace) :]\n            else:\n                key = k\n            if lowercase:\n                key = key.lower()\n            rv[key] = v\n        return rv"
                },
                {
                    "docstring": null,
                    "method_name": "__repr__",
                    "second_doc": "\"\"\"\nReturn a string representation of the configuration object, showing its type and contents.\n\nThis representation is primarily used to support debugging and logging by providing a clear and unambiguous view of the configuration's current state.\n\nReturns:\n    str: A string displaying the class name and the dictionary of configuration values.\n\"\"\"",
                    "source_code": "return f\"<{type(self).__name__} {dict.__repr__(self)}>\""
                }
            ],
            "name": "Config",
            "type": "class"
        }
    ],
    "flask/src/flask/ctx.py": [
        {
            "methods": [
                {
                    "docstring": "\"\"\"Get an attribute by name, or a default value. Like\n        :meth:`dict.get`.\n\n        :param name: Name of attribute to get.\n        :param default: Value to return if the attribute is not present.\n\n        .. versionadded:: 0.10\n        \"\"\"",
                    "first_doc": "\"\"\"\nRetrieves the value of an attribute by its name, returning a default value if the attribute is not found.\n\nArgs:\n    name: The name of the attribute to retrieve.\n\nReturns:\n    The value of the attribute with the specified name if it exists; otherwise, returns None.\n\"\"\"",
                    "method_name": "get",
                    "second_doc": "\"\"\"\nLooks up and returns the value of a named attribute stored on the application context, using an optional default if the attribute is absent. This allows for safe retrieval of dynamic context data without raising errors when the attribute is missing.\n\nArgs:\n    name: The name of the attribute to retrieve.\n    default: The value to return if the attribute does not exist.\n\nReturns:\n    The value associated with the given name if present; otherwise, the provided default value.\n\"\"\"",
                    "source_code": "return self.__dict__.get(name, default)"
                },
                {
                    "docstring": "\"\"\"Get and remove an attribute by name. Like :meth:`dict.pop`.\n\n        :param name: Name of attribute to pop.\n        :param default: Value to return if the attribute is not present,\n            instead of raising a ``KeyError``.\n\n        .. versionadded:: 0.11\n        \"\"\"",
                    "first_doc": "\"\"\"\nRemoves and returns the value of an attribute with the given name from the object.\n\nThis method tries to remove the attribute specified by the given name. If the attribute does not exist, a KeyError is raised unless a default value is provided, in which case the default is returned.\n\nArgs:\n    name: The name of the attribute to remove and return.\n\nReturns:\n    The value of the removed attribute, or the default value if the attribute was not present and a default was specified.\n\nRaises:\n    KeyError: If the attribute does not exist and no default value is provided.\n\"\"\"",
                    "method_name": "pop",
                    "second_doc": "\"\"\"\nRemoves and returns the value of the specified attribute from the object's context storage.\n\nThis method allows for dynamic management of context-specific data by removing a named attribute and returning its value. If the attribute does not exist and a default value is provided, the default is returned instead. If no default is given and the attribute is missing, a KeyError is raised.\n\nArgs:\n    name: The attribute name to be removed and retrieved.\n    default: (optional) A value to return if the attribute is not found.\n\nReturns:\n    The value of the removed attribute, or the default value if specified and the attribute was not present.\n\nRaises:\n    KeyError: If the attribute is not found and no default value is provided.\n\nWhy:\n    This function enables flexible cleanup or retrieval of data bound to the context, helping to manage per-request or per-context variables efficiently and avoid unintended state persistence.\n\"\"\"",
                    "source_code": "if default is _sentinel:\n            return self.__dict__.pop(name)\n        else:\n            return self.__dict__.pop(name, default)"
                },
                {
                    "docstring": "\"\"\"Get the value of an attribute if it is present, otherwise\n        set and return a default value. Like :meth:`dict.setdefault`.\n\n        :param name: Name of attribute to get.\n        :param default: Value to set and return if the attribute is not\n            present.\n\n        .. versionadded:: 0.11\n        \"\"\"",
                    "first_doc": "\"\"\"\nGets the value of the specified attribute if present; otherwise, sets the attribute to a default value and returns it, similar to dict.setdefault.\n\nArgs:\n    name: The name of the attribute to retrieve or set.\n\nReturns:\n    The value of the specified attribute if it exists, or the default value that was set if the attribute was not present.\n\"\"\"",
                    "method_name": "setdefault",
                    "second_doc": "\"\"\"\nRetrieves the value of a given attribute from the application context. If the attribute does not exist, it is initialized with a default value and then returned. This mechanism ensures that required context-specific data is always available when needed during request handling.\n\nArgs:\n    name: The name of the attribute to retrieve or initialize.\n    default: The value to set and return if the attribute does not already exist.\n\nReturns:\n    The existing value of the attribute if present, or the default value if the attribute was not previously set.\n\"\"\"",
                    "source_code": "return self.__dict__.setdefault(name, default)"
                },
                {
                    "docstring": null,
                    "method_name": "__contains__",
                    "second_doc": "\"\"\"\nCheck whether the given item exists in the instance's internal dictionary.\n\nThis method allows users to determine if a particular key has been stored in the request or application context, which is useful for conditional logic and avoiding KeyError exceptions when accessing context data.\n\nArgs:\n    item (str): The key to check for existence in the context.\n\nReturns:\n    bool: True if the key exists in the context, False otherwise.\n\"\"\"",
                    "source_code": "return item in self.__dict__"
                },
                {
                    "docstring": null,
                    "method_name": "__iter__",
                    "second_doc": "\"\"\"\nEnables iteration over all variable names stored in the context global object.\n\nThis allows developers to conveniently access and manage all context-stored data, which is useful for tasks such as debugging, serialization, or dynamic inspection of application state.\n\nReturns:\n    iterator: An iterator over the names of all variables stored in the application context globals.\n\"\"\"",
                    "source_code": "return iter(self.__dict__)"
                },
                {
                    "docstring": null,
                    "method_name": "__repr__",
                    "second_doc": "\"\"\"\nProvide a string representation for the application context globals, reflecting the current application's identity when available. This assists with debugging and logging by clarifying which application context is being referenced.\n\nReturns:\n    str: A descriptive string indicating the application context, or the default object representation if no context is active.\n\"\"\"",
                    "source_code": "top = _app_ctx_stack.top\n        if top is not None:\n            return f\"<flask.g of {top.app.name!r}>\"\n        return object.__repr__(self)"
                }
            ],
            "name": "_AppCtxGlobals",
            "type": "class"
        },
        {
            "details": {
                "docstring": "\"\"\"Executes a function after this request.  This is useful to modify\n    response objects.  The function is passed the response object and has\n    to return the same or a new one.\n\n    Example::\n\n        @app.route('/')\n        def index():\n            @after_this_request\n            def add_header(response):\n                response.headers['X-Foo'] = 'Parachute'\n                return response\n            return 'Hello World!'\n\n    This is more useful if a function other than the view function wants to\n    modify a response.  For instance think of a decorator that wants to add\n    some headers without converting the return value into a response object.\n\n    .. versionadded:: 0.9\n    \"\"\"",
                "first_doc": "\"\"\"\nRegisters a function to be called after the current request is completed.\n\nAppends the provided function to the list of functions to be executed after the current request finishes processing.\n\nArgs:\n    f: The function to register as an after-request handler for the current request.\n\nReturns:\n    The function 'f' that was registered.\n\"\"\"",
                "method_name": "after_this_request",
                "second_doc": "\"\"\"\nRegisters a function to be executed after the current request completes processing, allowing for actions such as cleanup or response modification to occur once the response is ready.\n\nArgs:\n    f: The function to execute after the current request has been processed.\n\nReturns:\n    The same function 'f' that was registered for post-request handling.\n\"\"\"",
                "source_code": "_request_ctx_stack.top._after_request_functions.append(f)\n    return f"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": "\"\"\"A helper function that decorates a function to retain the current\n    request context.  This is useful when working with greenlets.  The moment\n    the function is decorated a copy of the request context is created and\n    then pushed when the function is called.  The current session is also\n    included in the copied request context.\n\n    Example::\n\n        import gevent\n        from flask import copy_current_request_context\n\n        @app.route('/')\n        def index():\n            @copy_current_request_context\n            def do_some_work():\n                # do some work here, it can access flask.request or\n                # flask.session like you would otherwise in the view function.\n                ...\n            gevent.spawn(do_some_work)\n            return 'Regular response'\n\n    .. versionadded:: 0.10\n    \"\"\"",
                "first_doc": "\"\"\"\nCopies the current request context and ensures it is active during the execution of the decorated function.\n\nArgs:\n    f: The function to be decorated so that it executes with the copied request context.\n\nReturns:\n    A wrapped version of the original function that runs with the copied request context active.\n\"\"\"",
                "method_name": "copy_current_request_context",
                "second_doc": "\"\"\"\nEnsures that the decorated function runs with a preserved snapshot of the current request context, even when executed outside the typical request-handling flow. This allows asynchronous or background operations to access context-bound data as if they were running within the original request.\n\nArgs:\n    f (callable): The function to decorate so that it executes with the copied request context.\n\nReturns:\n    callable: A wrapped version of the input function that, when called, activates the preserved request context during its execution.\n\nRaises:\n    RuntimeError: If used outside the scope of an active request context.\n\"\"\"",
                "source_code": "top = _request_ctx_stack.top\n    if top is None:\n        raise RuntimeError(\n            \"This decorator can only be used at local scopes \"\n            \"when a request context is on the stack.  For instance within \"\n            \"view functions.\"\n        )\n    reqctx = top.copy()\n\n    def wrapper(*args, **kwargs):\n        with reqctx:\n            return f(*args, **kwargs)\n\n    return update_wrapper(wrapper, f)"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": "\"\"\"If you have code that wants to test if a request context is there or\n    not this function can be used.  For instance, you may want to take advantage\n    of request information if the request object is available, but fail\n    silently if it is unavailable.\n\n    ::\n\n        class User(db.Model):\n\n            def __init__(self, username, remote_addr=None):\n                self.username = username\n                if remote_addr is None and has_request_context():\n                    remote_addr = request.remote_addr\n                self.remote_addr = remote_addr\n\n    Alternatively you can also just test any of the context bound objects\n    (such as :class:`request` or :class:`g`) for truthness::\n\n        class User(db.Model):\n\n            def __init__(self, username, remote_addr=None):\n                self.username = username\n                if remote_addr is None and request:\n                    remote_addr = request.remote_addr\n                self.remote_addr = remote_addr\n\n    .. versionadded:: 0.7\n    \"\"\"",
                "first_doc": "\"\"\"\nChecks whether a request context is currently active.\n\nReturns:\n    bool: True if a request context is active on the context stack, False otherwise.\n\"\"\"",
                "method_name": "has_request_context",
                "second_doc": "\"\"\"\nDetermines if the current code is running within the scope of an active request, ensuring that operations dependent on request-specific data are only performed when appropriate.\n\nArgs:\n    None\n\nReturns:\n    bool: True if the current execution context has an active HTTP request (i.e., a request context exists on the context stack), False otherwise.\n\"\"\"",
                "source_code": "return _request_ctx_stack.top is not None"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": "\"\"\"Works like :func:`has_request_context` but for the application\n    context.  You can also just do a boolean check on the\n    :data:`current_app` object instead.\n\n    .. versionadded:: 0.9\n    \"\"\"",
                "first_doc": "\"\"\"\nChecks whether an application context is currently active.\n\nReturns:\n    bool: True if an application context is active, False otherwise.\n\"\"\"",
                "method_name": "has_app_context",
                "second_doc": "\"\"\"\nDetermines if the current code is running within an active application context.\nThis is necessary to avoid context-related errors when accessing resources or performing operations that depend on the application's state.\n\nArgs:\n    None\n\nReturns:\n    bool: True if code execution is within an active application context, otherwise False.\n\"\"\"",
                "source_code": "return _app_ctx_stack.top is not None"
            },
            "type": "function"
        },
        {
            "methods": [
                {
                    "docstring": null,
                    "method_name": "__init__",
                    "second_doc": "\"\"\"\nInitializes the application context by associating it with the provided application, setting up URL routing capabilities, and preparing context-local global storage. This sets the groundwork for managing resources and contextual data specific to the application's lifetime outside of any particular request, enabling consistent access to shared information during background tasks or CLI commands.\n\nArgs:\n    app: The Flask application instance used to initialize the context and its resources.\n\nReturns:\n    None\n\"\"\"",
                    "source_code": "self.app = app\n        self.url_adapter = app.create_url_adapter(None)\n        self.g = app.app_ctx_globals_class()\n\n        # Like request context, app contexts can be pushed multiple times\n        # but there a basic \"refcount\" is enough to track them.\n        self._refcnt = 0"
                },
                {
                    "docstring": "\"\"\"Binds the app context to the current context.\"\"\"",
                    "first_doc": "\"\"\"\nBinds the app context to the current context.\n\nIncrements the app context reference count, pushes the context onto the stack, and sends a signal indicating that the app context has been pushed.\n\nArgs:\n    self: The app context instance.\n\nReturns:\n    None: This method does not return a value.\n\"\"\"",
                    "method_name": "push",
                    "second_doc": "\"\"\"\nEstablishes the current application context for request handling and resource management.\n\nThis method increases the internal reference count for the application context, places it on the context stack to ensure correct operation within nested or concurrent requests, and signals other components that a new application context is now active. These actions guarantee that resources, configurations, and request-bound objects are accessible whenever needed during a request lifecycle.\n\nArgs:\n    self: The application context instance to be activated.\n\nReturns:\n    None\n\"\"\"",
                    "source_code": "self._refcnt += 1\n        _app_ctx_stack.push(self)\n        appcontext_pushed.send(self.app)"
                },
                {
                    "docstring": "\"\"\"Pops the app context.\"\"\"",
                    "first_doc": "\"\"\"\nRemoves (pops) the application context from the context stack and triggers any necessary teardown operations.\n\nArgs:\n    self: The instance of the class on which this method is called.\n\nReturns:\n    None. The method performs side effects such as updating the context stack, triggering teardown callbacks, and sending the appcontext_popped signal.\n\"\"\"",
                    "method_name": "pop",
                    "second_doc": "\"\"\"\nSafely removes the current application context from the stack, ensuring that any associated teardown routines are executed.\n\nThis method is essential for managing resource cleanup and maintaining the correct lifecycle of an application's context after request handling or other context-dependent operations.\n\nArgs:\n    self: The AppContext instance being removed from the context stack.\n\nReturns:\n    None. Performs side effects such as decrementing the reference count, triggering teardown callbacks for resource cleanup, verifying correct context removal, and emitting a signal after the context is popped.\n\"\"\"",
                    "source_code": "try:\n            self._refcnt -= 1\n            if self._refcnt <= 0:\n                if exc is _sentinel:\n                    exc = sys.exc_info()[1]\n                self.app.do_teardown_appcontext(exc)\n        finally:\n            rv = _app_ctx_stack.pop()\n        assert rv is self, f\"Popped wrong app context.  ({rv!r} instead of {self!r})\"\n        appcontext_popped.send(self.app)"
                },
                {
                    "docstring": null,
                    "method_name": "__enter__",
                    "second_doc": "\"\"\"\nEnters the application context, making the current application accessible for the duration of the context block.\n\nThis enables operations that require application-specific data and resources to be performed in a controlled and isolated environment.\n\nReturns:\n    AppContext: The application context instance, allowing use with 'with' statements for automatic context management.\n\"\"\"",
                    "source_code": "self.push()\n        return self"
                },
                {
                    "docstring": null,
                    "method_name": "__exit__",
                    "second_doc": "\"\"\"\nHandles cleanup of the application context when exiting a with-statement block or when the context is no longer needed.\n\nArgs:\n    exc_type (Optional[Type[BaseException]]): The exception type if an exception caused the context to exit, otherwise None.\n    exc_value (Optional[BaseException]): The exception instance if an exception caused the context to exit, otherwise None.\n    traceback (Optional[TracebackType]): The traceback if an exception caused the context to exit, otherwise None.\n\nReturns:\n    None\n\nWhy:\n    This method ensures that application-specific resources and configurations are properly unwound and detached when the context is exited, thereby preventing resource leaks and maintaining correct application state management.\n\"\"\"",
                    "source_code": "self.pop(exc_value)"
                }
            ],
            "name": "AppContext",
            "type": "class"
        },
        {
            "methods": [
                {
                    "docstring": null,
                    "method_name": "__init__",
                    "second_doc": "\"\"\"\nInitializes the request context for a web application, associating the current request, session, application context stack, and response handlers.\n\nArgs:\n    app: The web application instance to associate with the request context.\n    environ: The WSGI environment dictionary containing request data.\n    request: An optional pre-constructed request object; if not provided, one will be created using the environment.\n    session: The session object to be used for the request.\n\nReturns:\n    None\n\nWhy:\n    This method prepares all necessary state and hooks needed to manage the lifecycle and data of an individual web request. By setting up routing, session, request context stack, and after-request functions, it ensures that each request is handled in isolation with proper context management, supporting features such as URL matching and response post-processing.\n\"\"\"",
                    "source_code": "self.app = app\n        if request is None:\n            request = app.request_class(environ)\n        self.request = request\n        self.url_adapter = None\n        try:\n            self.url_adapter = app.create_url_adapter(self.request)\n        except HTTPException as e:\n            self.request.routing_exception = e\n        self.flashes = None\n        self.session = session\n\n        # Request contexts can be pushed multiple times and interleaved with\n        # other request contexts.  Now only if the last level is popped we\n        # get rid of them.  Additionally if an application context is missing\n        # one is created implicitly so for each level we add this information\n        self._implicit_app_ctx_stack = []\n\n        # indicator if the context was preserved.  Next time another context\n        # is pushed the preserved context is popped.\n        self.preserved = False\n\n        # remembers the exception for pop if there is one in case the context\n        # preservation kicks in.\n        self._preserved_exc = None\n\n        # Functions that should be executed after the request on the response\n        # object.  These will be called before the regular \"after_request\"\n        # functions.\n        self._after_request_functions = []"
                },
                {
                    "docstring": null,
                    "method_name": "g",
                    "second_doc": "\"\"\"\nProvides access to a general-purpose namespace object for storing data during the active request context.\n\nThis property allows storing and sharing data throughout a request lifecycle without polluting global state.\n\nReturns:\n    flask.g: The namespace object tied to the current request context, enabling temporary data storage across app functionality.\n\"\"\"",
                    "source_code": "return _app_ctx_stack.top.g"
                },
                {
                    "docstring": null,
                    "method_name": "g",
                    "second_doc": "\"\"\"\nAccesses or sets the general-purpose data storage (the 'g' object) associated with the current application context.\n\nThis method allows components to share or keep request-specific variables as the application processes a request. It helps track and manage data throughout the lifespan of the request, enabling different parts of the application to access shared, temporary information as needed.\n\nArgs:\n    value: The value to assign to the app context's 'g' attribute.\n\nReturns:\n    None\n\"\"\"",
                    "source_code": "_app_ctx_stack.top.g = value"
                },
                {
                    "docstring": "\"\"\"Creates a copy of this request context with the same request object.\n        This can be used to move a request context to a different greenlet.\n        Because the actual request object is the same this cannot be used to\n        move a request context to a different thread unless access to the\n        request object is locked.\n\n        .. versionadded:: 0.10\n\n        .. versionchanged:: 1.1\n           The current session object is used instead of reloading the original\n           data. This prevents `flask.session` pointing to an out-of-date object.\n        \"\"\"",
                    "first_doc": "\"\"\"\nCreates a copy of the current request context with the same request object.\n\nThis method is useful for moving a request context to a different greenlet. The request object remains the same in the copied context; therefore, this method should not be used to move the context to a different thread unless access to the request object is properly locked. When copying, the current session object is preserved to prevent inconsistencies.\n\nArgs:\n    self: The current instance of the request context.\n\nReturns:\n    A new instance of the request context class, preserving the same app, request, environ, and session objects as the current context.\n\"\"\"",
                    "method_name": "copy",
                    "second_doc": "\"\"\"\nCreates and returns a new request context instance that mirrors the current context, preserving the same application, environment, request, and session objects.\n\nThis functionality enables the current context to be replicated as needed\u2014such as when concurrent or asynchronous operations require isolated yet equivalent context information without interference. By duplicating the context, consistency is maintained across different execution scopes in the application.\n\nArgs:\n    self: The existing request context instance to be copied.\n\nReturns:\n    A new instance of the request context, initialized with references to the same app, request, environ, and session objects as the original context.\n\"\"\"",
                    "source_code": "return self.__class__(\n            self.app,\n            environ=self.request.environ,\n            request=self.request,\n            session=self.session,\n        )"
                },
                {
                    "docstring": "\"\"\"Can be overridden by a subclass to hook into the matching\n        of the request.\n        \"\"\"",
                    "first_doc": "\"\"\"\nHooks into the process of matching the current request to a URL rule.\n\nThis method attempts to match the incoming request using the URL adapter and assigns the matched URL rule and view arguments to the request. If an HTTP exception occurs during matching, it attaches the exception to the request for further handling.\n\nArgs:\n    self: The instance of the class.\n\nReturns:\n    None: This method does not return a value. The result is stored in the request object as attributes.\n\"\"\"",
                    "method_name": "match_request",
                    "second_doc": "\"\"\"\nAttempts to resolve the current HTTP request to a route handler by using the configured URL adapter.\n\nBy performing this matching process, the method determines which logic should respond to the request and extracts any relevant parameters from the URL. If matching fails due to an HTTP error, the exception is stored with the request for error handling. This ensures that each incoming request can be correctly routed or managed according to application logic.\n\nArgs:\n    self: Instance of the RequestContext containing the URL adapter and request.\n\nReturns:\n    None: Modifies the request object in-place by setting url_rule, view_args, or routing_exception depending on the outcome of URL matching.\n\"\"\"",
                    "source_code": "try:\n            result = self.url_adapter.match(return_rule=True)\n            self.request.url_rule, self.request.view_args = result\n        except HTTPException as e:\n            self.request.routing_exception = e"
                },
                {
                    "docstring": "\"\"\"Binds the request context to the current context.\"\"\"",
                    "first_doc": "\"\"\"\nBinds the request context to the current thread context, ensuring that the application and session context are properly managed.\n\nArgs:\n    self: The instance of the request context being pushed.\n\nReturns:\n    None: This method does not return a value.\n\"\"\"",
                    "method_name": "push",
                    "second_doc": "\"\"\"\nPrepares and manages the request context for the current thread, handling transitions and cleanup to avoid conflicts or memory leaks from previous or incomplete contexts. By ensuring the correct application and session contexts are associated with each request, this method maintains proper isolation and state management for concurrent or successive requests.\n\nArgs:\n    self: The instance of the request context being pushed, representing the current HTTP request and its associated state.\n\nReturns:\n    None: The method performs context setup but does not return a value.\n\"\"\"",
                    "source_code": "# If an exception occurs in debug mode or if context preservation is\n        # activated under exception situations exactly one context stays\n        # on the stack.  The rationale is that you want to access that\n        # information under debug situations.  However if someone forgets to\n        # pop that context again we want to make sure that on the next push\n        # it's invalidated, otherwise we run at risk that something leaks\n        # memory.  This is usually only a problem in test suite since this\n        # functionality is not active in production environments.\n        top = _request_ctx_stack.top\n        if top is not None and top.preserved:\n            top.pop(top._preserved_exc)\n\n        # Before we push the request context we have to ensure that there\n        # is an application context.\n        app_ctx = _app_ctx_stack.top\n        if app_ctx is None or app_ctx.app != self.app:\n            app_ctx = self.app.app_context()\n            app_ctx.push()\n            self._implicit_app_ctx_stack.append(app_ctx)\n        else:\n            self._implicit_app_ctx_stack.append(None)\n\n        _request_ctx_stack.push(self)\n\n        # Open the session at the moment that the request context is available.\n        # This allows a custom open_session method to use the request context.\n        # Only open a new session if this is the first time the request was\n        # pushed, otherwise stream_with_context loses the session.\n        if self.session is None:\n            session_interface = self.app.session_interface\n            self.session = session_interface.open_session(self.app, self.request)\n\n            if self.session is None:\n                self.session = session_interface.make_null_session(self.app)\n\n        if self.url_adapter is not None:\n            self.match_request()"
                },
                {
                    "docstring": "\"\"\"Pops the request context and unbinds it by doing that.  This will\n        also trigger the execution of functions registered by the\n        :meth:`~flask.Flask.teardown_request` decorator.\n\n        .. versionchanged:: 0.9\n           Added the `exc` argument.\n        \"\"\"",
                    "first_doc": "\"\"\"\nRemoves the current request context from the stack, unbinding it and performing necessary teardown operations.\n\nThis method triggers the execution of functions registered by the Flask `teardown_request` decorator and ensures clean-up of the request and application context, including closing the request object if possible and removing references to avoid circular dependencies.\n\nArgs:\n    self: The RequestContext instance on which this method is called.\n\nReturns:\n    None: This method does not return a value. It performs side-effects related to context management and resource cleanup.\n\"\"\"",
                    "method_name": "pop",
                    "second_doc": "\"\"\"\nCleans up and finalizes the current request context by unbinding it from the stack and ensuring all registered teardown functions are called. This guarantees that resources associated with the request are released, background operations complete, and references are removed to avoid memory leaks or dependency issues.\n\nThis method is necessary to enforce correct isolation and cleanup between separate web requests, preventing stale request data from persisting and ensuring the application remains responsive and efficient.\n\nArgs:\n    self: The RequestContext instance whose context and resources are being cleaned up.\n    exc (optional): The exception, if any, that occurred during the request. Defaults to a sentinel value indicating no exception.\n\nReturns:\n    None: This method only performs side-effects related to request and application context management and does not return a value.\n\"\"\"",
                    "source_code": "app_ctx = self._implicit_app_ctx_stack.pop()\n        clear_request = False\n\n        try:\n            if not self._implicit_app_ctx_stack:\n                self.preserved = False\n                self._preserved_exc = None\n                if exc is _sentinel:\n                    exc = sys.exc_info()[1]\n                self.app.do_teardown_request(exc)\n\n                request_close = getattr(self.request, \"close\", None)\n                if request_close is not None:\n                    request_close()\n                clear_request = True\n        finally:\n            rv = _request_ctx_stack.pop()\n\n            # get rid of circular dependencies at the end of the request\n            # so that we don't require the GC to be active.\n            if clear_request:\n                rv.request.environ[\"werkzeug.request\"] = None\n\n            # Get rid of the app as well if necessary.\n            if app_ctx is not None:\n                app_ctx.pop(exc)\n\n            assert (\n                rv is self\n            ), f\"Popped wrong request context. ({rv!r} instead of {self!r})\""
                },
                {
                    "docstring": null,
                    "method_name": "auto_pop",
                    "second_doc": "\"\"\"\nDetermines whether to preserve the current request context or remove it based on environment and exception state. This ensures proper management of the request lifecycle, maintaining context when necessary (such as during debugging or exception handling), and cleaning up resources otherwise.\n\nArgs:\n    exc (Exception or None): The exception that was raised, if any.\n\nReturns:\n    None\n\"\"\"",
                    "source_code": "if self.request.environ.get(\"flask._preserve_context\") or (\n            exc is not None and self.app.preserve_context_on_exception\n        ):\n            self.preserved = True\n            self._preserved_exc = exc\n        else:\n            self.pop(exc)"
                },
                {
                    "docstring": null,
                    "method_name": "__enter__",
                    "second_doc": "\"\"\"\nEnters the request context, making it active for the current thread or process.\n\nThis method enables the management and isolation of request-specific data by pushing the context onto the context stack, ensuring that the application logic operates within the correct scope.\n\nReturns:\n    RequestContext: The current request context instance to allow usage as a context manager.\n\"\"\"",
                    "source_code": "self.push()\n        return self"
                },
                {
                    "docstring": null,
                    "method_name": "__exit__",
                    "second_doc": "\"\"\"\nHandles the cleanup of the request context when exiting a context manager block.\n\nThis method ensures that resources tied to the request context are properly released and the context stack is managed correctly to prevent memory leaks and maintain application stability.\n\nArgs:\n    exc_type (type): The exception type if raised within the context, otherwise None.\n    exc_value (Exception): The exception instance if raised, otherwise None.\n    tb (traceback): The traceback object if an exception occurred, otherwise None.\n\nReturns:\n    None\n\"\"\"",
                    "source_code": "self.auto_pop(exc_value)"
                },
                {
                    "docstring": null,
                    "method_name": "__repr__",
                    "second_doc": "\"\"\"\nReturn a string representation of the request context for debugging and logging purposes.\n\nArgs:\n    self: The instance of the RequestContext containing the current request and app information.\n\nReturns:\n    str: A concise string summarizing the context, including the request URL, HTTP method, and the associated application name. This helps developers quickly identify and differentiate request contexts during development or troubleshooting.\n\"\"\"",
                    "source_code": "return (\n            f\"<{type(self).__name__} {self.request.url!r}\"\n            f\" [{self.request.method}] of {self.app.name}>\"\n        )"
                }
            ],
            "name": "RequestContext",
            "type": "class"
        }
    ],
    "flask/src/flask/debughelpers.py": [
        {
            "methods": [],
            "name": "UnexpectedUnicodeError",
            "type": "class"
        },
        {
            "methods": [
                {
                    "docstring": null,
                    "method_name": "__init__",
                    "second_doc": "\"\"\"\nInitializes a descriptive error message when a requested file key is not found in the uploaded files of an HTTP request, often due to incorrect form encoding.\n\nArgs:\n    key (str): The name of the file field being accessed.\n    request (Request): The HTTP request object containing form and file data.\n\nReturns:\n    None: This constructor initializes an instance and sets an error message explaining why the file was not accessible.\n    \nWhy:\n    This process helps developers quickly identify misconfigurations or client-side mistakes (like missing or incorrect form encoding) that prevent expected file uploads, facilitating troubleshooting and user feedback.\n\"\"\"",
                    "source_code": "form_matches = request.form.getlist(key)\n        buf = [\n            f\"You tried to access the file {key!r} in the request.files\"\n            \" dictionary but it does not exist. The mimetype for the\"\n            f\" request is {request.mimetype!r} instead of\"\n            \" 'multipart/form-data' which means that no file contents\"\n            \" were transmitted. To fix this error you should provide\"\n            ' enctype=\"multipart/form-data\" in your form.'\n        ]\n        if form_matches:\n            names = \", \".join(repr(x) for x in form_matches)\n            buf.append(\n                \"\\n\\nThe browser instead transmitted some file names. \"\n                f\"This was submitted: {names}\"\n            )\n        self.msg = \"\".join(buf)"
                },
                {
                    "docstring": null,
                    "method_name": "__str__",
                    "second_doc": "\"\"\"\nReturn the error message associated with this exception.\n\nReturns:\n    str: The message describing the specific key error encountered during debugging.\n\nThis method provides a clear and informative error message to help developers identify and resolve issues when accessing certain debug files, facilitating easier troubleshooting during development.\n\"\"\"",
                    "source_code": "return self.msg"
                }
            ],
            "name": "DebugFilesKeyError",
            "type": "class"
        },
        {
            "methods": [
                {
                    "docstring": null,
                    "method_name": "__init__",
                    "second_doc": "\"\"\"\nInitializes an AssertionError when an HTTP routing redirect occurs, especially for requests with form data, and provides a detailed explanation to aid debugging and prevent unintentional data loss during automatic redirects.\n\nArgs:\n    request: The request object that triggered the routing exception and redirect.\n\nReturns:\n    None; initializes the error with an informative message to help developers understand and resolve issues related to automatic routing redirects.\n\"\"\"",
                    "source_code": "exc = request.routing_exception\n        buf = [\n            f\"A request was sent to this URL ({request.url}) but a\"\n            \" redirect was issued automatically by the routing system\"\n            f\" to {exc.new_url!r}.\"\n        ]\n\n        # In case just a slash was appended we can be extra helpful\n        if f\"{request.base_url}/\" == exc.new_url.split(\"?\")[0]:\n            buf.append(\n                \"  The URL was defined with a trailing slash so Flask\"\n                \" will automatically redirect to the URL with the\"\n                \" trailing slash if it was accessed without one.\"\n            )\n\n        buf.append(\n            \"  Make sure to directly send your\"\n            f\" {request.method}-request to this URL since we can't make\"\n            \" browsers or HTTP clients redirect with form data reliably\"\n            \" or without user interaction.\"\n        )\n        buf.append(\"\\n\\nNote: this exception is only raised in debug mode\")\n        AssertionError.__init__(self, \"\".join(buf).encode(\"utf-8\"))"
                }
            ],
            "name": "FormDataRoutingRedirect",
            "type": "class"
        },
        {
            "details": {
                "docstring": "\"\"\"Since Flask 0.8 we're monkeypatching the files object in case a\n    request is detected that does not use multipart form data but the files\n    object is accessed.\n    \"\"\"",
                "first_doc": "\"\"\"\nAttaches a custom MultiDict subclass to handle encoding type errors in file uploads.\n\nThis method replaces the class of `request.files` with a subclass that intercepts missing file keys. If a requested file is not found but exists in the form data, it raises a custom `DebugFilesKeyError` to provide a more informative error message.\n\nArgs:\n    request: The Request object containing `files` and `form` attributes to be patched.\n\nReturns:\n    None. The function modifies `request.files` in place.\n\"\"\"",
                "method_name": "attach_enctype_error_multidict",
                "second_doc": "\"\"\"\nEnhances error reporting for file uploads when form encoding issues occur.\n\nBy wrapping the `request.files` multidict with a custom subclass, this method ensures that if a file is requested but missing, and its key is present in the form data, a specialized error (`DebugFilesKeyError`) is raised. This provides clearer feedback during file processing, supporting easier debugging and improving developer understanding of upload-related errors. Such enhanced error handling helps in diagnosing issues where files are not transmitted correctly due to misconfigured requests or form submissions.\n\nArgs:\n    request: The Request object whose `files` attribute will be subclassed for improved error handling.\n\nReturns:\n    None. Modifies `request.files` in-place to use the augmented error-checking subclass.\n\"\"\"",
                "source_code": "oldcls = request.files.__class__\n\n    class newcls(oldcls):\n        def __getitem__(self, key):\n            try:\n                return oldcls.__getitem__(self, key)\n            except KeyError:\n                if key not in request.form:\n                    raise\n                raise DebugFilesKeyError(request, key)\n\n    newcls.__name__ = oldcls.__name__\n    newcls.__module__ = oldcls.__module__\n    request.files.__class__ = newcls"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "_dump_loader_info",
                "second_doc": "\"\"\"\nYields a textual summary of a loader's public attributes, focusing on serializable configuration states and class identity.\n\nArgs:\n    loader: The object whose details are to be formatted and yielded.\n\nYields:\n    str: Lines describing the class and selected public attributes of the loader, organized for readability.\n\nWhy:\n    This method systematically extracts and presents key information about a loader object's state and configuration, facilitating easier introspection, debugging, and documentation during application development.\n\"\"\"",
                "source_code": "yield f\"class: {type(loader).__module__}.{type(loader).__name__}\"\n    for key, value in sorted(loader.__dict__.items()):\n        if key.startswith(\"_\"):\n            continue\n        if isinstance(value, (tuple, list)):\n            if not all(isinstance(x, str) for x in value):\n                continue\n            yield f\"{key}:\"\n            for item in value:\n                yield f\"  - {item}\"\n            continue\n        elif not isinstance(value, (str, int, float, bool)):\n            continue\n        yield f\"{key}: {value!r}\""
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": "\"\"\"This should help developers understand what failed\"\"\"",
                "first_doc": "\"\"\"\nLogs the process and results of attempts to locate a template in a Flask application.\n\nThis method examines all given template loading attempts and logs detailed information about each attempt, including where the loader is from, whether a template was found, and relevant advice if the lookup seems suspicious or ambiguous.\n\nArgs:\n    app: The Flask application instance whose logger is used to record the results.\n    template: The name of the template being searched for.\n    attempts: A list of tuples, each containing a loader, its source object, and a triple describing the attempted load/result.\n\nReturns:\n    None. The method logs information to the application's logger and does not return a value.\n\"\"\"",
                "method_name": "explain_template_loading_attempts",
                "second_doc": "\"\"\"\nAnalyzes and logs the details and outcomes of searching for a template in a web application, helping to identify potential issues with template discovery and organization.\n\nThis method iterates through each attempt to load a specified template using different loaders and sources, documents their origins, the results of each search, and provides suggestions if no template is found or if multiple matches occur. This thorough logging assists developers in debugging template loading issues by making the lookup process transparent.\n\nArgs:\n    app: The Flask application instance whose logger records the information.\n    template: The name of the template being searched for.\n    attempts: A list of tuples, each including a loader, its source object, and a result triple describing the attempt outcome.\n\nReturns:\n    None: The method's sole purpose is to log information; it does not return a value.\n\"\"\"",
                "source_code": "info = [f\"Locating template {template!r}:\"]\n    total_found = 0\n    blueprint = None\n    reqctx = _request_ctx_stack.top\n    if reqctx is not None and reqctx.request.blueprint is not None:\n        blueprint = reqctx.request.blueprint\n\n    for idx, (loader, srcobj, triple) in enumerate(attempts):\n        if isinstance(srcobj, Flask):\n            src_info = f\"application {srcobj.import_name!r}\"\n        elif isinstance(srcobj, Blueprint):\n            src_info = f\"blueprint {srcobj.name!r} ({srcobj.import_name})\"\n        else:\n            src_info = repr(srcobj)\n\n        info.append(f\"{idx + 1:5}: trying loader of {src_info}\")\n\n        for line in _dump_loader_info(loader):\n            info.append(f\"       {line}\")\n\n        if triple is None:\n            detail = \"no match\"\n        else:\n            detail = f\"found ({triple[1] or '<string>'!r})\"\n            total_found += 1\n        info.append(f\"       -> {detail}\")\n\n    seems_fishy = False\n    if total_found == 0:\n        info.append(\"Error: the template could not be found.\")\n        seems_fishy = True\n    elif total_found > 1:\n        info.append(\"Warning: multiple loaders returned a match for the template.\")\n        seems_fishy = True\n\n    if blueprint is not None and seems_fishy:\n        info.append(\n            \"  The template was looked up from an endpoint that belongs\"\n            f\" to the blueprint {blueprint!r}.\"\n        )\n        info.append(\"  Maybe you did not place a template in the right folder?\")\n        info.append(\"  See https://flask.palletsprojects.com/blueprints/#templates\")\n\n    app.logger.info(\"\\n\".join(info))"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "explain_ignored_app_run",
                "second_doc": "\"\"\"\nIssues a warning when app.run() is called from the Flask command line executable, indicating that this invocation is being ignored to prevent unintended behavior during command-based application management.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "if os.environ.get(\"WERKZEUG_RUN_MAIN\") != \"true\":\n        warn(\n            Warning(\n                \"Silently ignoring app.run() because the application is\"\n                \" run from the flask command line executable. Consider\"\n                ' putting app.run() behind an if __name__ == \"__main__\"'\n                \" guard to silence this warning.\"\n            ),\n            stacklevel=3,\n        )"
            },
            "type": "function"
        }
    ],
    "flask/src/flask/globals.py": [
        {
            "details": {
                "docstring": null,
                "method_name": "_lookup_req_object",
                "second_doc": "\"\"\"\nRetrieves a specific attribute from the current request context object for the active application.\n\nThis method enables access to objects tied to the ongoing request, ensuring each HTTP request gets isolated and the appropriate context-bound data is fetched. This is essential for maintaining correct request handling and data integrity within a multi-request environment.\n\nArgs:\n    name (str): The name of the attribute to retrieve from the current request context.\n\nReturns:\n    Any: The value of the requested attribute from the request context.\n\nRaises:\n    RuntimeError: If there is no active request context available.\n\"\"\"",
                "source_code": "top = _request_ctx_stack.top\n    if top is None:\n        raise RuntimeError(_request_ctx_err_msg)\n    return getattr(top, name)"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "_lookup_app_object",
                "second_doc": "\"\"\"\nRetrieves an attribute from the top of the application context stack.\n\nThis method ensures access to context-specific resources or configuration by fetching a named attribute from the current top application context. It raises an error if no application context is active, preventing operations depending on unavailable context.\n\nArgs:\n    name (str): The name of the attribute to retrieve from the application context.\n\nReturns:\n    Any: The value of the requested attribute from the current application context.\n\nRaises:\n    RuntimeError: If there is no active application context.\n\"\"\"",
                "source_code": "top = _app_ctx_stack.top\n    if top is None:\n        raise RuntimeError(_app_ctx_err_msg)\n    return getattr(top, name)"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "_find_app",
                "second_doc": "\"\"\"\nRetrieves the current application instance from the context stack.\n\nThis method ensures that operations depending on the presence of an active application context have access to the relevant application object. By enforcing this context check, it helps maintain correct application behavior and prevents misuse outside of request or application lifecycle scopes.\n\nArgs:\n    None\n\nReturns:\n    Flask: The application instance associated with the current context.\n\nRaises:\n    RuntimeError: If no application context is active, indicating that the method was called outside of an appropriate context.\n\"\"\"",
                "source_code": "top = _app_ctx_stack.top\n    if top is None:\n        raise RuntimeError(_app_ctx_err_msg)\n    return top.app"
            },
            "type": "function"
        }
    ],
    "flask/src/flask/helpers.py": [
        {
            "details": {
                "docstring": "\"\"\"Get the environment the app is running in, indicated by the\n    :envvar:`FLASK_ENV` environment variable. The default is\n    ``'production'``.\n    \"\"\"",
                "first_doc": "\"\"\"\nRetrieves the current Flask environment setting.\n\nChecks the value of the \"FLASK_ENV\" environment variable and returns it if set; otherwise, defaults to \"production\".\n\nReturns:\n    str: The current Flask environment (\"development\", \"production\", etc.).\n\"\"\"",
                "method_name": "get_env",
                "second_doc": "\"\"\"\nDetermines and returns the application's runtime environment setting.\n\nThis method checks the \"FLASK_ENV\" environment variable to identify whether the application should run in a specific mode, enhancing control over configuration and behavior. If the variable is not set, it falls back to \"production\" to ensure a secure default operation.\n\nArgs:\n    None\n\nReturns:\n    str: The environment name specified by \"FLASK_ENV\" (e.g., \"development\", \"production\"); defaults to \"production\" if unset.\n\"\"\"",
                "source_code": "return os.environ.get(\"FLASK_ENV\") or \"production\""
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": "\"\"\"Get whether debug mode should be enabled for the app, indicated\n    by the :envvar:`FLASK_DEBUG` environment variable. The default is\n    ``True`` if :func:`.get_env` returns ``'development'``, or ``False``\n    otherwise.\n    \"\"\"",
                "first_doc": "\"\"\"\nDetermines whether the debug mode should be enabled.\n\nThis method checks the FLASK_DEBUG environment variable to decide if debug mode is active. If the variable is not set, it falls back to checking if the environment is set to \"development\" as determined by the get_env() function.\n\nReturns:\n    bool: True if debug mode should be enabled, False otherwise.\n\"\"\"",
                "method_name": "get_debug_flag",
                "second_doc": "\"\"\"\nDecides whether the application's debug features should be active based on environment configuration.\n\nActivating debug mode provides detailed error information and automatic reloading, which aids developers in identifying and resolving issues during application development or troubleshooting.\n\nArgs:\n    None\n\nReturns:\n    bool: True if debugging should be enabled based on environment variables or development settings, False otherwise.\n\"\"\"",
                "source_code": "val = os.environ.get(\"FLASK_DEBUG\")\n\n    if not val:\n        return get_env() == \"development\"\n\n    return val.lower() not in (\"0\", \"false\", \"no\")"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": "\"\"\"Get whether the user has disabled loading dotenv files by setting\n    :envvar:`FLASK_SKIP_DOTENV`. The default is ``True``, load the\n    files.\n\n    :param default: What to return if the env var isn't set.\n    \"\"\"",
                "first_doc": "\"\"\"\nDetermines whether to load environment variables from a .env file by checking the FLASK_SKIP_DOTENV environment variable.\n\nIf FLASK_SKIP_DOTENV is not set, returns the provided default value. If the variable is set, returns False when its value is \"0\", \"false\", or \"no\" (case-insensitive), and True otherwise.\n\nReturns:\n    bool: Whether to load the .env file or not.\n\"\"\"",
                "method_name": "get_load_dotenv",
                "second_doc": "\"\"\"\nChecks whether environment variables should be loaded from a .env file based on the FLASK_SKIP_DOTENV setting. This allows for configuration control across different environments by enabling or bypassing automatic .env loading as needed.\n\nArgs:\n    default (bool): The value to return if FLASK_SKIP_DOTENV is not set.\n\nReturns:\n    bool: True if loading from the .env file should be skipped; otherwise, returns the provided default.\n\"\"\"",
                "source_code": "val = os.environ.get(\"FLASK_SKIP_DOTENV\")\n\n    if not val:\n        return default\n\n    return val.lower() in (\"0\", \"false\", \"no\")"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": "\"\"\"Internal helper that returns the default endpoint for a given\n    function.  This always is the function name.\n    \"\"\"",
                "first_doc": "\"\"\"\nReturns the name of the given view function.\n\nArgs:\n    view_func: The view function whose name is to be retrieved.\n\nReturns:\n    str: The name of the provided view function.\n\"\"\"",
                "method_name": "_endpoint_from_view_func",
                "second_doc": "\"\"\"\nRetrieves the function name from a view function object, which can serve as a unique identifier when routing requests within the application.\n\nArgs:\n    view_func (callable): The view function whose name is to be extracted. Must not be None.\n\nReturns:\n    str: The name of the provided view function. This is typically used internally to associate endpoints with their handlers.\n\"\"\"",
                "source_code": "assert view_func is not None, \"expected view func if endpoint is not provided.\"\n    return view_func.__name__"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": "\"\"\"Request contexts disappear when the response is started on the server.\n    This is done for efficiency reasons and to make it less likely to encounter\n    memory leaks with badly written WSGI middlewares.  The downside is that if\n    you are using streamed responses, the generator cannot access request bound\n    information any more.\n\n    This function however can help you keep the context around for longer::\n\n        from flask import stream_with_context, request, Response\n\n        @app.route('/stream')\n        def streamed_response():\n            @stream_with_context\n            def generate():\n                yield 'Hello '\n                yield request.args['name']\n                yield '!'\n            return Response(generate())\n\n    Alternatively it can also be used around a specific generator::\n\n        from flask import stream_with_context, request, Response\n\n        @app.route('/stream')\n        def streamed_response():\n            def generate():\n                yield 'Hello '\n                yield request.args['name']\n                yield '!'\n            return Response(stream_with_context(generate()))\n\n    .. versionadded:: 0.9\n    \"\"\"",
                "first_doc": "\"\"\"\nWraps a generator or generator function to ensure it is executed within the current request context.\n\nIf a generator function is provided, this function returns a decorated version that streams its output while preserving the Flask request context. If an iterable (generator) is passed, it wraps the generator so that the context remains active throughout iteration, ensuring safe and consistent access to context-specific variables and cleanup.\n\nArgs:\n    generator_or_function: A generator function or generator object to be streamed with preserved request context.\n\nReturns:\n    An iterator or a decorated generator function that ensures execution within the Flask request context.\n\"\"\"",
                "method_name": "stream_with_context",
                "second_doc": "\"\"\"\nEnsures that a generator function or generator is executed while maintaining the active request context, so that features dependent on request-local information (such as user sessions or configuration) behave correctly throughout streaming or iteration.\n\nThis is necessary to guarantee that each streamed response or chunk of data consistently reflects the associated request's state and allows proper resource management and cleanup tied to the request lifecycle.\n\nArgs:\n    generator_or_function: Either a generator function or a generator object intended for streaming output while preserving request context.\n\nReturns:\n    If a generator function is provided, returns a decorated generator function that activates the request context during streaming.\n    If a generator object is provided, returns an iterator that runs within the current request context for its entire lifetime.\n\"\"\"",
                "source_code": "try:\n        gen = iter(generator_or_function)\n    except TypeError:\n\n        def decorator(*args, **kwargs):\n            gen = generator_or_function(*args, **kwargs)\n            return stream_with_context(gen)\n\n        return update_wrapper(decorator, generator_or_function)\n\n    def generator():\n        ctx = _request_ctx_stack.top\n        if ctx is None:\n            raise RuntimeError(\n                \"Attempted to stream with context but \"\n                \"there was no context in the first place to keep around.\"\n            )\n        with ctx:\n            # Dummy sentinel.  Has to be inside the context block or we're\n            # not actually keeping the context around.\n            yield None\n\n            # The try/finally is here so that if someone passes a WSGI level\n            # iterator in we're still running the cleanup logic.  Generators\n            # don't need that because they are closed on their destruction\n            # automatically.\n            try:\n                yield from gen\n            finally:\n                if hasattr(gen, \"close\"):\n                    gen.close()\n\n    # The trick is to start the generator.  Then the code execution runs until\n    # the first dummy None is yielded at which point the context was already\n    # pushed.  This item is discarded.  Then when the iteration continues the\n    # real generator is executed.\n    wrapped_g = generator()\n    next(wrapped_g)\n    return wrapped_g"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": "\"\"\"Sometimes it is necessary to set additional headers in a view.  Because\n    views do not have to return response objects but can return a value that\n    is converted into a response object by Flask itself, it becomes tricky to\n    add headers to it.  This function can be called instead of using a return\n    and you will get a response object which you can use to attach headers.\n\n    If view looked like this and you want to add a new header::\n\n        def index():\n            return render_template('index.html', foo=42)\n\n    You can now do something like this::\n\n        def index():\n            response = make_response(render_template('index.html', foo=42))\n            response.headers['X-Parachutes'] = 'parachutes are cool'\n            return response\n\n    This function accepts the very same arguments you can return from a\n    view function.  This for example creates a response with a 404 error\n    code::\n\n        response = make_response(render_template('not_found.html'), 404)\n\n    The other use case of this function is to force the return value of a\n    view function into a response which is helpful with view\n    decorators::\n\n        response = make_response(view_function())\n        response.headers['X-Parachutes'] = 'parachutes are cool'\n\n    Internally this function does the following things:\n\n    -   if no arguments are passed, it creates a new response argument\n    -   if one argument is passed, :meth:`flask.Flask.make_response`\n        is invoked with it.\n    -   if more than one argument is passed, the arguments are passed\n        to the :meth:`flask.Flask.make_response` function as tuple.\n\n    .. versionadded:: 0.6\n    \"\"\"",
                "first_doc": "\"\"\"\nGenerates a Flask response object.\n\nThis method creates a response object using the Flask application's context. If no arguments are provided, it returns an empty response. If arguments are provided, it uses the application's response creation mechanism.\n\nReturns:\n    A Flask response object generated from the provided arguments or an empty response if no arguments are given.\n\"\"\"",
                "method_name": "make_response",
                "second_doc": "\"\"\"\nCreates an HTTP response object within the application's context.\n\nThis method ensures that returned data from view functions is properly converted into a valid HTTP response, accommodating different types and formats of content. By standardizing the creation of response objects, it supports consistent interaction between the server and clients.\n\nArgs:\n    *args: Optional arguments to generate the response. Can be a response body, tuple with body and status/code, or headers.\n\nReturns:\n    Response: A Flask response object generated from the provided arguments, or an empty response if no arguments are provided.\n\"\"\"",
                "source_code": "if not args:\n        return current_app.response_class()\n    if len(args) == 1:\n        args = args[0]\n    return current_app.make_response(args)"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": "\"\"\"Generates a URL to the given endpoint with the method provided.\n\n    Variable arguments that are unknown to the target endpoint are appended\n    to the generated URL as query arguments.  If the value of a query argument\n    is ``None``, the whole pair is skipped.  In case blueprints are active\n    you can shortcut references to the same blueprint by prefixing the\n    local endpoint with a dot (``.``).\n\n    This will reference the index function local to the current blueprint::\n\n        url_for('.index')\n\n    See :ref:`url-building`.\n\n    Configuration values ``APPLICATION_ROOT`` and ``SERVER_NAME`` are only used when\n    generating URLs outside of a request context.\n\n    To integrate applications, :class:`Flask` has a hook to intercept URL build\n    errors through :attr:`Flask.url_build_error_handlers`.  The `url_for`\n    function results in a :exc:`~werkzeug.routing.BuildError` when the current\n    app does not have a URL for the given endpoint and values.  When it does, the\n    :data:`~flask.current_app` calls its :attr:`~Flask.url_build_error_handlers` if\n    it is not ``None``, which can return a string to use as the result of\n    `url_for` (instead of `url_for`'s default to raise the\n    :exc:`~werkzeug.routing.BuildError` exception) or re-raise the exception.\n    An example::\n\n        def external_url_handler(error, endpoint, values):\n            \"Looks up an external URL when `url_for` cannot build a URL.\"\n            # This is an example of hooking the build_error_handler.\n            # Here, lookup_url is some utility function you've built\n            # which looks up the endpoint in some external URL registry.\n            url = lookup_url(endpoint, **values)\n            if url is None:\n                # External lookup did not have a URL.\n                # Re-raise the BuildError, in context of original traceback.\n                exc_type, exc_value, tb = sys.exc_info()\n                if exc_value is error:\n                    raise exc_type, exc_value, tb\n                else:\n                    raise error\n            # url_for will use this result, instead of raising BuildError.\n            return url\n\n        app.url_build_error_handlers.append(external_url_handler)\n\n    Here, `error` is the instance of :exc:`~werkzeug.routing.BuildError`, and\n    `endpoint` and `values` are the arguments passed into `url_for`.  Note\n    that this is for building URLs outside the current application, and not for\n    handling 404 NotFound errors.\n\n    .. versionadded:: 0.10\n       The `_scheme` parameter was added.\n\n    .. versionadded:: 0.9\n       The `_anchor` and `_method` parameters were added.\n\n    .. versionadded:: 0.9\n       Calls :meth:`Flask.handle_build_error` on\n       :exc:`~werkzeug.routing.BuildError`.\n\n    :param endpoint: the endpoint of the URL (name of the function)\n    :param values: the variable arguments of the URL rule\n    :param _external: if set to ``True``, an absolute URL is generated. Server\n      address can be changed via ``SERVER_NAME`` configuration variable which\n      falls back to the `Host` header, then to the IP and port of the request.\n    :param _scheme: a string specifying the desired URL scheme. The `_external`\n      parameter must be set to ``True`` or a :exc:`ValueError` is raised. The default\n      behavior uses the same scheme as the current request, or\n      :data:`PREFERRED_URL_SCHEME` if no request context is available.\n      This also can be set to an empty string to build protocol-relative\n      URLs.\n    :param _anchor: if provided this is added as anchor to the URL.\n    :param _method: if provided this explicitly specifies an HTTP method.\n    \"\"\"",
                "first_doc": "\"\"\"\nGenerates a URL to the given endpoint with the method provided.\n\nThis method generates an absolute or relative URL for the specified endpoint, optionally applying URL generation arguments and context-specific flags (such as external, anchor, method, and scheme). It utilizes the current application and request context to ensure correct URL building. In case of failures, it delegates error handling to the application's error handler.\n\nArgs:\n    endpoint: The endpoint of the URL (typically the name of the view function for which to generate a URL).\n\nReturns:\n    str: The generated URL for the given endpoint, including any applied arguments and anchor if specified.\n\"\"\"",
                "method_name": "url_for",
                "second_doc": "\"\"\"\nBuilds a URL for a given endpoint using the application's current configuration and request context, taking into account optional parameters for external links, anchors, methods, and URL schemes. This method adapts the generated URL to suit different contexts, such as when operating within a request or independently from one, by either producing relative or absolute links. By integrating application defaults and handling contextual nuances, it ensures that generated URLs are always accurate and functional for navigation, redirection, or linking both within and outside of the application.\n\nArgs:\n    endpoint (str): The endpoint of the URL (typically the name of the view function or blueprint endpoint).\n    **values: Arbitrary keyword arguments corresponding to variable parts of the URL rule or special flags (e.g., _external, _anchor, _method, _scheme).\n\nReturns:\n    str: The constructed URL, fully resolved with any provided arguments and optionally adjusted for anchors or external schemes.\n\nRaises:\n    RuntimeError: If called outside an application context or if URL adapter cannot be created.\n    ValueError: If a URL scheme is specified without requesting an external URL.\n\"\"\"",
                "source_code": "appctx = _app_ctx_stack.top\n    reqctx = _request_ctx_stack.top\n\n    if appctx is None:\n        raise RuntimeError(\n            \"Attempted to generate a URL without the application context being\"\n            \" pushed. This has to be executed when application context is\"\n            \" available.\"\n        )\n\n    # If request specific information is available we have some extra\n    # features that support \"relative\" URLs.\n    if reqctx is not None:\n        url_adapter = reqctx.url_adapter\n        blueprint_name = request.blueprint\n\n        if endpoint[:1] == \".\":\n            if blueprint_name is not None:\n                endpoint = f\"{blueprint_name}{endpoint}\"\n            else:\n                endpoint = endpoint[1:]\n\n        external = values.pop(\"_external\", False)\n\n    # Otherwise go with the url adapter from the appctx and make\n    # the URLs external by default.\n    else:\n        url_adapter = appctx.url_adapter\n\n        if url_adapter is None:\n            raise RuntimeError(\n                \"Application was not able to create a URL adapter for request\"\n                \" independent URL generation. You might be able to fix this by\"\n                \" setting the SERVER_NAME config variable.\"\n            )\n\n        external = values.pop(\"_external\", True)\n\n    anchor = values.pop(\"_anchor\", None)\n    method = values.pop(\"_method\", None)\n    scheme = values.pop(\"_scheme\", None)\n    appctx.app.inject_url_defaults(endpoint, values)\n\n    # This is not the best way to deal with this but currently the\n    # underlying Werkzeug router does not support overriding the scheme on\n    # a per build call basis.\n    old_scheme = None\n    if scheme is not None:\n        if not external:\n            raise ValueError(\"When specifying _scheme, _external must be True\")\n        old_scheme = url_adapter.url_scheme\n        url_adapter.url_scheme = scheme\n\n    try:\n        try:\n            rv = url_adapter.build(\n                endpoint, values, method=method, force_external=external\n            )\n        finally:\n            if old_scheme is not None:\n                url_adapter.url_scheme = old_scheme\n    except BuildError as error:\n        # We need to inject the values again so that the app callback can\n        # deal with that sort of stuff.\n        values[\"_external\"] = external\n        values[\"_anchor\"] = anchor\n        values[\"_method\"] = method\n        values[\"_scheme\"] = scheme\n        return appctx.app.handle_url_build_error(error, endpoint, values)\n\n    if anchor is not None:\n        rv += f\"#{url_quote(anchor)}\"\n    return rv"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": "\"\"\"Loads a macro (or variable) a template exports.  This can be used to\n    invoke a macro from within Python code.  If you for example have a\n    template named :file:`_cider.html` with the following contents:\n\n    .. sourcecode:: html+jinja\n\n       {% macro hello(name) %}Hello {{ name }}!{% endmacro %}\n\n    You can access this from Python code like this::\n\n        hello = get_template_attribute('_cider.html', 'hello')\n        return hello('World')\n\n    .. versionadded:: 0.2\n\n    :param template_name: the name of the template\n    :param attribute: the name of the variable of macro to access\n    \"\"\"",
                "first_doc": "\"\"\"\nRetrieves a specified attribute from a Jinja template module.\n\nArgs:\n    template_name: The name of the Jinja template to retrieve.\n    attribute: The name of the attribute to extract from the template module.\n\nReturns:\n    The value of the specified attribute from the Jinja template module.\n\"\"\"",
                "method_name": "get_template_attribute",
                "second_doc": "\"\"\"\nAccesses a specific dynamic element defined within a Jinja template module, facilitating the reuse of complex template-based logic and structures across different parts of the application.\n\nArgs:\n    template_name (str): The name of the Jinja template to load.\n    attribute (str): The attribute or exported variable to retrieve from the template's module.\n\nReturns:\n    Any: The value of the requested attribute from the specified template module.\n\"\"\"",
                "source_code": "return getattr(current_app.jinja_env.get_template(template_name).module, attribute)"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": "\"\"\"Flashes a message to the next request.  In order to remove the\n    flashed message from the session and to display it to the user,\n    the template has to call :func:`get_flashed_messages`.\n\n    .. versionchanged:: 0.3\n       `category` parameter added.\n\n    :param message: the message to be flashed.\n    :param category: the category for the message.  The following values\n                     are recommended: ``'message'`` for any kind of message,\n                     ``'error'`` for errors, ``'info'`` for information\n                     messages and ``'warning'`` for warnings.  However any\n                     kind of string can be used as category.\n    \"\"\"",
                "first_doc": "\"\"\"\nStores a flash message in the session to be rendered in the next request.\n\nArgs:\n    message: The message to be flashed to the user.\n\nReturns:\n    None. The method modifies the session by adding the message to the '_flashes' list and emits a signal to notify that a message has been flashed.\n\"\"\"",
                "method_name": "flash",
                "second_doc": "\"\"\"\nQueues a message and its category to be displayed to the user on a subsequent request by storing it in the session and notifying the application.\n\nArgs:\n    message: The message to display to the user.\n    category: The type or classification of the message (e.g., 'info', 'warning', etc.).\n\nReturns:\n    None. Updates the session's '_flashes' list with the new message and category, and emits a signal to inform the application that a message has been queued.\n\nWhy:\n    This method enables the application to persist user-facing notifications or messages across requests, even when the rendering of those messages must be deferred until a later response. This ensures users receive timely feedback about actions or events, improving usability and user interaction flow.\n\"\"\"",
                "source_code": "# Original implementation:\n    #\n    #     session.setdefault('_flashes', []).append((category, message))\n    #\n    # This assumed that changes made to mutable structures in the session are\n    # always in sync with the session object, which is not true for session\n    # implementations that use external storage for keeping their keys/values.\n    flashes = session.get(\"_flashes\", [])\n    flashes.append((category, message))\n    session[\"_flashes\"] = flashes\n    message_flashed.send(\n        current_app._get_current_object(), message=message, category=category\n    )"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": "\"\"\"Pulls all flashed messages from the session and returns them.\n    Further calls in the same request to the function will return\n    the same messages.  By default just the messages are returned,\n    but when `with_categories` is set to ``True``, the return value will\n    be a list of tuples in the form ``(category, message)`` instead.\n\n    Filter the flashed messages to one or more categories by providing those\n    categories in `category_filter`.  This allows rendering categories in\n    separate html blocks.  The `with_categories` and `category_filter`\n    arguments are distinct:\n\n    * `with_categories` controls whether categories are returned with message\n      text (``True`` gives a tuple, where ``False`` gives just the message text).\n    * `category_filter` filters the messages down to only those matching the\n      provided categories.\n\n    See :doc:`/patterns/flashing` for examples.\n\n    .. versionchanged:: 0.3\n       `with_categories` parameter added.\n\n    .. versionchanged:: 0.9\n        `category_filter` parameter added.\n\n    :param with_categories: set to ``True`` to also receive categories.\n    :param category_filter: whitelist of categories to limit return values\n    \"\"\"",
                "first_doc": "\"\"\"\nRetrieves flashed messages from the session or request context.\n\nFetches stored flash messages, optionally filtering them by category and determining whether to return messages alone or along with their categories.\n\nReturns:\n    list: A list of flashed messages. If categories are included, each item is a tuple of (category, message); otherwise, it is a list of messages.\n\"\"\"",
                "method_name": "get_flashed_messages",
                "second_doc": "\"\"\"\nExtracts and returns any queued flash messages for the current request cycle, optionally filtering by category and choosing whether to include categories alongside messages.\n\nThis method ensures that temporary notification or feedback messages intended for users are collected from the request context or session, supporting their display and proper lifecycle handling in a web application.\n\nArgs:\n    with_categories (bool, optional): If True, returns messages as (category, message) tuples. If False, returns only message strings.\n    category_filter (list, optional): A list of categories to filter and include; if None, all categories are included.\n\nReturns:\n    list: A list of flashed messages. If with_categories is True, the list contains (category, message) tuples; otherwise, it contains strings of messages only.\n\"\"\"",
                "source_code": "flashes = _request_ctx_stack.top.flashes\n    if flashes is None:\n        _request_ctx_stack.top.flashes = flashes = (\n            session.pop(\"_flashes\") if \"_flashes\" in session else []\n        )\n    if category_filter:\n        flashes = list(filter(lambda f: f[0] in category_filter, flashes))\n    if not with_categories:\n        return [x[1] for x in flashes]\n    return flashes"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": "\"\"\"Sends the contents of a file to the client.  This will use the\n    most efficient method available and configured.  By default it will\n    try to use the WSGI server's file_wrapper support.  Alternatively\n    you can set the application's :attr:`~Flask.use_x_sendfile` attribute\n    to ``True`` to directly emit an ``X-Sendfile`` header.  This however\n    requires support of the underlying webserver for ``X-Sendfile``.\n\n    By default it will try to guess the mimetype for you, but you can\n    also explicitly provide one.  For extra security you probably want\n    to send certain files as attachment (HTML for instance).  The mimetype\n    guessing requires a `filename` or an `attachment_filename` to be\n    provided.\n\n    When passing a file-like object instead of a filename, only binary\n    mode is supported (``open(filename, \"rb\")``, :class:`~io.BytesIO`,\n    etc.). Text mode files and :class:`~io.StringIO` will raise a\n    :exc:`ValueError`.\n\n    ETags will also be attached automatically if a `filename` is provided. You\n    can turn this off by setting `add_etags=False`.\n\n    If `conditional=True` and `filename` is provided, this method will try to\n    upgrade the response stream to support range requests.  This will allow\n    the request to be answered with partial content response.\n\n    Please never pass filenames to this function from user sources;\n    you should use :func:`send_from_directory` instead.\n\n    .. versionchanged:: 2.0\n        Passing a file-like object that inherits from\n        :class:`~io.TextIOBase` will raise a :exc:`ValueError` rather\n        than sending an empty file.\n\n    .. versionchanged:: 1.1\n        ``filename`` may be a :class:`~os.PathLike` object.\n\n    .. versionchanged:: 1.1\n        Passing a :class:`~io.BytesIO` object supports range requests.\n\n    .. versionchanged:: 1.0.3\n        Filenames are encoded with ASCII instead of Latin-1 for broader\n        compatibility with WSGI servers.\n\n    .. versionchanged:: 1.0\n        UTF-8 filenames, as specified in `RFC 2231`_, are supported.\n\n    .. _RFC 2231: https://tools.ietf.org/html/rfc2231#section-4\n\n    .. versionchanged:: 0.12\n       The filename is no longer automatically inferred from file\n       objects. If you want to use automatic MIME and etag support, pass\n       a filename via ``filename_or_fp`` or ``attachment_filename``.\n\n    .. versionchanged:: 0.12\n       ``attachment_filename`` is preferred over ``filename`` for MIME\n       detection.\n\n    .. versionchanged:: 0.9\n       ``cache_timeout`` defaults to\n       :meth:`Flask.get_send_file_max_age`.\n\n    .. versionchanged:: 0.7\n       MIME guessing and etag support for file-like objects was\n       deprecated because it was unreliable. Pass a filename if you are\n       able to, otherwise attach an etag yourself. This functionality\n       will be removed in Flask 1.0.\n\n    .. versionadded:: 0.5\n       The ``add_etags``, ``cache_timeout`` and ``conditional``\n       parameters were added. The default behavior is to add etags.\n\n    .. versionadded:: 0.2\n\n    :param filename_or_fp: The filename of the file to send, relative to\n        :attr:`~Flask.root_path` if a relative path is specified.\n        Alternatively, a file-like object opened in binary mode. Make\n        sure the file pointer is seeked to the start of the data.\n        ``X-Sendfile`` will only be used with filenames.\n    :param mimetype: the mimetype of the file if provided. If a file path is\n                     given, auto detection happens as fallback, otherwise an\n                     error will be raised.\n    :param as_attachment: set to ``True`` if you want to send this file with\n                          a ``Content-Disposition: attachment`` header.\n    :param attachment_filename: the filename for the attachment if it\n                                differs from the file's filename.\n    :param add_etags: set to ``False`` to disable attaching of etags.\n    :param conditional: set to ``True`` to enable conditional responses.\n\n    :param cache_timeout: the timeout in seconds for the headers. When ``None``\n                          (default), this value is set by\n                          :meth:`~Flask.get_send_file_max_age` of\n                          :data:`~flask.current_app`.\n    :param last_modified: set the ``Last-Modified`` header to this value,\n        a :class:`~datetime.datetime` or timestamp.\n        If a file was passed, this overrides its mtime.\n    \"\"\"",
                "first_doc": "\"\"\"\nSends the specified file as a HTTP response to the client.\n\nArgs:\n    filename_or_fp: The file path or file-like object to send.\n\nReturns:\n    A Flask response object containing the requested file or file content.\n\"\"\"",
                "method_name": "send_file",
                "second_doc": "\"\"\"\nPrepares and transmits the given file or file-like object to the client as an HTTP response, handling headers, caching, and content disposition to ensure correct and efficient content delivery.\n\nArgs:\n    filename_or_fp: The file path (as a string or path-like object) or a file-like object to be sent.\n    mimetype (optional): The MIME type to send for the file.\n    as_attachment (optional): If True, indicate the response as a file download.\n    attachment_filename (optional): The filename to use for the Content-Disposition header.\n    add_etags (optional): Whether to generate and include ETags for HTTP caching.\n    cache_timeout (optional): Max age (in seconds) to use for HTTP cache headers.\n    conditional (optional): If True, enables conditional response handling (e.g., for range requests).\n    last_modified (optional): Override the Last-Modified HTTP header value.\n\nReturns:\n    A Flask response object containing the file's content, accompanied by appropriate headers for content type, disposition, size, caching, and conditional requests.\n\nWhy:\n    This method centralizes correct, secure, and efficient file serving in web applications\u2014ensuring headers are properly set, files are efficiently streamed, HTTP standards (like caching and conditional requests) are followed, and edge cases (such as missing MIME types or invalid file modes) are managed to optimize client compatibility and resource use.\n\"\"\"",
                "source_code": "mtime = None\n    fsize = None\n\n    if hasattr(filename_or_fp, \"__fspath__\"):\n        filename_or_fp = os.fspath(filename_or_fp)\n\n    if isinstance(filename_or_fp, str):\n        filename = filename_or_fp\n        if not os.path.isabs(filename):\n            filename = os.path.join(current_app.root_path, filename)\n        file = None\n        if attachment_filename is None:\n            attachment_filename = os.path.basename(filename)\n    else:\n        file = filename_or_fp\n        filename = None\n\n    if mimetype is None:\n        if attachment_filename is not None:\n            mimetype = (\n                mimetypes.guess_type(attachment_filename)[0]\n                or \"application/octet-stream\"\n            )\n\n        if mimetype is None:\n            raise ValueError(\n                \"Unable to infer MIME-type because no filename is available. \"\n                \"Please set either `attachment_filename`, pass a filepath to \"\n                \"`filename_or_fp` or set your own MIME-type via `mimetype`.\"\n            )\n\n    headers = Headers()\n    if as_attachment:\n        if attachment_filename is None:\n            raise TypeError(\"filename unavailable, required for sending as attachment\")\n\n        if not isinstance(attachment_filename, str):\n            attachment_filename = attachment_filename.decode(\"utf-8\")\n\n        try:\n            attachment_filename = attachment_filename.encode(\"ascii\")\n        except UnicodeEncodeError:\n            quoted = url_quote(attachment_filename, safe=\"\")\n            filenames = {\n                \"filename\": unicodedata.normalize(\"NFKD\", attachment_filename).encode(\n                    \"ascii\", \"ignore\"\n                ),\n                \"filename*\": f\"UTF-8''{quoted}\",\n            }\n        else:\n            filenames = {\"filename\": attachment_filename}\n\n        headers.add(\"Content-Disposition\", \"attachment\", **filenames)\n\n    if current_app.use_x_sendfile and filename:\n        if file is not None:\n            file.close()\n\n        headers[\"X-Sendfile\"] = filename\n        fsize = os.path.getsize(filename)\n        data = None\n    else:\n        if file is None:\n            file = open(filename, \"rb\")\n            mtime = os.path.getmtime(filename)\n            fsize = os.path.getsize(filename)\n        elif isinstance(file, io.BytesIO):\n            fsize = file.getbuffer().nbytes\n        elif isinstance(file, io.TextIOBase):\n            raise ValueError(\"Files must be opened in binary mode or use BytesIO.\")\n\n        data = wrap_file(request.environ, file)\n\n    if fsize is not None:\n        headers[\"Content-Length\"] = fsize\n\n    rv = current_app.response_class(\n        data, mimetype=mimetype, headers=headers, direct_passthrough=True\n    )\n\n    if last_modified is not None:\n        rv.last_modified = last_modified\n    elif mtime is not None:\n        rv.last_modified = mtime\n\n    rv.cache_control.public = True\n    if cache_timeout is None:\n        cache_timeout = current_app.get_send_file_max_age(filename)\n    if cache_timeout is not None:\n        rv.cache_control.max_age = cache_timeout\n        rv.expires = int(time() + cache_timeout)\n\n    if add_etags and filename is not None:\n        from warnings import warn\n\n        try:\n            check = (\n                adler32(\n                    filename.encode(\"utf-8\") if isinstance(filename, str) else filename\n                )\n                & 0xFFFFFFFF\n            )\n            rv.set_etag(\n                f\"{os.path.getmtime(filename)}-{os.path.getsize(filename)}-{check}\"\n            )\n        except OSError:\n            warn(\n                f\"Access {filename} failed, maybe it does not exist, so\"\n                \" ignore etags in headers\",\n                stacklevel=2,\n            )\n\n    if conditional:\n        try:\n            rv = rv.make_conditional(request, accept_ranges=True, complete_length=fsize)\n        except RequestedRangeNotSatisfiable:\n            if file is not None:\n                file.close()\n            raise\n        # make sure we don't send x-sendfile for servers that\n        # ignore the 304 status code for x-sendfile.\n        if rv.status_code == 304:\n            rv.headers.pop(\"x-sendfile\", None)\n    return rv"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": "\"\"\"Safely join `directory` and zero or more untrusted `pathnames`\n    components.\n\n    Example usage::\n\n        @app.route('/wiki/<path:filename>')\n        def wiki_page(filename):\n            filename = safe_join(app.config['WIKI_FOLDER'], filename)\n            with open(filename, 'rb') as fd:\n                content = fd.read()  # Read and process the file content...\n\n    :param directory: the trusted base directory.\n    :param pathnames: the untrusted pathnames relative to that directory.\n    :raises: :class:`~werkzeug.exceptions.NotFound` if one or more passed\n            paths fall out of its boundaries.\n    \"\"\"",
                "first_doc": "\"\"\"\nSafely joins a directory with one or more relative path components, preventing directory traversal attacks.\n\nArgs:\n    directory: The base directory to which the path components will be joined.\n\nReturns:\n    str: The normalized, joined path that remains within the base directory.\n\nRaises:\n    NotFound: If an attempt to traverse outside the base directory is detected (e.g., absolute path, '..', or path separator).\n\"\"\"",
                "method_name": "safe_join",
                "second_doc": "\"\"\"\nConstructs a normalized path by securely joining a base directory with one or more relative path components, ensuring that the resulting path cannot escape the confines of the starting directory. This check is crucial for maintaining application security by validating file access and preventing unauthorized traversal.\n\nArgs:\n    directory (str): The base directory to which the given path components are appended.\n    *pathnames (str): One or more relative path components to join with the base directory.\n\nReturns:\n    str: The resulting normalized path, guaranteed to be a subpath of the provided base directory.\n\nRaises:\n    NotFound: If an invalid path component is detected that attempts to escape the base directory, such as an absolute path, directory traversal pattern (e.g., '..' or '../'), or includes disallowed separators.\n\"\"\"",
                "source_code": "parts = [directory]\n\n    for filename in pathnames:\n        if filename != \"\":\n            filename = posixpath.normpath(filename)\n\n        if (\n            any(sep in filename for sep in _os_alt_seps)\n            or os.path.isabs(filename)\n            or filename == \"..\"\n            or filename.startswith(\"../\")\n        ):\n            raise NotFound()\n\n        parts.append(filename)\n\n    return posixpath.join(*parts)"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": "\"\"\"Send a file from a given directory with :func:`send_file`.  This\n    is a secure way to quickly expose static files from an upload folder\n    or something similar.\n\n    Example usage::\n\n        @app.route('/uploads/<path:filename>')\n        def download_file(filename):\n            return send_from_directory(app.config['UPLOAD_FOLDER'],\n                                       filename, as_attachment=True)\n\n    .. admonition:: Sending files and Performance\n\n       It is strongly recommended to activate either ``X-Sendfile`` support in\n       your webserver or (if no authentication happens) to tell the webserver\n       to serve files for the given path on its own without calling into the\n       web application for improved performance.\n\n    .. versionadded:: 0.5\n\n    :param directory: the directory where all the files are stored.\n    :param filename: the filename relative to that directory to\n                     download.\n    :param options: optional keyword arguments that are directly\n                    forwarded to :func:`send_file`.\n    \"\"\"",
                "first_doc": "\"\"\"\nSends a file from within a specified directory.\n\nThis method ensures that the file is located safely within the given directory, checks that it exists, and sends it as a response to the client. It is typically used to securely serve files from a static directory.\n\nArgs:\n    directory: The directory in which to look for the file.\n    filename: The name of the file to send from the specified directory.\n\nReturns:\n    A response object resulting from sending the specified file to the client.\n\"\"\"",
                "method_name": "send_from_directory",
                "second_doc": "\"\"\"\nSafely locates and transmits a specified file from a designated directory to the client.\n\nThis method validates the file path to prevent unauthorized access, ensures the file exists, and then serves it as a response. The approach aims to enforce security and reliability when making server files available to users.\n\nArgs:\n    directory (str): The target directory in which to search for the file.\n    filename (str): The specific name of the file to be sent from the directory.\n\nReturns:\n    Response: A response object that streams the requested file to the client, or raises an error if the file cannot be located or accessed safely.\n\"\"\"",
                "source_code": "filename = os.fspath(filename)\n    directory = os.fspath(directory)\n    filename = safe_join(directory, filename)\n    if not os.path.isabs(filename):\n        filename = os.path.join(current_app.root_path, filename)\n    try:\n        if not os.path.isfile(filename):\n            raise NotFound()\n    except (TypeError, ValueError):\n        raise BadRequest()\n    options.setdefault(\"conditional\", True)\n    return send_file(filename, **options)"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": "\"\"\"Returns the path to a package or cwd if that cannot be found.  This\n    returns the path of a package or the folder that contains a module.\n\n    Not to be confused with the package path returned by :func:`find_package`.\n    \"\"\"",
                "first_doc": "\"\"\"\nReturns the absolute filesystem root path for the given import name.\n\nDetermines the root path of a Python module or package by checking if the module is already imported, analyzing its loader, or falling back to the current working directory. Handles various import scenarios including namespace packages and modules loaded in interactive sessions.\n\nArgs:\n    import_name: The import name of the module or package whose root filesystem path should be determined.\n\nReturns:\n    str: The absolute root directory path for the specified module or package.\n\"\"\"",
                "method_name": "get_root_path",
                "second_doc": "\"\"\"\nLocates and returns the absolute root filesystem path for a given Python module or package import name. This process ensures that the application can reliably resolve resource and configuration locations within the module's directory structure, regardless of how the module was imported or executed. It addresses various execution contexts, such as running from a file, package, or interactively.\n\nArgs:\n    import_name (str): The import name of the module or package whose root filesystem path needs to be determined.\n\nReturns:\n    str: The absolute filesystem root directory path corresponding to the specified module or package.\n\nRaises:\n    RuntimeError: If a root path cannot be determined due to the module being a namespace package or lacking file information.\n\"\"\"",
                "source_code": "# Module already imported and has a file attribute.  Use that first.\n    mod = sys.modules.get(import_name)\n    if mod is not None and hasattr(mod, \"__file__\"):\n        return os.path.dirname(os.path.abspath(mod.__file__))\n\n    # Next attempt: check the loader.\n    loader = pkgutil.get_loader(import_name)\n\n    # Loader does not exist or we're referring to an unloaded main module\n    # or a main module without path (interactive sessions), go with the\n    # current working directory.\n    if loader is None or import_name == \"__main__\":\n        return os.getcwd()\n\n    if hasattr(loader, \"get_filename\"):\n        filepath = loader.get_filename(import_name)\n    else:\n        # Fall back to imports.\n        __import__(import_name)\n        mod = sys.modules[import_name]\n        filepath = getattr(mod, \"__file__\", None)\n\n        # If we don't have a filepath it might be because we are a\n        # namespace package.  In this case we pick the root path from the\n        # first module that is contained in our package.\n        if filepath is None:\n            raise RuntimeError(\n                \"No root path can be found for the provided module\"\n                f\" {import_name!r}. This can happen because the module\"\n                \" came from an import hook that does not provide file\"\n                \" name information or because it's a namespace package.\"\n                \" In this case the root path needs to be explicitly\"\n                \" provided.\"\n            )\n\n    # filepath is import_name.py for a module, or __init__.py for a package.\n    return os.path.dirname(os.path.abspath(filepath))"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": "\"\"\"Given the loader that loaded a module and the module this function\n    attempts to figure out if the given module is actually a package.\n    \"\"\"",
                "first_doc": "\"\"\"\nDetermines whether the given module should be considered a package according to the provided loader.\n\nThis method checks if the loader can explicitly identify packages, or if the loader is recognized as a namespace loader that always treats modules as packages. If neither is possible, it raises an error indicating the loader is incompatible.\n\nArgs:\n    loader: The loader object used for importing modules.\n    mod_name: The name of the module to be checked.\n\nReturns:\n    bool: True if the module is a package according to the loader, otherwise raises an AttributeError.\n\"\"\"",
                "method_name": "_matching_loader_thinks_module_is_package",
                "second_doc": "\"\"\"\nDetermines if a given module should be treated as a package based on the capabilities of its loader. This check ensures that modules are correctly categorized, either through direct loader support or by recognizing special cases where all modules are considered packages. If the loader lacks the necessary attributes, an error is raised to prevent ambiguous module handling, maintaining consistency in the application's import behavior.\n\nArgs:\n    loader: The object responsible for loading the module.\n    mod_name: The name of the module being examined.\n\nReturns:\n    bool: True if the loader identifies the module as a package.\n    \nRaises:\n    AttributeError: If the loader cannot determine package status for the module.\n\"\"\"",
                "source_code": "cls = type(loader)\n    # If the loader can tell us if something is a package, we can\n    # directly ask the loader.\n    if hasattr(loader, \"is_package\"):\n        return loader.is_package(mod_name)\n    # importlib's namespace loaders do not have this functionality but\n    # all the modules it loads are packages, so we can take advantage of\n    # this information.\n    elif cls.__module__ == \"_frozen_importlib\" and cls.__name__ == \"NamespaceLoader\":\n        return True\n    # Otherwise we need to fail with an error that explains what went\n    # wrong.\n    raise AttributeError(\n        f\"{cls.__name__}.is_package() method is missing but is required\"\n        \" for PEP 302 import hooks.\"\n    )"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": "\"\"\"Find the path where the module's root exists in\"\"\"",
                "first_doc": "\"\"\"\nDetermines the absolute filesystem path of the given root module or package.\n\nThis method attempts to locate the directory containing the specified module or package by consulting the available import machinery. It accounts for various scenarios, including namespace packages, regular packages, single-file modules, and special cases such as interactive sessions or modules not found by standard mechanisms. If the module is a namespace package, the path to its directory is returned. For packages and modules, the containing directory is determined appropriately. If the module cannot be found through standard means, the current working directory is returned.\n\nArgs:\n    root_mod_name: The fully qualified name of the root module or package to find.\n\nReturns:\n    str: The absolute filesystem path to the specified root module or package, or the current working directory if the module cannot be located.\n\"\"\"",
                "method_name": "_find_package_path",
                "second_doc": "\"\"\"\nResolves the absolute filesystem path for a given Python module or package name.\n\nThis method identifies where a specified module or package resides on disk by interacting with Python\u2019s import system. It robustly accounts for varying import scenarios (e.g., standard, namespace, or single-file modules) and interactive or missing modules by falling back to the current working directory when necessary. This allows the framework to reliably locate resources, templates, or configuration files relative to the project\u2019s structure, regardless of how or where the module is loaded.\n\nArgs:\n    root_mod_name (str): The fully qualified name of the module or package whose directory path is to be determined.\n\nReturns:\n    str: The absolute filesystem path to the root module or package, or the current working directory if the location cannot be determined.\n\"\"\"",
                "source_code": "import importlib.util\n\n    try:\n        spec = importlib.util.find_spec(root_mod_name)\n        if spec is None:\n            raise ValueError(\"not found\")\n    # ImportError: the machinery told us it does not exist\n    # ValueError:\n    #    - the module name was invalid\n    #    - the module name is __main__\n    #    - *we* raised `ValueError` due to `spec` being `None`\n    except (ImportError, ValueError):\n        pass  # handled below\n    else:\n        # namespace package\n        if spec.origin in {\"namespace\", None}:\n            return os.path.dirname(next(iter(spec.submodule_search_locations)))\n        # a package (with __init__.py)\n        elif spec.submodule_search_locations:\n            return os.path.dirname(os.path.dirname(spec.origin))\n        # just a normal module\n        else:\n            return os.path.dirname(spec.origin)\n\n    # we were unable to find the `package_path` using PEP 451 loaders\n    loader = pkgutil.get_loader(root_mod_name)\n    if loader is None or root_mod_name == \"__main__\":\n        # import name is not found, or interactive/main module\n        return os.getcwd()\n    else:\n        if hasattr(loader, \"get_filename\"):\n            filename = loader.get_filename(root_mod_name)\n        elif hasattr(loader, \"archive\"):\n            # zipimporter's loader.archive points to the .egg or .zip\n            # archive filename is dropped in call to dirname below.\n            filename = loader.archive\n        else:\n            # At least one loader is missing both get_filename and archive:\n            # Google App Engine's HardenedModulesHook\n            #\n            # Fall back to imports.\n            __import__(root_mod_name)\n            filename = sys.modules[root_mod_name].__file__\n        package_path = os.path.abspath(os.path.dirname(filename))\n\n        # In case the root module is a package we need to chop of the\n        # rightmost part. This needs to go through a helper function\n        # because of namespace packages.\n        if _matching_loader_thinks_module_is_package(loader, root_mod_name):\n            package_path = os.path.dirname(package_path)\n\n    return package_path"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": "\"\"\"Finds a package and returns the prefix (or None if the package is\n    not installed) as well as the folder that contains the package or\n    module as a tuple.  The package path returned is the module that would\n    have to be added to the pythonpath in order to make it possible to\n    import the module.  The prefix is the path below which a UNIX like\n    folder structure exists (lib, share etc.).\n    \"\"\"",
                "first_doc": "\"\"\"\nFinds the base directory and package path of a given Python import name.\n\nThis method determines the file system location of the root package corresponding to the provided import name. It returns both the base directory under which the package is installed and the full path to the package itself. The behavior adapts to different installation environments, such as virtual environments, site-packages, and platform-specific structures.\n\nArgs:\n    import_name: The dotted-path string of the module or package to locate (e.g., 'flask.helpers').\n\nReturns:\n    tuple: A tuple (base_dir, package_path) where base_dir is the root directory of the Python environment or installation, and package_path is the path to the package for import_name. If the package is not located within the standard Python prefix, base_dir may be None.\n\"\"\"",
                "method_name": "find_package",
                "second_doc": "\"\"\"\nLocates the root directory and absolute file system path for the given Python import name.\n\nThis method analyzes the environment in which a package or module is installed to accurately identify both the base directory of the Python installation and the full path to the specified package or module. This is necessary to ensure the correct discovery and referencing of dependencies regardless of diverse installation layouts or environments, which may affect how applications locate their resources.\n\nArgs:\n    import_name (str): The dotted import path of the module or package to locate (e.g., 'flask.helpers').\n\nReturns:\n    tuple: (base_dir, package_path) where base_dir is the root directory of the Python environment or installation, and package_path is the absolute path to the located package or module. Returns (None, package_path) if the package is outside standard directory structures.\n\"\"\"",
                "source_code": "root_mod_name, _, _ = import_name.partition(\".\")\n    package_path = _find_package_path(root_mod_name)\n    site_parent, site_folder = os.path.split(package_path)\n    py_prefix = os.path.abspath(sys.prefix)\n    if package_path.startswith(py_prefix):\n        return py_prefix, package_path\n    elif site_folder.lower() == \"site-packages\":\n        parent, folder = os.path.split(site_parent)\n        # Windows like installations\n        if folder.lower() == \"lib\":\n            base_dir = parent\n        # UNIX like installations\n        elif os.path.basename(parent).lower() == \"lib\":\n            base_dir = os.path.dirname(parent)\n        else:\n            base_dir = site_parent\n        return base_dir, package_path\n    return None, package_path"
            },
            "type": "function"
        },
        {
            "methods": [
                {
                    "docstring": null,
                    "method_name": "__init__",
                    "second_doc": "\"\"\"\nInitializes a new instance of the locked_cached_property descriptor, capturing the target function, its documentation, and metadata, while ensuring thread-safe access to cached results.\n\nArgs:\n    func (callable): The function whose result should be cached as a property.\n    name (str, optional): The name to assign to the property. Defaults to the function's name if not provided.\n    doc (str, optional): The docstring for the property. Defaults to the function's docstring if not provided.\n\nReturns:\n    None\n\nWhy:  \nThis initialization process allows later property lookups to efficiently and safely cache expensive computations on objects, ensuring consistent results even when accessed by multiple threads simultaneously.\n\"\"\"",
                    "source_code": "self.__name__ = name or func.__name__\n        self.__module__ = func.__module__\n        self.__doc__ = doc or func.__doc__\n        self.func = func\n        self.lock = RLock()"
                },
                {
                    "docstring": null,
                    "method_name": "__get__",
                    "second_doc": "\"\"\"\nRetrieve the cached property value from the instance, computing and storing it if necessary.\n\nThis method enables efficient and thread-safe access to an expensive or frequently used computed value by caching it on first access. Ensures that the calculation only occurs once per instance by using a lock for synchronization.\n\nArgs:\n    obj: The instance the property was accessed through.\n    type: The type of the instance (unused).\n\nReturns:\n    The cached value of the property for the given instance. If accessed through the class, returns the property itself.\n\"\"\"",
                    "source_code": "if obj is None:\n            return self\n        with self.lock:\n            value = obj.__dict__.get(self.__name__, _missing)\n            if value is _missing:\n                value = self.func(obj)\n                obj.__dict__[self.__name__] = value\n            return value"
                }
            ],
            "name": "locked_cached_property",
            "type": "class"
        },
        {
            "methods": [
                {
                    "docstring": null,
                    "method_name": "__init__",
                    "second_doc": "\"\"\"\nInitializes a package-bound object, setting up essential paths and structures for resource loading, static files, templates, and command-line interface integration. This supports the modular configuration and extensibility of the application environment.\n\nArgs:\n    import_name (str): The dotted Python import path of the application or module.\n    template_folder (Optional[str]): The name of the folder containing templates, relative to the package root.\n    root_path (Optional[str]): The absolute filesystem path to the package or module root. If not provided, it is determined from import_name.\n\nReturns:\n    None\n\nWhy:\n    This method ensures that core paths and resources are initialized and accessible, enabling proper loading of templates, static files, and the registration of command-line commands for interaction and development workflows.\n\"\"\"",
                    "source_code": "self.import_name = import_name\n        self.template_folder = template_folder\n\n        if root_path is None:\n            root_path = get_root_path(self.import_name)\n\n        self.root_path = root_path\n        self._static_folder = None\n        self._static_url_path = None\n\n        # circular import\n        from .cli import AppGroup\n\n        #: The Click command group for registration of CLI commands\n        #: on the application and associated blueprints. These commands\n        #: are accessible via the :command:`flask` command once the\n        #: application has been discovered and blueprints registered.\n        self.cli = AppGroup()"
                },
                {
                    "docstring": "\"\"\"The absolute path to the configured static folder.\"\"\"",
                    "first_doc": "\"\"\"\nReturns the absolute path to the configured static folder.\n\nArgs:\n    self: The instance of the class.\n\nReturns:\n    str: The absolute filesystem path to the static folder if configured; otherwise, returns None.\n\"\"\"",
                    "method_name": "static_folder",
                    "second_doc": "\"\"\"\nComputes and returns the absolute path to the static file directory associated with the current application or blueprint, enabling correct access and serving of static resources.\n\nArgs:\n    self: The instance representing the bound package object.\n\nReturns:\n    str or None: Absolute filesystem path to the static folder if it is set; otherwise, None.\n\"\"\"",
                    "source_code": "if self._static_folder is not None:\n            return os.path.join(self.root_path, self._static_folder)"
                },
                {
                    "docstring": null,
                    "method_name": "static_folder",
                    "second_doc": "\"\"\"\nSets the static folder path for serving static files by removing any trailing slashes or backslashes from the given value. \nThis ensures path consistency and prevents issues when resolving static resources associated with the application.\n\nArgs:\n    value (str or None): The path to the static folder. If not None, trailing slashes or backslashes are stripped.\n\nReturns:\n    None\n\"\"\"",
                    "source_code": "if value is not None:\n            value = value.rstrip(\"/\\\\\")\n        self._static_folder = value"
                },
                {
                    "docstring": "\"\"\"The URL prefix that the static route will be accessible from.\n\n        If it was not configured during init, it is derived from\n        :attr:`static_folder`.\n        \"\"\"",
                    "first_doc": "\"\"\"\nReturns the URL prefix used to access the static route.\n\nIf the URL prefix was not explicitly configured during initialization, it is derived from the static_folder attribute by using the folder's basename.\n\nArgs:\n  self: The instance of the class.\n\nReturns:\n  str: The URL path prefix for accessing static files.\n\"\"\"",
                    "method_name": "static_url_path",
                    "second_doc": "\"\"\"\nDetermines the URL prefix at which static files will be served for the application instance.\n\nThis logic allows the framework to automatically infer a suitable access path for static content, ensuring that every application can consistently serve necessary static resources even in the absence of explicit configuration. By defaulting to the basename of the static folder, the framework promotes convention over configuration and reduces boilerplate for developers.\n\nArgs:\n    self: The instance of the class, representing the web application or blueprint.\n\nReturns:\n    str: The URL path prefix used for serving static files. If not explicitly set, this is derived from the basename of the static folder.\n\"\"\"",
                    "source_code": "if self._static_url_path is not None:\n            return self._static_url_path\n\n        if self.static_folder is not None:\n            basename = os.path.basename(self.static_folder)\n            return f\"/{basename}\".rstrip(\"/\")"
                },
                {
                    "docstring": null,
                    "method_name": "static_url_path",
                    "second_doc": "\"\"\"\nNormalizes and assigns the given static URL path to ensure consistent routing of static files.\n\nArgs:\n    value (str or None): The URL path for serving static files, or None to unset the static path.\n\nReturns:\n    None\n\nWhy:\n    Ensuring the static URL path does not have a trailing slash maintains predictable and uniform routes for serving static resources, which is important for correct URL matching and resource delivery within the application.\n\"\"\"",
                    "source_code": "if value is not None:\n            value = value.rstrip(\"/\")\n\n        self._static_url_path = value"
                },
                {
                    "docstring": "\"\"\"This is ``True`` if the package bound object's container has a\n        folder for static files.\n\n        .. versionadded:: 0.5\n        \"\"\"",
                    "first_doc": "\"\"\"\nChecks if the package bound object's container includes a folder for static files.\n\nReturns:\n    bool: True if the static folder is set for the object, otherwise False.\n\"\"\"",
                    "method_name": "has_static_folder",
                    "second_doc": "\"\"\"\nDetermines whether a directory is specified for serving static files, enabling the object to provide static content via the web server.\n\nReturns:\n    bool: True if a static folder is configured for the object, allowing static files to be served; False otherwise.\n\"\"\"",
                    "source_code": "return self.static_folder is not None"
                },
                {
                    "docstring": "\"\"\"The Jinja loader for this package bound object.\n\n        .. versionadded:: 0.5\n        \"\"\"",
                    "first_doc": "\"\"\"\nReturns a Jinja template loader for the package-bound object.\n\nThis property provides a Jinja FileSystemLoader instance, configured with this object's template folder and root path.\n\nArgs:\n    self: The instance of the class.\n\nReturns:\n    FileSystemLoader: An instance of Jinja's FileSystemLoader configured to search for templates in the object's template folder.\n\"\"\"",
                    "method_name": "jinja_loader",
                    "second_doc": "\"\"\"\nCreates and returns a Jinja FileSystemLoader configured to locate template files for rendering dynamic content based on the object's template directory.\n\nThis enables the application to efficiently find and render HTML templates associated with different components, ensuring a consistent and organized structure for dynamic web content generation.\n\nArgs:\n    self: The instance of the class containing the template configuration.\n\nReturns:\n    FileSystemLoader: A Jinja2 FileSystemLoader instance set to search for templates within the object's designated template folder.\n\"\"\"",
                    "source_code": "if self.template_folder is not None:\n            return FileSystemLoader(os.path.join(self.root_path, self.template_folder))"
                },
                {
                    "docstring": "\"\"\"Provides default cache_timeout for the :func:`send_file` functions.\n\n        By default, this function returns ``SEND_FILE_MAX_AGE_DEFAULT`` from\n        the configuration of :data:`~flask.current_app`.\n\n        Static file functions such as :func:`send_from_directory` use this\n        function, and :func:`send_file` calls this function on\n        :data:`~flask.current_app` when the given cache_timeout is ``None``. If a\n        cache_timeout is given in :func:`send_file`, that timeout is used;\n        otherwise, this method is called.\n\n        This allows subclasses to change the behavior when sending files based\n        on the filename.  For example, to set the cache timeout for .js files\n        to 60 seconds::\n\n            class MyFlask(flask.Flask):\n                def get_send_file_max_age(self, name):\n                    if name.lower().endswith('.js'):\n                        return 60\n                    return flask.Flask.get_send_file_max_age(self, name)\n\n        .. versionadded:: 0.9\n        \"\"\"",
                    "first_doc": "\"\"\"\nReturns the default cache timeout for the send_file function based on the current app configuration.\n\nThis method retrieves the cache timeout value used when sending files. If a specific cache_timeout is not provided, this method retrieves the default value from the application's configuration. Subclasses can override this method to customize cache timeout behavior based on the filename.\n\nArgs:\n    self: The instance of the class.\n    filename: The name of the file for which the cache timeout is being determined.\n\nReturns:\n    int: The cache timeout value in seconds to be used for the given file.\n\"\"\"",
                    "method_name": "get_send_file_max_age",
                    "second_doc": "\"\"\"\nDetermines the appropriate HTTP cache timeout (in seconds) to use when serving a file with send_file, based on the application's current configuration.\n\nThis method ensures that served files are cached by clients for the desired duration, improving performance by reducing redundant network requests and optimizing resource delivery. The timeout returned is derived from the app's default send_file cache duration, allowing for consistent handling of file responses across the application. Subclasses may override this method to set cache timeouts tailored to individual files.\n\nArgs:\n    self: The object instance through which the method is called.\n    filename: The name of the file being served, used if subclasses want to customize timeout per file.\n\nReturns:\n    int: Number of seconds files should be cached for, as determined by the application's configuration.\n\"\"\"",
                    "source_code": "return total_seconds(current_app.send_file_max_age_default)"
                },
                {
                    "docstring": "\"\"\"Function used internally to send static files from the static\n        folder to the browser.\n\n        .. versionadded:: 0.5\n        \"\"\"",
                    "first_doc": "\"\"\"\nSends a static file from the static folder to the browser.\n\nThis method is typically used internally to handle requests for static files, retrieving them from the static folder and serving them with the correct cache timeout.\n\nArgs:\n    filename: The name of the static file to send from the static folder.\n\nReturns:\n    A response object containing the specified static file, sent from the static folder.\n\"\"\"",
                    "method_name": "send_static_file",
                    "second_doc": "\"\"\"\nServes a static file from the configured static directory to the client, ensuring appropriate cache control is applied.\n\nThis method checks for the presence of a static folder and retrieves the requested file, determining its cache timeout before delivering it in the response. This ensures that resources like images, scripts, and style sheets are accessible to clients while adhering to caching strategies for optimal performance.\n\nArgs:\n    filename (str): The name of the static file to serve.\n\nReturns:\n    Response: A Flask response object containing the requested static file.\n\nRaises:\n    RuntimeError: If no static folder is configured for this object.\n\"\"\"",
                    "source_code": "if not self.has_static_folder:\n            raise RuntimeError(\"No static folder for this object\")\n        # Ensure get_send_file_max_age is called in all cases.\n        # Here, we ensure get_send_file_max_age is called for Blueprints.\n        cache_timeout = self.get_send_file_max_age(filename)\n        return send_from_directory(\n            self.static_folder, filename, cache_timeout=cache_timeout\n        )"
                },
                {
                    "docstring": "\"\"\"Opens a resource from the application's resource folder.  To see\n        how this works, consider the following folder structure::\n\n            /myapplication.py\n            /schema.sql\n            /static\n                /style.css\n            /templates\n                /layout.html\n                /index.html\n\n        If you want to open the :file:`schema.sql` file you would do the\n        following::\n\n            with app.open_resource('schema.sql') as f:\n                contents = f.read()\n                do_something_with(contents)\n\n        :param resource: the name of the resource.  To access resources within\n                         subfolders use forward slashes as separator.\n        :param mode: Open file in this mode. Only reading is supported,\n            valid values are \"r\" (or \"rt\") and \"rb\".\n        \"\"\"",
                    "first_doc": "\"\"\"\nOpens a resource file from the application's resource directory for reading.\n\nThis method allows you to access files placed within your application's resource folder or its subfolders, providing a convenient way to read static or template files needed by your application. The path to the resource should be relative to the application's resource directory and use forward slashes for subfolders.\n\nArgs:\n    resource: The name of the resource file to open. For resources in subfolders, use forward slashes (e.g., 'templates/layout.html').\n    mode: The mode in which to open the file. Only reading modes are supported; valid values are 'r', 'rt', or 'rb'.\n\nReturns:\n    A file object opened for reading in the specified mode.\n\"\"\"",
                    "method_name": "open_resource",
                    "second_doc": "\"\"\"\nSafely opens a file located in the application's resource directory for read-only access.\n\nThis method ensures that only files intended for reading\u2014such as static assets, configuration files, or templates\u2014are accessed, helping maintain application integrity and prevent unintended file modifications. Restricting operations to reading modes promotes consistent handling of internal files and avoids errors or misuse. The resource path is assumed to be relative to the application's root and should use forward slashes for navigating subdirectories.\n\nArgs:\n    resource (str): Relative path of the resource file to open, using forward slashes (e.g., 'static/style.css' or 'config/settings.json').\n    mode (str): File open mode. Supported values are 'r', 'rt', or 'rb' for text or binary read-only access.\n\nReturns:\n    file object: An open file object in the specified read-only mode.\n\nRaises:\n    ValueError: If a mode other than 'r', 'rt', or 'rb' is provided.\n\"\"\"",
                    "source_code": "if mode not in {\"r\", \"rt\", \"rb\"}:\n            raise ValueError(\"Resources can only be opened for reading\")\n\n        return open(os.path.join(self.root_path, resource), mode)"
                }
            ],
            "name": "_PackageBoundObject",
            "type": "class"
        },
        {
            "details": {
                "docstring": "\"\"\"Returns the total seconds from a timedelta object.\n\n    :param timedelta td: the timedelta to be converted in seconds\n\n    :returns: number of seconds\n    :rtype: int\n    \"\"\"",
                "first_doc": "\"\"\"\nCalculates the total number of seconds represented by a time duration.\n\nArgs:\n    td: The time duration to be converted to total seconds.\n\nReturns:\n    int: The total number of seconds represented by the input duration.\n\"\"\"",
                "method_name": "total_seconds",
                "second_doc": "\"\"\"\nConverts a time duration into its equivalent total number of seconds to facilitate precise time calculations and comparisons.\n\nArgs:\n    td: A time duration object, typically a datetime.timedelta instance, representing a span of time.\n\nReturns:\n    int: The total number of seconds corresponding to the provided time duration.\n\"\"\"",
                "source_code": "return td.days * 60 * 60 * 24 + td.seconds"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": "\"\"\"Determine if the given string is an IP address.\n\n    :param value: value to check\n    :type value: str\n\n    :return: True if string is an IP address\n    :rtype: bool\n    \"\"\"",
                "first_doc": "\"\"\"\nChecks whether the given value is a valid IPv4 or IPv6 address.\n\nArgs:\n    value: The input value to be checked for IP address validity.\n\nReturns:\n    bool: True if the value is a valid IPv4 or IPv6 address, False otherwise.\n\"\"\"",
                "method_name": "is_ip",
                "second_doc": "\"\"\"\nDetermines if the provided value represents a valid IPv4 or IPv6 address. This check ensures that data representing network addresses is properly validated before further processing in the application, which is essential for handling user input, network communication, or request routing.\n\nArgs:\n    value (str): The string to be validated as an IP address.\n\nReturns:\n    bool: True if the value is a valid IPv4 or IPv6 address, otherwise False.\n\"\"\"",
                "source_code": "for family in (socket.AF_INET, socket.AF_INET6):\n        try:\n            socket.inet_pton(family, value)\n        except OSError:\n            pass\n        else:\n            return True\n\n    return False"
            },
            "type": "function"
        }
    ],
    "flask/src/flask/json/__init__.py": [
        {
            "methods": [
                {
                    "docstring": "\"\"\"Convert ``o`` to a JSON serializable type. See\n        :meth:`json.JSONEncoder.default`. Python does not support\n        overriding how basic types like ``str`` or ``list`` are\n        serialized, they are handled before this method.\n        \"\"\"",
                    "first_doc": "\"\"\"\nConverts the provided object to a JSON serializable type using custom handling for certain types.\n\nArgs:\n    self: The instance of the class.\n    o: The object to be serialized to a JSON-compatible type. Supports datetime, date, uuid.UUID, dataclasses, and objects with a __html__ method.\n\nReturns:\n    The JSON-serializable representation of the input object, or delegates to the superclass's default method if a custom conversion is not implemented.\n\"\"\"",
                    "method_name": "default",
                    "second_doc": "\"\"\"\nSerializes Python objects into JSON-compatible types by applying special handling for certain complex objects encountered frequently in web responses, such as dates, times, UUIDs, and objects with HTML representations. This ensures data sent in HTTP responses is correctly formatted and interpretable by clients.\n\nArgs:\n    self: The instance of the JSONEncoder.\n    o: The Python object to serialize. Supported types include datetime, date, uuid.UUID, dataclass instances, and objects implementing a __html__ method.\n\nReturns:\n    The JSON-serializable form of the input object if a recognized type is provided; otherwise, delegates to the superclass's default JSON encoding method.\n\"\"\"",
                    "source_code": "if isinstance(o, datetime):\n            return http_date(o.utctimetuple())\n        if isinstance(o, date):\n            return http_date(o.timetuple())\n        if isinstance(o, uuid.UUID):\n            return str(o)\n        if dataclasses and dataclasses.is_dataclass(o):\n            return dataclasses.asdict(o)\n        if hasattr(o, \"__html__\"):\n            return str(o.__html__())\n        return super().default(self, o)"
                }
            ],
            "name": "JSONEncoder",
            "type": "class"
        },
        {
            "methods": [],
            "name": "JSONDecoder",
            "type": "class"
        },
        {
            "details": {
                "docstring": "\"\"\"Inject default arguments for dump functions.\"\"\"",
                "first_doc": "\"\"\"\nSets default keyword arguments for JSON serialization based on the current application context.\n\nThis method configures default values in the kwargs dictionary, such as the JSON encoder, whether to ensure ASCII characters, and whether to sort keys, according to the current Flask application and request context.\n\nArgs:\n    kwargs: A dictionary containing keyword arguments to be used for JSON serialization. This will be updated in-place with sensible defaults if certain keys are not already set.\n\nReturns:\n    None: This method updates the provided kwargs dictionary in-place and does not return a value.\n\"\"\"",
                "method_name": "_dump_arg_defaults",
                "second_doc": "\"\"\"\nDetermines and sets sensible defaults for JSON serialization parameters in the provided keyword arguments dictionary, tailoring the serialization process to match the active application, blueprint, or request context.\n\nBy considering the relevant configuration and context, this method ensures that JSON output is consistent, adheres to user or application expectations, and minimizes the need for manual configuration when serializing data, leading to more predictable and maintainable behavior in response construction.\n\nArgs:\n    kwargs (dict): Dictionary of keyword arguments to update with JSON serialization defaults if certain keys are not already present.\n\nReturns:\n    None: The input kwargs dictionary is updated in place; no value is returned.\n\"\"\"",
                "source_code": "if app is None:\n        app = current_app\n\n    if app:\n        bp = app.blueprints.get(request.blueprint) if request else None\n        cls = bp.json_encoder if bp and bp.json_encoder else app.json_encoder\n        kwargs.setdefault(\"cls\", cls)\n        kwargs.setdefault(\"ensure_ascii\", app.config[\"JSON_AS_ASCII\"])\n        kwargs.setdefault(\"sort_keys\", app.config[\"JSON_SORT_KEYS\"])\n    else:\n        kwargs.setdefault(\"sort_keys\", True)\n        kwargs.setdefault(\"cls\", JSONEncoder)"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": "\"\"\"Inject default arguments for load functions.\"\"\"",
                "first_doc": "\"\"\"\nSets the default JSON decoder class in argument defaults if not already specified.\n\nIf an app context is available, uses a blueprint-specific JSON decoder if present; otherwise, uses the app's default JSON decoder. If no app is present, falls back to a standard JSON decoder. Updates the \"cls\" key in the kwargs dictionary accordingly.\n\nArgs:\n    kwargs: A dictionary of keyword arguments that may include configuration for JSON decoding. The method sets or overrides the \"cls\" key to specify the decoder class to use.\n\nReturns:\n    None: This method modifies the kwargs dictionary in place and does not return a value.\n\"\"\"",
                "method_name": "_load_arg_defaults",
                "second_doc": "\"\"\"\nDetermines and assigns the appropriate JSON decoder class for incoming data processing by updating the \"cls\" entry in the provided kwargs dictionary, prioritizing configuration from the current application context and its blueprints if available, or defaulting to a standard decoder when no context is present. This ensures consistency and adherence to any custom JSON decoding behaviors defined in the application's configuration, supporting correct parsing and extensibility of incoming request data.\n\nArgs:\n    kwargs (dict): A dictionary of keyword arguments that may contain JSON decoding configuration. The method sets or ensures the \"cls\" key specifies the decoder class to use for JSON parsing.\n\nReturns:\n    None: Modifies the kwargs dictionary in place to set JSON decoding behavior; does not return a separate value.\n\"\"\"",
                "source_code": "if app is None:\n        app = current_app\n\n    if app:\n        bp = app.blueprints.get(request.blueprint) if request else None\n        cls = bp.json_decoder if bp and bp.json_decoder else app.json_decoder\n        kwargs.setdefault(\"cls\", cls)\n    else:\n        kwargs.setdefault(\"cls\", JSONDecoder)"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": "\"\"\"Serialize an object to a string of JSON.\n\n    Takes the same arguments as the built-in :func:`json.dumps`, with\n    some defaults from application configuration.\n\n    :param obj: Object to serialize to JSON.\n    :param app: Use this app's config instead of the active app context\n        or defaults.\n    :param kwargs: Extra arguments passed to func:`json.dumps`.\n\n    .. versionchanged:: 2.0\n        ``encoding`` is deprecated and will be removed in 2.1.\n\n    .. versionchanged:: 1.0.3\n        ``app`` can be passed directly, rather than requiring an app\n        context for configuration.\n    \"\"\"",
                "first_doc": "\"\"\"\nSerializes a Python object to a JSON-formatted string.\n\nArgs:\n    obj: The Python object to serialize.\n\nReturns:\n    str or bytes: The JSON-encoded string representation of the object. If the deprecated 'encoding' argument is supplied via kwargs, the result will be returned as bytes encoded with the specified encoding.\n\"\"\"",
                "method_name": "dumps",
                "second_doc": "\"\"\"\nConverts a Python object into its JSON string representation for transferring or storing structured data.\n\nArgs:\n    obj: The Python object to serialize.\n    **kwargs: Additional keyword arguments passed to the underlying JSON serializer. May include the deprecated 'encoding' parameter.\n\nReturns:\n    str: The JSON-encoded representation of the object.\n    bytes: If the deprecated 'encoding' parameter is provided, returns the JSON string encoded into bytes using the specified encoding.\n\nRaises:\n    DeprecationWarning: If the 'encoding' argument is supplied, a deprecation warning is issued.\n\nWhy:\n    Serializing objects to JSON ensures consistent and reliable data exchange between different parts of an application, external services, or clients, supporting interoperability and flexible data handling.\n\"\"\"",
                "source_code": "_dump_arg_defaults(kwargs, app=app)\n    encoding = kwargs.pop(\"encoding\", None)\n    rv = _json.dumps(obj, **kwargs)\n\n    if encoding is not None:\n        warnings.warn(\n            \"'encoding' is deprecated and will be removed in 2.1.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n\n        if isinstance(rv, str):\n            return rv.encode(encoding)\n\n    return rv"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": "\"\"\"Serialize an object to JSON written to a file object.\n\n    Takes the same arguments as the built-in :func:`json.dump`, with\n    some defaults from application configuration.\n\n    :param obj: Object to serialize to JSON.\n    :param fp: File object to write JSON to.\n    :param app: Use this app's config instead of the active app context\n        or defaults.\n    :param kwargs: Extra arguments passed to func:`json.dump`.\n\n    .. versionchanged:: 2.0\n        Writing to a binary file, and the ``encoding`` argument, is\n        deprecated and will be removed in 2.1.\n    \"\"\"",
                "first_doc": "\"\"\"\nSerializes a Python object as a JSON-formatted stream to the given file-like object.\n\nArgs:\n    obj: The Python object to serialize as JSON.\n    fp: The file-like object to which the JSON data will be written.\n\nReturns:\n    None: This method does not return a value. The object is written to the file.\n\"\"\"",
                "method_name": "dump",
                "second_doc": "\"\"\"\nConverts a Python object into a JSON-formatted stream and writes it to the provided file-like object. This process ensures data structures can be stored or transmitted in a standardized, text-based format compatible with web technologies and APIs.\n\nArgs:\n    obj: The Python object to serialize as JSON.\n    fp: The file-like object (text or binary) where the JSON data will be written.\n    **kwargs: Additional keyword arguments for serialization settings, such as encoding.\n\nReturns:\n    None: The JSON-formatted data is written directly to the given file-like object.\n\"\"\"",
                "source_code": "_dump_arg_defaults(kwargs, app=app)\n    encoding = kwargs.pop(\"encoding\", None)\n    show_warning = encoding is not None\n\n    try:\n        fp.write(\"\")\n    except TypeError:\n        show_warning = True\n        fp = io.TextIOWrapper(fp, encoding or \"utf-8\")\n\n    if show_warning:\n        warnings.warn(\n            \"Writing to a binary file, and the 'encoding' argument, is\"\n            \" deprecated and will be removed in 2.1.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n\n    _json.dump(obj, fp, **kwargs)"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": "\"\"\"Deserialize an object from a string of JSON.\n\n    Takes the same arguments as the built-in :func:`json.loads`, with\n    some defaults from application configuration.\n\n    :param s: JSON string to deserialize.\n    :param app: Use this app's config instead of the active app context\n        or defaults.\n    :param kwargs: Extra arguments passed to func:`json.dump`.\n\n    .. versionchanged:: 2.0\n        ``encoding`` is deprecated and will be removed in 2.1. The data\n        must be a string or UTF-8 bytes.\n\n    .. versionchanged:: 1.0.3\n        ``app`` can be passed directly, rather than requiring an app\n        context for configuration.\n    \"\"\"",
                "first_doc": "\"\"\"\nParses a JSON-formatted string and returns the corresponding Python object.\n\nArgs:\n    s: The string to parse.\n\nReturns:\n    The Python object resulting from parsing the JSON data in the input string.\n\"\"\"",
                "method_name": "loads",
                "second_doc": "\"\"\"\nDeserializes a JSON-formatted input string or UTF-8 bytes into its corresponding Python data structure, handling deprecated encoding arguments for compatibility.\n\nArgs:\n    s: The JSON string or UTF-8 bytes to be deserialized.\n    **kwargs: Additional keyword arguments passed to the underlying JSON decoder.\n\nReturns:\n    The native Python object resulting from decoding the provided JSON data.\n\nThis method ensures that data received as JSON is correctly converted for use within the application's logic, enabling seamless data interchange and processing.\n\"\"\"",
                "source_code": "_load_arg_defaults(kwargs, app=app)\n    encoding = kwargs.pop(\"encoding\", None)\n\n    if encoding is not None:\n        warnings.warn(\n            \"'encoding' is deprecated and will be removed in 2.1. The\"\n            \" data must be a string or UTF-8 bytes.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n\n        if isinstance(s, bytes):\n            s = s.decode(encoding)\n\n    return _json.loads(s, **kwargs)"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": "\"\"\"Deserialize an object from JSON read from a file object.\n\n    Takes the same arguments as the built-in :func:`json.load`, with\n    some defaults from application configuration.\n\n    :param fp: File object to read JSON from.\n    :param app: Use this app's config instead of the active app context\n        or defaults.\n    :param kwargs: Extra arguments passed to func:`json.load`.\n\n    .. versionchanged:: 2.0\n        ``encoding`` is deprecated and will be removed in 2.1. The file\n        must be text mode, or binary mode with UTF-8 bytes.\n    \"\"\"",
                "first_doc": "\"\"\"\nLoad JSON data from a file-like object.\n\nThis method reads JSON-encoded data from the provided file-like object and returns the corresponding Python object.\n\nArgs:\n    fp: The file-like object from which to read JSON data.\n\nReturns:\n    The Python object resulting from decoding the JSON data from the file-like object.\n\"\"\"",
                "method_name": "load",
                "second_doc": "\"\"\"\nSafely loads and decodes JSON data from a file-like object, ensuring compatibility with expected text or UTF-8 encoded input. This method helps maintain smooth data interchange and configuration loading processes within the application.\n\nArgs:\n    fp: A file-like object from which the JSON data is read. Should be opened in text mode or in binary mode with UTF-8 encoding.\n    **kwargs: Additional keyword arguments passed to the underlying JSON decoder.\n\nReturns:\n    The Python object obtained by decoding the JSON content from the file-like object.\n\"\"\"",
                "source_code": "_load_arg_defaults(kwargs, app=app)\n    encoding = kwargs.pop(\"encoding\", None)\n\n    if encoding is not None:\n        warnings.warn(\n            \"'encoding' is deprecated and will be removed in 2.1. The\"\n            \" file must be text mode, or binary mode with UTF-8 bytes.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n\n        if isinstance(fp.read(0), bytes):\n            fp = io.TextIOWrapper(fp, encoding)\n\n    return _json.load(fp, **kwargs)"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": "\"\"\"Serialize an object to a string of JSON, replacing HTML-unsafe\n    characters with Unicode escapes. Otherwise behaves the same as\n    :func:`dumps`.\n\n    This is available in templates as the ``|tojson`` filter, which will\n    also mark the result with ``|safe``.\n\n    The returned string is safe to render in HTML documents and\n    ``<script>`` tags. The exception is in HTML attributes that are\n    double quoted; either use single quotes or the ``|forceescape``\n    filter.\n\n    .. versionchanged:: 0.10\n        Single quotes are escaped, making this safe to use in HTML,\n        ``<script>`` tags, and single-quoted attributes without further\n        escaping.\n    \"\"\"",
                "first_doc": "\"\"\"\nSerializes a Python object to a JSON-formatted string and escapes characters to make the output HTML-safe.\n\nArgs:\n    obj: The Python object to serialize.\n\nReturns:\n    str: A JSON-formatted string with characters escaped for safe insertion into HTML.\n\"\"\"",
                "method_name": "htmlsafe_dumps",
                "second_doc": "\"\"\"\nConverts a Python object into a JSON-formatted string with special characters escaped to ensure that embedding the output into HTML does not introduce security issues.\n\nArgs:\n    obj: The Python object to serialize into a JSON string.\n    **kwargs: Additional keyword arguments passed to the underlying JSON serializer.\n\nReturns:\n    str: The resulting JSON string with certain characters escaped for safe use within HTML markup.\n\"\"\"",
                "source_code": "return dumps(obj, **kwargs).translate(_htmlsafe_map)"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": "\"\"\"Serialize an object to JSON written to a file object, replacing\n    HTML-unsafe characters with Unicode escapes. See\n    :func:`htmlsafe_dumps` and :func:`dumps`.\n    \"\"\"",
                "first_doc": "\"\"\"\nSerializes an object and writes its HTML-safe representation to a file-like object.\n\nArgs:\n    obj: The object to serialize and write in an HTML-safe format.\n    fp: A file-like object with a write() method, where the serialized data will be written.\n\nReturns:\n    None: This method does not return any value.\n\"\"\"",
                "method_name": "htmlsafe_dump",
                "second_doc": "\"\"\"\nConverts an object to its HTML-safe serialized form and writes the result to a given file-like object, ensuring that the output is suitable for safe HTML display.\n\nArgs:\n    obj: The data object to be serialized into an HTML-safe format.\n    fp: A file-like object with a write() method to which the serialized HTML-safe output will be written.\n    **kwargs: Additional keyword arguments to customize the serialization process.\n\nReturns:\n    None: This function writes directly to the provided file-like object and does not return a value.\n    \nWhy:\n    This method helps prevent injection vulnerabilities or malformed markup when displaying user-generated or dynamic data in web contexts by ensuring all data written is safe for HTML rendering.\n\"\"\"",
                "source_code": "fp.write(htmlsafe_dumps(obj, **kwargs))"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": "\"\"\"Serialize data to JSON and wrap it in a :class:`~flask.Response`\n    with the :mimetype:`application/json` mimetype.\n\n    Uses :func:`dumps` to serialize the data, but ``args`` and\n    ``kwargs`` are treated as data rather than arguments to\n    :func:`json.dumps`.\n\n    1.  Single argument: Treated as a single value.\n    2.  Multiple arguments: Treated as a list of values.\n        ``jsonify(1, 2, 3)`` is the same as ``jsonify([1, 2, 3])``.\n    3.  Keyword arguments: Treated as a dict of values.\n        ``jsonify(data=data, errors=errors)`` is the same as\n        ``jsonify({\"data\": data, \"errors\": errors})``.\n    4.  Passing both arguments and keyword arguments is not allowed as\n        it's not clear what should happen.\n\n    .. code-block:: python\n\n        from flask import jsonify\n\n        @app.route(\"/users/me\")\n        def get_current_user():\n            return jsonify(\n                username=g.user.username,\n                email=g.user.email,\n                id=g.user.id,\n            )\n\n    Will return a JSON response like this:\n\n    .. code-block:: javascript\n\n        {\n          \"username\": \"admin\",\n          \"email\": \"admin@localhost\",\n          \"id\": 42\n        }\n\n    The default output omits indents and spaces after separators. In\n    debug mode or if :data:`JSONIFY_PRETTYPRINT_REGULAR` is ``True``,\n    the output will be formatted to be easier to read.\n\n    .. versionchanged:: 0.11\n        Added support for serializing top-level arrays. This introduces\n        a security risk in ancient browsers. See :ref:`security-json`.\n\n    .. versionadded:: 0.2\n    \"\"\"",
                "first_doc": "\"\"\"\nSerializes data to JSON and returns a Flask response object with the appropriate MIME type.\n\nDepending on the Flask application configuration and debug status, the JSON output may be pretty-printed.\n\nReturns:\n    A Flask response object containing the JSON-serialized data with the correct MIME type.\n\"\"\"",
                "method_name": "jsonify",
                "second_doc": "\"\"\"\nConverts Python data structures to a JSON-formatted string and wraps it in a Flask HTTP response with the correct MIME type.\n\nThe method adapts JSON formatting based on application configuration and debug status to improve readability during development or minimize size for production. This standardizes how data is transmitted in HTTP responses, facilitating reliable communication with web clients.\n\nArgs:\n    *args: Single positional argument or multiple arguments representing data to serialize.\n    **kwargs: Keyword arguments representing data to serialize.\n\nReturns:\n    flask.Response: A Flask response object containing the JSON-serialized data with the appropriate MIME type.\n    \nRaises:\n    TypeError: If both args and kwargs are provided, as behavior is undefined in this case.\n\"\"\"",
                "source_code": "indent = None\n    separators = (\",\", \":\")\n\n    if current_app.config[\"JSONIFY_PRETTYPRINT_REGULAR\"] or current_app.debug:\n        indent = 2\n        separators = (\", \", \": \")\n\n    if args and kwargs:\n        raise TypeError(\"jsonify() behavior undefined when passed both args and kwargs\")\n    elif len(args) == 1:  # single args are passed directly to dumps()\n        data = args[0]\n    else:\n        data = args or kwargs\n\n    return current_app.response_class(\n        f\"{dumps(data, indent=indent, separators=separators)}\\n\",\n        mimetype=current_app.config[\"JSONIFY_MIMETYPE\"],\n    )"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "tojson_filter",
                "second_doc": "\"\"\"\nSerializes a Python object to a JSON-formatted string marked as safe for inclusion in HTML templates.\n\nArgs:\n    obj: The Python object to be serialized.\n    **kwargs: Additional keyword arguments passed to the JSON serializer.\n\nReturns:\n    Markup: A string containing the JSON representation of the object, marked safe for preventing HTML escaping.\n\nWhy:\n    Ensures data can be embedded in templates as JSON without introducing security vulnerabilities or formatting issues, allowing for dynamic content rendering on web pages.\n\"\"\"",
                "source_code": "return Markup(htmlsafe_dumps(obj, **kwargs))"
            },
            "type": "function"
        }
    ],
    "flask/src/flask/json/tag.py": [
        {
            "methods": [
                {
                    "docstring": "\"\"\"Create a tagger for the given serializer.\"\"\"",
                    "first_doc": "\"\"\"\nInitializes a tagger for the provided serializer.\n\nArgs:\n    serializer: The serializer instance that will be associated with the tagger.\n\nAttributes:\n    serializer: Stores the provided serializer instance for use within the tagger.\n\nReturns:\n    None. This is a class constructor and does not return a value.\n\"\"\"",
                    "method_name": "__init__",
                    "second_doc": "\"\"\"\nAssociates a serializer instance with the JSONTag, enabling conversion between data representations.\n\nArgs:\n    serializer: An object responsible for serializing and deserializing data types handled by the tagger.\n\nReturns:\n    None\n\"\"\"",
                    "source_code": "self.serializer = serializer"
                },
                {
                    "docstring": "\"\"\"Check if the given value should be tagged by this tag.\"\"\"",
                    "first_doc": "\"\"\"\nCheck if the given value should be tagged by this tag.\n\nArgs:\n    value: The input value to be evaluated for tagging.\n\nReturns:\n    bool: True if the value should be tagged, False otherwise.\n\"\"\"",
                    "method_name": "check",
                    "second_doc": "\"\"\"\nDetermine whether a given value meets the criteria for tagging according to the tag's logic. This abstract check provides a mechanism for subclasses to implement specific tagging rules, facilitating flexible and customizable data handling for different tagging strategies.\n\nArgs:\n    value: The object or data input to be checked against the tag's requirements.\n\nReturns:\n    bool: True if the value satisfies the conditions for tagging; False otherwise.\n\"\"\"",
                    "source_code": "raise NotImplementedError"
                },
                {
                    "docstring": "\"\"\"Convert the Python object to an object that is a valid JSON type.\n        The tag will be added later.\"\"\"",
                    "first_doc": "\"\"\"\nConvert the given Python object to a valid JSON-serializable type.\n\nArgs:\n    self: The instance of the class.\n    value: The Python object to be converted to a valid JSON type.\n\nReturns:\n    An object that is compatible with JSON serialization.\n\"\"\"",
                    "method_name": "to_json",
                    "second_doc": "\"\"\"\nTransforms a Python object into a form that can be represented as JSON, ensuring compatibility for serialization within web responses or data exchanges. This abstraction allows subclasses to handle specific data types that may not be natively supported by standard JSON encoding.\n\nArgs:\n    self: Instance of the JSONTag class.\n    value: The Python object intended for JSON-compatible transformation.\n\nReturns:\n    An object suitable for JSON serialization, such as basic data types or structures supported by JSON encoding.\n\nRaises:\n    NotImplementedError: Indicates that subclasses must implement this method to define custom conversion logic for non-standard Python objects.\n\"\"\"",
                    "source_code": "raise NotImplementedError"
                },
                {
                    "docstring": "\"\"\"Convert the JSON representation back to the correct type. The tag\n        will already be removed.\"\"\"",
                    "first_doc": "\"\"\"\nConverts the provided JSON representation back to its corresponding Python type.\n\nArgs:\n    self: The instance of the class.\n    value: The JSON value to be converted back to the appropriate Python type.\n\nReturns:\n    The value converted to its appropriate Python type.\n\"\"\"",
                    "method_name": "to_python",
                    "second_doc": "\"\"\"\nDeserializes a JSON-compatible value into its corresponding Python type, enabling dynamic data exchange between the application and external clients.\n\nArgs:\n    self: The current instance of the JSONTag class.\n    value: The value obtained from a JSON structure that should be converted to a native Python representation.\n\nReturns:\n    The deserialized Python object corresponding to the given JSON value.\n\nRaises:\n    NotImplementedError: This method should be implemented by subclasses.\n\"\"\"",
                    "source_code": "raise NotImplementedError"
                },
                {
                    "docstring": "\"\"\"Convert the value to a valid JSON type and add the tag structure\n        around it.\"\"\"",
                    "first_doc": "\"\"\"\nConverts a value to a valid JSON type and wraps it in a tag structure using the object's key.\n\nArgs:\n    value: The data to be converted to a JSON-compatible type and tagged.\n\nReturns:\n    dict: A dictionary with the object's key as the single key and the converted value as its value, forming a tag structure.\n\"\"\"",
                    "method_name": "tag",
                    "second_doc": "\"\"\"\nSerializes a value into a JSON-compatible format and encapsulates it within a tagged dictionary structure using a designated key.\n\nArgs:\n    value: The data to be serialized into a JSON-compatible type.\n\nReturns:\n    dict: A dictionary containing the specified key mapped to the serialized value, facilitating consistent data structuring for further processing or transmission.\n\"\"\"",
                    "source_code": "return {self.key: self.to_json(value)}"
                }
            ],
            "name": "JSONTag",
            "type": "class"
        },
        {
            "methods": [
                {
                    "docstring": null,
                    "method_name": "check",
                    "second_doc": "\"\"\"\nChecks whether the given value is a dictionary containing exactly one key, and that key corresponds to a recognized tag in the serializer.\n\nArgs:\n    value: The object to be checked.\n\nReturns:\n    bool: True if value is a single-keyed dictionary whose key matches one of the recognized tags; False otherwise.\n\nWhy:\n    This validation ensures that only properly structured tag dictionaries recognized by the serializer are processed further, maintaining data consistency and expected behavior when handling tagged objects within the application.\n\"\"\"",
                    "source_code": "return (\n            isinstance(value, dict)\n            and len(value) == 1\n            and next(iter(value)) in self.serializer.tags\n        )"
                },
                {
                    "docstring": null,
                    "method_name": "to_json",
                    "second_doc": "\"\"\"\nSerializes a dictionary by extracting its single key-value pair, tagging the value, and preparing it for JSON encoding. This helps ensure consistent data formatting when transmitting or storing data structures that contain custom objects.\n\nArgs:\n    value (dict): A dictionary expected to have a single key-value pair representing the item to be serialized.\n\nReturns:\n    dict: A dictionary with a modified key and a value processed by the tag serializer for compatibility with downstream JSON-based processes.\n\"\"\"",
                    "source_code": "key = next(iter(value))\n        return {f\"{key}__\": self.serializer.tag(value[key])}"
                },
                {
                    "docstring": null,
                    "method_name": "to_python",
                    "second_doc": "\"\"\"\nConverts a specialized dictionary-like structure into a standard Python dictionary format.\nThis method extracts the key-value pair with the key modified by removing its last two characters.\n\nArgs:\n    value (dict): The input dictionary with keys intended for internal processing or transformation.\n\nReturns:\n    dict: A new dictionary with the processed key and its associated value.\n\nWhy:\n    Streamlining internal representations into standard Python dictionaries allows for easier manipulation, integration, or serialization, which is important for processes that require compatibility with common data structures.\n\"\"\"",
                    "source_code": "key = next(iter(value))\n        return {key[:-2]: value[key]}"
                }
            ],
            "name": "TagDict",
            "type": "class"
        },
        {
            "methods": [
                {
                    "docstring": null,
                    "method_name": "check",
                    "second_doc": "\"\"\"\nChecks whether the provided value is a dictionary.\n\nThis check helps ensure that the data being processed or stored has the expected structure, which is important for maintaining consistency and enabling further handling or transformation.\n\nArgs:\n    value: The object to be checked for dictionary type.\n\nReturns:\n    bool: True if the value is a dictionary, False otherwise.\n\"\"\"",
                    "source_code": "return isinstance(value, dict)"
                },
                {
                    "docstring": null,
                    "method_name": "to_json",
                    "second_doc": "\"\"\"\nSerializes a dictionary by applying a tagging function to each value, preparing the data for further processing or transmission.\n\nArgs:\n    value (dict): The dictionary whose values will be serialized and tagged.\n\nReturns:\n    dict: A new dictionary with the same keys as the input, but with each value processed using the serializer's tag method.\n\nWhy:\n    This ensures that complex or custom objects stored as dictionary values are properly marked or transformed, facilitating compatibility with JSON responses or other web-related data formats.\n\"\"\"",
                    "source_code": "return {k: self.serializer.tag(v) for k, v in value.items()}"
                }
            ],
            "name": "PassDict",
            "type": "class"
        },
        {
            "methods": [
                {
                    "docstring": null,
                    "method_name": "check",
                    "second_doc": "\"\"\"\nChecks if the provided value is of tuple type. \n\nThis ensures that only tuple values are processed, which can help maintain data consistency and prevent unexpected errors when handling tag data structures.\n\nArgs:\n    value: The object to be verified as a tuple.\n\nReturns:\n    bool: True if the value is a tuple, False otherwise.\n\"\"\"",
                    "source_code": "return isinstance(value, tuple)"
                },
                {
                    "docstring": null,
                    "method_name": "to_json",
                    "second_doc": "\"\"\"\nSerializes each item in the given value using the serializer's tag method.\n\nThis method transforms elements into a standardized tagged structure, which can be useful for consistent encoding, transmission, or storage within the application.\n\nArgs:\n    value (iterable): The collection of items to be serialized.\n\nReturns:\n    list: A list containing the serialized (tagged) representation of each input item.\n\"\"\"",
                    "source_code": "return [self.serializer.tag(item) for item in value]"
                },
                {
                    "docstring": null,
                    "method_name": "to_python",
                    "second_doc": "\"\"\"\nConverts the stored value into a standard Python tuple.\n\nArgs:\n    None\n\nReturns:\n    tuple: The underlying value represented as a tuple.\n\nThis method ensures compatibility with Python's tuple operations, which may be important when passing data internally or interacting with APIs expecting tuple input.\n\"\"\"",
                    "source_code": "return tuple(value)"
                }
            ],
            "name": "TagTuple",
            "type": "class"
        },
        {
            "methods": [
                {
                    "docstring": null,
                    "method_name": "check",
                    "second_doc": "\"\"\"\nChecks whether the given value is a list.\n\nThis method is used to ensure that the provided value conforms to an expected data structure, which supports predictable processing in contexts where list-type data is required.\n\nArgs:\n    value: The object to be checked.\n\nReturns:\n    bool: True if the value is a list, False otherwise.\n\"\"\"",
                    "source_code": "return isinstance(value, list)"
                },
                {
                    "docstring": null,
                    "method_name": "to_json",
                    "second_doc": "\"\"\"\nSerializes each item in the provided list using the configured serializer, allowing the list to be converted into a JSON-compatible format. This enables consistent encoding of complex Python objects for transmission or storage, which is essential for web application data interchange and API responses.\n\nArgs:\n    value (list): A list of items to be serialized.\n\nReturns:\n    list: A list of serialized items, each processed for JSON compatibility.\n\"\"\"",
                    "source_code": "return [self.serializer.tag(item) for item in value]"
                }
            ],
            "name": "PassList",
            "type": "class"
        },
        {
            "methods": [
                {
                    "docstring": null,
                    "method_name": "check",
                    "second_doc": "\"\"\"\nChecks whether the given value is of type bytes.\n\nThis is important for ensuring consistent and correct handling of raw binary data, which is often required when processing or transmitting information between different parts of a web application.\n\nArgs:\n    value: The input to check for bytes type.\n\nReturns:\n    bool: True if the value is a bytes object, False otherwise.\n\"\"\"",
                    "source_code": "return isinstance(value, bytes)"
                },
                {
                    "docstring": null,
                    "method_name": "to_json",
                    "second_doc": "\"\"\"\nConverts the given byte value into a base64-encoded ASCII string representation.\n\nThis method is used to ensure data can be safely and consistently serialized for transmission or storage, particularly in contexts where binary data must be represented as text.\n\nArgs:\n    value (bytes): The byte sequence to encode.\n\nReturns:\n    str: The base64-encoded ASCII string representation of the input bytes.\n\"\"\"",
                    "source_code": "return b64encode(value).decode(\"ascii\")"
                },
                {
                    "docstring": null,
                    "method_name": "to_python",
                    "second_doc": "\"\"\"\nDecodes a base64-encoded value into its original byte representation.\n\nThis method ensures that data stored in a serialized or transport-safe format can be accurately converted back to its original binary form for further processing or use.\n\nArgs:\n    value (str or bytes): The base64-encoded value to decode.\n\nReturns:\n    bytes: The decoded byte sequence representing the original data.\n\"\"\"",
                    "source_code": "return b64decode(value)"
                }
            ],
            "name": "TagBytes",
            "type": "class"
        },
        {
            "methods": [
                {
                    "docstring": null,
                    "method_name": "check",
                    "second_doc": "\"\"\"\nChecks whether the given value has a __html__ method, indicating it can be safely rendered as HTML.\n\nThis determination is necessary to ensure that objects passed into HTML-rendering contexts can provide their own safe HTML representation, helping prevent injection of unsafe or untrusted markup.\n\nArgs:\n    value: The object to check for a __html__ method.\n\nReturns:\n    bool: True if the value has a callable __html__ method, False otherwise.\n\"\"\"",
                    "source_code": "return callable(getattr(value, \"__html__\", None))"
                },
                {
                    "docstring": null,
                    "method_name": "to_json",
                    "second_doc": "\"\"\"\nConverts the HTML representation of the value to a JSON-compatible string format.\n\nThis method ensures the HTML content produced by the value is safely and correctly serialized, which is necessary for transmitting or storing rendered template data in web applications.\n\nArgs:\n    value: An object that implements the __html__() method, providing its HTML markup.\n\nReturns:\n    str: The string representation of the rendered HTML, suitable for JSON serialization or output.\n\"\"\"",
                    "source_code": "return str(value.__html__())"
                },
                {
                    "docstring": null,
                    "method_name": "to_python",
                    "second_doc": "\"\"\"\nConverts the given value into a Markup object, ensuring the value is safely treated as pre-escaped HTML.\n\nArgs:\n    value: The input to be wrapped safely as HTML.\n\nReturns:\n    Markup: An object representing the sanitized HTML, preventing unwanted escaping when rendering to templates.\n\nWhy:\n    This method is used to safely handle and output content as HTML in templates, preventing security issues like double escaping or injection, and ensuring web pages display intended markup.\n\"\"\"",
                    "source_code": "return Markup(value)"
                }
            ],
            "name": "TagMarkup",
            "type": "class"
        },
        {
            "methods": [
                {
                    "docstring": null,
                    "method_name": "check",
                    "second_doc": "\"\"\"\nValidates whether the provided value is a UUID instance.\n\nThis method is used to ensure that a value conforms to the expected UUID type, facilitating type safety and consistent data handling within the application.\n\nArgs:\n    value: The value to be checked for UUID type.\n\nReturns:\n    bool: True if the value is an instance of UUID, False otherwise.\n\"\"\"",
                    "source_code": "return isinstance(value, UUID)"
                },
                {
                    "docstring": null,
                    "method_name": "to_json",
                    "second_doc": "\"\"\"\nSerializes the UUID value of the tag to a JSON-compatible hexadecimal string.\n\nArgs:\n    value (uuid.UUID): The UUID object representing the tag.\n\nReturns:\n    str: A hexadecimal string representation of the UUID suitable for JSON serialization.\n\nWhy:\n    Converting UUID objects to hexadecimal strings allows them to be easily included in JSON responses or data exchanges, facilitating communication between the server and clients in a standardized format.\n\"\"\"",
                    "source_code": "return value.hex"
                },
                {
                    "docstring": null,
                    "method_name": "to_python",
                    "second_doc": "\"\"\"\nConverts the provided value into a standard Python UUID object to ensure uniform handling and validation of UUID data within the application.\n\nArgs:\n    value: The input value expected to represent a UUID.\n\nReturns:\n    UUID: A Python UUID object created from the input value.\n\"\"\"",
                    "source_code": "return UUID(value)"
                }
            ],
            "name": "TagUUID",
            "type": "class"
        },
        {
            "methods": [
                {
                    "docstring": null,
                    "method_name": "check",
                    "second_doc": "\"\"\"\nChecks if the provided value is an instance of a datetime object.\n\nThis verification is necessary to ensure that the value conforms to expected data types when processing or validating time-related information.\n\nArgs:\n    value: The object to be checked.\n\nReturns:\n    bool: True if value is an instance of datetime, otherwise False.\n\"\"\"",
                    "source_code": "return isinstance(value, datetime)"
                },
                {
                    "docstring": null,
                    "method_name": "to_json",
                    "second_doc": "\"\"\"\nConverts a datetime value to an HTTP-date formatted string suitable for use in HTTP headers.\n\nArgs:\n    value (datetime): The datetime value to be formatted.\n\nReturns:\n    str: The formatted date string compliant with HTTP standards.\n\nWhy:\n    HTTP headers often require dates to be formatted in a specific way for protocol compliance and interoperability between clients and servers. This method ensures consistent and correct date serialization for use in HTTP communication.\n\"\"\"",
                    "source_code": "return http_date(value)"
                },
                {
                    "docstring": null,
                    "method_name": "to_python",
                    "second_doc": "\"\"\"\nConverts a string value into a Python datetime object by parsing its date and time format.\nThis allows the application to work with dates and times in a consistent and native manner during request processing or data manipulation.\n\nArgs:\n    value (str): The string representation of a date and time.\n\nReturns:\n    datetime.datetime: The parsed datetime object corresponding to the input value.\n\"\"\"",
                    "source_code": "return parse_date(value)"
                }
            ],
            "name": "TagDateTime",
            "type": "class"
        },
        {
            "methods": [
                {
                    "docstring": null,
                    "method_name": "__init__",
                    "second_doc": "\"\"\"\nInitializes a TaggedJSONSerializer by setting up internal data structures for managing serializers associated with specific data types and registering default serialization handlers.\n\nArgs:\n    None\n\nReturns:\n    None\n\nWhy:\n    This initialization ensures that custom tagging and serialization mechanisms are ready to handle Flask's need for reliably encoding and decoding complex data types in JSON payloads, supporting features such as secure session management and advanced data handling.\n\"\"\"",
                    "source_code": "self.tags = {}\n        self.order = []\n\n        for cls in self.default_tags:\n            self.register(cls)"
                },
                {
                    "docstring": "\"\"\"Register a new tag with this serializer.\n\n        :param tag_class: tag class to register. Will be instantiated with this\n            serializer instance.\n        :param force: overwrite an existing tag. If false (default), a\n            :exc:`KeyError` is raised.\n        :param index: index to insert the new tag in the tag order. Useful when\n            the new tag is a special case of an existing tag. If ``None``\n            (default), the tag is appended to the end of the order.\n\n        :raise KeyError: if the tag key is already registered and ``force`` is\n            not true.\n        \"\"\"",
                    "first_doc": "\"\"\"\nRegisters a new tag with the serializer.\n\nThis method creates an instance of the given tag class, associates it with the serializer, and inserts it into the serializer's collection of tags. The method ensures that each tag's key is unique within the serializer, unless overwriting is explicitly allowed.\n\nArgs:\n    tag_class: The tag class to register. The tag class will be instantiated with this serializer instance.\n\nReturns:\n    None. The tag is registered with the serializer's internal structures.\n\"\"\"",
                    "method_name": "register",
                    "second_doc": "\"\"\"\nRegisters a tag handler with the serializer to enable custom processing of specific data types.\n\nBy storing the tag instance and managing its position in the processing order, this method ensures that the serializer can correctly interpret and serialize complex or user-defined Python objects. Enforcing unique tag keys prevents conflicts and maintains consistency in the serialization process.\n\nArgs:\n    tag_class: The class of the tag to register. This class is instantiated with the serializer instance.\n    force (bool, optional): If True, overwrite an existing tag with the same key. Defaults to False.\n    index (int, optional): The specific position to insert the tag in the processing order. If None, the tag is added to the end.\n\nReturns:\n    None\n\"\"\"",
                    "source_code": "tag = tag_class(self)\n        key = tag.key\n\n        if key is not None:\n            if not force and key in self.tags:\n                raise KeyError(f\"Tag '{key}' is already registered.\")\n\n            self.tags[key] = tag\n\n        if index is None:\n            self.order.append(tag)\n        else:\n            self.order.insert(index, tag)"
                },
                {
                    "docstring": "\"\"\"Convert a value to a tagged representation if necessary.\"\"\"",
                    "first_doc": "\"\"\"\nConverts the provided value to a tagged representation if applicable.\n\nIterates through a predefined order of tags and applies the first matching tag to the value. If no tag matches, returns the original value unchanged.\n\nArgs:\n    value: The value to be converted to a tagged representation.\n\nReturns:\n    The tagged representation of the value if a matching tag is found; otherwise, the original value.\n\"\"\"",
                    "method_name": "tag",
                    "second_doc": "\"\"\"\nAttempts to convert the given value into a specialized serialized form by checking a series of tagging strategies in a specific order. This transformation enables values to be represented in a way that preserves their type and semantics when encoding structured data, ensuring correct handling during storage or transmission. If no suitable representation is found, the value is left unchanged.\n\nArgs:\n    value: The input to be examined and possibly converted into a tagged serialization format.\n\nReturns:\n    The value in a serialized tagged format if a matching conversion strategy is applicable; otherwise, the original unmodified value.\n\"\"\"",
                    "source_code": "for tag in self.order:\n            if tag.check(value):\n                return tag.tag(value)\n\n        return value"
                },
                {
                    "docstring": "\"\"\"Convert a tagged representation back to the original type.\"\"\"",
                    "first_doc": "\"\"\"\nConverts a tagged representation back to its original Python type.\n\nThis method checks whether the provided value is a tagged object. If so, it uses the corresponding handler to convert the tagged value back to its original Python type; otherwise, the value is returned unmodified.\n\nArgs:\n    self: The instance of the class.\n    value: The value to be checked and potentially converted from a tagged representation.\n\nReturns:\n    The original Python value if the input was a recognized tagged object; otherwise, the input value unchanged.\n\"\"\"",
                    "method_name": "untag",
                    "second_doc": "\"\"\"\nRestores a Python object from its tagged representation if applicable.\n\nThis method determines if the provided value matches a known tagged format. When a handler is registered for this tag, the appropriate conversion logic is applied to recover the original Python type. This enables seamless serialization and deserialization of complex objects that cannot be represented natively.\n\nArgs:\n    value: The value to be inspected and potentially converted from a tagged representation.\n\nReturns:\n    The converted Python value if the input matches a recognized tag, or the value itself if no valid tag is found.\n\"\"\"",
                    "source_code": "if len(value) != 1:\n            return value\n\n        key = next(iter(value))\n\n        if key not in self.tags:\n            return value\n\n        return self.tags[key].to_python(value[key])"
                },
                {
                    "docstring": "\"\"\"Tag the value and dump it to a compact JSON string.\"\"\"",
                    "first_doc": "\"\"\"\nSerializes the given value by tagging it and converting it to a compact JSON string.\n\nArgs:\n    self: The instance of the class.\n    value: The value to be tagged and serialized.\n\nReturns:\n    str: A compact JSON string representing the tagged value.\n\"\"\"",
                    "method_name": "dumps",
                    "second_doc": "\"\"\"\nConverts the input value into a compact, tagged JSON string for safe storage or transmission within the application's data handling processes.\n\nArgs:\n    self: The instance of TaggedJSONSerializer.\n    value: The data to be tagged and serialized into JSON format.\n\nReturns:\n    str: A compact JSON string with tagging information, suitable for precise reconstruction of the original value by the deserializer.\n\"\"\"",
                    "source_code": "return dumps(self.tag(value), separators=(\",\", \":\"))"
                },
                {
                    "docstring": "\"\"\"Load data from a JSON string and deserialized any tagged objects.\"\"\"",
                    "first_doc": "\"\"\"\nLoads data from a JSON string and deserializes any tagged objects using a custom object hook.\n\nArgs:\n    self: The instance of the class.\n    value: The JSON string to be loaded and deserialized.\n\nReturns:\n    The deserialized Python object obtained from the JSON string, with any tagged objects processed accordingly.\n\"\"\"",
                    "method_name": "loads",
                    "second_doc": "\"\"\"\nDeserializes a JSON string and reconstructs any special tagged Python objects using a custom decoding process.\n\nArgs:\n    self: Instance of the TaggedJSONSerializer handling the deserialization.\n    value: The JSON-encoded string to be parsed.\n\nReturns:\n    The resulting Python object created from the JSON string, with any tagged constructs properly restored.\n\nWhy:\n    This method allows complex Python objects to be safely stored and retrieved using JSON, ensuring data integrity when exchanging structured data between different components or sessions.\n\"\"\"",
                    "source_code": "return loads(value, object_hook=self.untag)"
                }
            ],
            "name": "TaggedJSONSerializer",
            "type": "class"
        }
    ],
    "flask/src/flask/logging.py": [
        {
            "details": {
                "docstring": "\"\"\"Find the most appropriate error stream for the application. If a request\n    is active, log to ``wsgi.errors``, otherwise use ``sys.stderr``.\n\n    If you configure your own :class:`logging.StreamHandler`, you may want to\n    use this for the stream. If you are using file or dict configuration and\n    can't import this directly, you can refer to it as\n    ``ext://flask.logging.wsgi_errors_stream``.\n    \"\"\"",
                "first_doc": "\"\"\"\nReturns the appropriate error stream for WSGI environments.\n\nIf there is an active request, retrieves the WSGI error stream from the request's environment. If not, defaults to the system standard error stream.\n\nReturns:\n    A stream object used for error logging. This will be either the WSGI error stream from the current request or sys.stderr if no request is available.\n\"\"\"",
                "method_name": "wsgi_errors_stream",
                "second_doc": "\"\"\"\nObtains the correct error output stream based on the context of execution.\n\nThis method ensures that error messages and logs are directed to the appropriate output target depending on whether a web request is currently being handled. By preferring the WSGI error stream during active requests and otherwise defaulting to the system's standard error, error information is consistently routed for proper collection and debugging.\n\nArgs:\n    None\n\nReturns:\n    A stream-like object for error output. Returns the WSGI error stream if an active request exists; otherwise, returns sys.stderr.\n\"\"\"",
                "source_code": "return request.environ[\"wsgi.errors\"] if request else sys.stderr"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": "\"\"\"Check if there is a handler in the logging chain that will handle the\n    given logger's :meth:`effective level <~logging.Logger.getEffectiveLevel>`.\n    \"\"\"",
                "first_doc": "\"\"\"\nDetermines if the specified logger or any of its ancestors has a handler with an effective level less than or equal to the logger's effective level.\n\nArgs:\n    logger: The logger to check for a suitable handler. The method will also inspect ancestor loggers if propagation is enabled.\n\nReturns:\n    bool: True if the logger or any ancestor has a suitable handler; otherwise, False.\n\"\"\"",
                "method_name": "has_level_handler",
                "second_doc": "\"\"\"\nChecks whether the given logger or any of its ancestors is capable of handling messages at the logger's effective level or lower by possessing a handler set to the appropriate level. This ensures that log messages will be appropriately processed, supporting effective debugging and observability of application behavior.\n\nArgs:\n    logger: The logger instance whose handler hierarchy is to be checked. If propagation is enabled, ancestor loggers are also considered.\n\nReturns:\n    bool: True if a handler exists on the logger or its ancestors that will process messages at the logger's effective level or lower; False otherwise.\n\"\"\"",
                "source_code": "level = logger.getEffectiveLevel()\n    current = logger\n\n    while current:\n        if any(handler.level <= level for handler in current.handlers):\n            return True\n\n        if not current.propagate:\n            break\n\n        current = current.parent\n\n    return False"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": "\"\"\"Get the Flask app's logger and configure it if needed.\n\n    The logger name will be the same as\n    :attr:`app.import_name <flask.Flask.name>`.\n\n    When :attr:`~flask.Flask.debug` is enabled, set the logger level to\n    :data:`logging.DEBUG` if it is not set.\n\n    If there is no handler for the logger's effective level, add a\n    :class:`~logging.StreamHandler` for\n    :func:`~flask.logging.wsgi_errors_stream` with a basic format.\n    \"\"\"",
                "first_doc": "\"\"\"\nCreates and configures a logger for the given app instance.\n\nThis method obtains a logger using the application's name, sets its log level to DEBUG if the application is in debug mode and the logger does not already have a logging level set, and ensures that it has at least one handler. If no handlers are present, a default handler is added.\n\nArgs:\n    app: The application instance for which the logger is created. Should have attributes 'name' and 'debug'.\n\nReturns:\n    Logger: The configured logger instance for the application.\n\"\"\"",
                "method_name": "create_logger",
                "second_doc": "\"\"\"\nInitializes and configures a logger tailored to the application's needs, ensuring consistent and appropriate log handling based on the application's state.\n\nBy dynamically configuring the logger level and adding a default handler if none are present, this method guarantees that debug and runtime information is properly captured and routed during application execution.\n\nArgs:\n    app: An application instance with 'name' and 'debug' attributes, used to uniquely identify the logger and determine if debug logging should be enabled.\n\nReturns:\n    logging.Logger: The logger instance configured according to the application's settings.\n\"\"\"",
                "source_code": "logger = logging.getLogger(app.name)\n\n    if app.debug and not logger.level:\n        logger.setLevel(logging.DEBUG)\n\n    if not has_level_handler(logger):\n        logger.addHandler(default_handler)\n\n    return logger"
            },
            "type": "function"
        }
    ],
    "flask/src/flask/sessions.py": [
        {
            "methods": [
                {
                    "docstring": "\"\"\"This reflects the ``'_permanent'`` key in the dict.\"\"\"",
                    "first_doc": "\"\"\"\nReturns whether the '_permanent' key is set in the dictionary.\n\nArgs:\n    self: The instance of the dictionary-derived class.\n\nReturns:\n    bool: True if the '_permanent' key exists and is True; otherwise, False.\n\"\"\"",
                    "method_name": "permanent",
                    "second_doc": "\"\"\"\nChecks if the session is marked to be persistent across browser restarts, based on the presence and value of the '_permanent' attribute.\n\nArgs:\n    self: The session object to be checked.\n\nReturns:\n    bool: True if the session is designated as permanent; otherwise, False.\n\"\"\"",
                    "source_code": "return self.get(\"_permanent\", False)"
                },
                {
                    "docstring": null,
                    "method_name": "permanent",
                    "second_doc": "\"\"\"\nSets whether the user session should be considered permanent, affecting how long the session data is retained.\n\nThis method updates the internal session state to indicate the permanence of a session. Permanent sessions are designed to persist beyond browser restarts, while non-permanent sessions are typically cleared when the browser is closed. This enables control over session lifetime according to application requirements.\n\nArgs:\n    value (bool): If True, marks the session as permanent; if False, marks the session as non-permanent.\n\nReturns:\n    None\n\"\"\"",
                    "source_code": "self[\"_permanent\"] = bool(value)"
                }
            ],
            "name": "SessionMixin",
            "type": "class"
        },
        {
            "methods": [
                {
                    "docstring": null,
                    "method_name": "__init__",
                    "second_doc": "\"\"\"\nMarks the session as both modified and accessed when changes occur, ensuring the session state accurately reflects user interactions.\n\nArgs:\n    initial (dict): The initial data for the session.\n\nReturns:\n    None\n\"\"\"",
                    "source_code": "def on_update(self):\n            self.modified = True\n            self.accessed = True\n\n        super().__init__(initial, on_update)"
                },
                {
                    "docstring": null,
                    "method_name": "__getitem__",
                    "second_doc": "\"\"\"\nMarks the session as accessed and retrieves the value associated with the given key.\n\nArgs:\n    key: The session key whose value is to be retrieved.\n\nReturns:\n    The value corresponding to the provided key from the session data.\n\nWhy:\n    This method ensures the session is flagged as accessed whenever data is retrieved, allowing accurate session management and lifecycle handling.\n\"\"\"",
                    "source_code": "self.accessed = True\n        return super().__getitem__(key)"
                },
                {
                    "docstring": null,
                    "method_name": "get",
                    "second_doc": "\"\"\"\nRetrieves a value from the session data using the specified key, marking the session as accessed to ensure it is properly tracked.\n\nArgs:\n    key (str): The key whose value should be retrieved from the session.\n    default (Any, optional): The value to return if the key is not found in the session. Defaults to None.\n\nReturns:\n    Any: The value associated with the provided key if it exists; otherwise, the default value.\n\nWhy:\n    Marking the session as accessed helps manage changes to session state, ensuring accurate tracking for persistence or updates during web request handling.\n\"\"\"",
                    "source_code": "self.accessed = True\n        return super().get(key, default)"
                },
                {
                    "docstring": null,
                    "method_name": "setdefault",
                    "second_doc": "\"\"\"\nMarks the session as accessed and retrieves the value for the given key, setting it to the default if it does not exist.\n\nThis ensures that the session's accessed state is updated whenever data is read or modified, supporting proper session management and consistency.\n\nArgs:\n    key: The key to look up in the session data.\n    default: The default value to set and return if the key is not present.\n\nReturns:\n    The value associated with the key if it exists, otherwise the provided default value.\n\"\"\"",
                    "source_code": "self.accessed = True\n        return super().setdefault(key, default)"
                }
            ],
            "name": "SecureCookieSession",
            "type": "class"
        },
        {
            "methods": [
                {
                    "docstring": null,
                    "method_name": "_fail",
                    "second_doc": "\"\"\"\nRaises an error indicating that the session cannot be accessed due to a missing secret key configuration. \n\nThis ensures that session data is protected and not inadvertently exposed or used insecurely.\n\nRaises:\n    RuntimeError: If no secret key is set for the application, preventing session usage.\n\"\"\"",
                    "source_code": "raise RuntimeError(\n            \"The session is unavailable because no secret \"\n            \"key was set.  Set the secret_key on the \"\n            \"application to something unique and secret.\"\n        )"
                }
            ],
            "name": "NullSession",
            "type": "class"
        },
        {
            "methods": [
                {
                    "docstring": "\"\"\"Creates a null session which acts as a replacement object if the\n        real session support could not be loaded due to a configuration\n        error.  This mainly aids the user experience because the job of the\n        null session is to still support lookup without complaining but\n        modifications are answered with a helpful error message of what\n        failed.\n\n        This creates an instance of :attr:`null_session_class` by default.\n        \"\"\"",
                    "first_doc": "\"\"\"\nCreates and returns a null session object as a fallback.\n\nThis method generates a null session when the real session support cannot be loaded due to a configuration error. The null session enables safe lookup operations without raising errors and prohibits modification operations, providing a helpful error message to the user instead. By default, it creates an instance of the `null_session_class` attribute.\n\nArgs:\n    self: The current instance of the class.\n    app: The application instance for which the null session is being created.\n\nReturns:\n    object: An instance of the class specified by the `null_session_class` attribute, serving as a no-operation session replacement.\n\"\"\"",
                    "method_name": "make_null_session",
                    "second_doc": "\"\"\"\nCreates and returns a null session object to ensure the application can continue operating even if session functionality is unavailable.\n\nThis method produces a fallback \"null session\" object when normal session support cannot be initialized\u2014typically due to configuration issues. The null session permits read-only access to session-related operations without raising exceptions and blocks any modifications by providing informative error feedback, thus maintaining application stability and user awareness when session management fails.\n\nArgs:\n    self: The session interface instance invoking this method.\n    app: The Flask application instance requesting a session object.\n\nReturns:\n    object: An instance of the `null_session_class`, functioning as a safe, non-modifiable session placeholder.\n\"\"\"",
                    "source_code": "return self.null_session_class()"
                },
                {
                    "docstring": "\"\"\"Checks if a given object is a null session.  Null sessions are\n        not asked to be saved.\n\n        This checks if the object is an instance of :attr:`null_session_class`\n        by default.\n        \"\"\"",
                    "first_doc": "\"\"\"\nDetermines whether the provided object is a null session.\n\nChecks if the given object is an instance of the class specified by the object's 'null_session_class' attribute. Null sessions are not persisted or saved.\n\nArgs:\n    self: The instance of the class in which this method is defined.\n    obj: The object to check for being a null session.\n\nReturns:\n    bool: True if the object is a null session, False otherwise.\n\"\"\"",
                    "method_name": "is_null_session",
                    "second_doc": "\"\"\"\nChecks if the provided object represents a null session by verifying its type against the expected null session class.\n\nThis check is necessary to determine whether session-related data should be stored or managed, helping prevent operations on temporary or placeholder session objects.\n\nArgs:\n    self: The instance of SessionInterface.\n    obj: The object to be checked for being a null session.\n\nReturns:\n    bool: True if obj is an instance of the configured null session class (indicating it is a null session), False otherwise.\n\"\"\"",
                    "source_code": "return isinstance(obj, self.null_session_class)"
                },
                {
                    "docstring": "\"\"\"Returns the name of the session cookie.\n\n        Uses ``app.session_cookie_name`` which is set to ``SESSION_COOKIE_NAME``\n        \"\"\"",
                    "first_doc": "\"\"\"\nReturns the name of the session cookie.\n\nRetrieves the session cookie name from the provided application object using its configured `session_cookie_name` attribute, which is typically set based on the application's `SESSION_COOKIE_NAME` setting.\n\nArgs:\n    self: The class instance.\n    app: The application object from which to obtain the session cookie name.\n\nReturns:\n    The name of the session cookie as defined in the application's configuration.\n\"\"\"",
                    "method_name": "get_cookie_name",
                    "second_doc": "\"\"\"\nFetches the name assigned to the session cookie for the given application instance.\n\nThis method accesses the application's session configuration to determine the identifier used for client-side session management. By retrieving the cookie name, the method ensures that other components can consistently reference or manipulate the session data stored in the user's browser.\n\nArgs:\n    self: The instance of the class invoking the method.\n    app: The application object whose session cookie name is to be accessed.\n\nReturns:\n    str: The string representing the session cookie's name as specified in the application's configuration.\n\"\"\"",
                    "source_code": "return app.session_cookie_name"
                },
                {
                    "docstring": "\"\"\"Returns the domain that should be set for the session cookie.\n\n        Uses ``SESSION_COOKIE_DOMAIN`` if it is configured, otherwise\n        falls back to detecting the domain based on ``SERVER_NAME``.\n\n        Once detected (or if not set at all), ``SESSION_COOKIE_DOMAIN`` is\n        updated to avoid re-running the logic.\n        \"\"\"",
                    "first_doc": "\"\"\"\nDetermines and returns the domain to be used for the session cookie.\n\nThe method checks whether a domain for the session cookie is explicitly set in the application's configuration. If it is not set, the domain is derived from the server name, safely handling edge cases such as localhost or IP addresses. The computed or detected value is stored for subsequent requests to avoid redundant processing.\n\nArgs:\n    self: The instance of the class invoking this method.\n    app: The application instance whose configuration is used to determine the session cookie domain.\n\nReturns:\n    The domain that should be set for the session cookie, as a string. Returns None if no suitable domain is found.\n\"\"\"",
                    "method_name": "get_cookie_domain",
                    "second_doc": "\"\"\"\nDetermines and returns the appropriate domain to be set for the session cookie, based on the application's configuration and server name.\n\nThis method checks if the session cookie domain has been explicitly specified; if not, it intelligently derives it from the server name, accounting for various edge cases such as localhost, IP addresses, or missing configuration. It also ensures the derived domain follows browser compatibility requirements and caches the result to optimize performance in subsequent requests.\n\nThis mechanism is essential to help scopes session cookies securely and reliably to the intended domain context, reducing security risks and ensuring browser compatibility.\n\nArgs:\n    self: The SessionInterface instance invoking this method.\n    app: The Flask application instance whose configuration is checked for determining the session cookie domain.\n\nReturns:\n    str or None: The domain string to be set for the session cookie. Returns None if an appropriate domain cannot be determined.\n\"\"\"",
                    "source_code": "rv = app.config[\"SESSION_COOKIE_DOMAIN\"]\n\n        # set explicitly, or cached from SERVER_NAME detection\n        # if False, return None\n        if rv is not None:\n            return rv if rv else None\n\n        rv = app.config[\"SERVER_NAME\"]\n\n        # server name not set, cache False to return none next time\n        if not rv:\n            app.config[\"SESSION_COOKIE_DOMAIN\"] = False\n            return None\n\n        # chop off the port which is usually not supported by browsers\n        # remove any leading '.' since we'll add that later\n        rv = rv.rsplit(\":\", 1)[0].lstrip(\".\")\n\n        if \".\" not in rv:\n            # Chrome doesn't allow names without a '.'. This should only\n            # come up with localhost. Hack around this by not setting\n            # the name, and show a warning.\n            warnings.warn(\n                f\"{rv!r} is not a valid cookie domain, it must contain\"\n                \" a '.'. Add an entry to your hosts file, for example\"\n                f\" '{rv}.localdomain', and use that instead.\"\n            )\n            app.config[\"SESSION_COOKIE_DOMAIN\"] = False\n            return None\n\n        ip = is_ip(rv)\n\n        if ip:\n            warnings.warn(\n                \"The session cookie domain is an IP address. This may not work\"\n                \" as intended in some browsers. Add an entry to your hosts\"\n                ' file, for example \"localhost.localdomain\", and use that'\n                \" instead.\"\n            )\n\n        # if this is not an ip and app is mounted at the root, allow subdomain\n        # matching by adding a '.' prefix\n        if self.get_cookie_path(app) == \"/\" and not ip:\n            rv = f\".{rv}\"\n\n        app.config[\"SESSION_COOKIE_DOMAIN\"] = rv\n        return rv"
                },
                {
                    "docstring": "\"\"\"Returns the path for which the cookie should be valid.  The\n        default implementation uses the value from the ``SESSION_COOKIE_PATH``\n        config var if it's set, and falls back to ``APPLICATION_ROOT`` or\n        uses ``/`` if it's ``None``.\n        \"\"\"",
                    "first_doc": "\"\"\"\nDetermines the path for which a session cookie should be valid.\n\nThis method selects the session cookie path using the application's configuration variables. It first checks if the 'SESSION_COOKIE_PATH' config variable is set, then falls back to 'APPLICATION_ROOT' if not, and finally defaults to '/' if none are set.\n\nArgs:\n    self: The instance of the object calling this method.\n    app: The application object whose config is used to determine the cookie path.\n\nReturns:\n    The path as a string for which the session cookie will be valid.\n\"\"\"",
                    "method_name": "get_cookie_path",
                    "second_doc": "\"\"\"\nDetermines the path for which the session cookie will be set based on the application's configuration.\n\nBy choosing the most specific configuration value available, this method ensures that session cookies are scoped appropriately within the application, helping to maintain session integrity and control how cookies are shared across different routes or subpaths.\n\nArgs:\n    self: The instance of the SessionInterface.\n    app: The application instance whose configuration is consulted.\n\nReturns:\n    str: The cookie path that should be used, derived from the configuration values.\n\"\"\"",
                    "source_code": "return app.config[\"SESSION_COOKIE_PATH\"] or app.config[\"APPLICATION_ROOT\"]"
                },
                {
                    "docstring": "\"\"\"Returns True if the session cookie should be httponly.  This\n        currently just returns the value of the ``SESSION_COOKIE_HTTPONLY``\n        config var.\n        \"\"\"",
                    "first_doc": "\"\"\"\nDetermines if the session cookie should be set as HTTPOnly.\n\nChecks the application's configuration to decide whether the session cookie should only be transmitted over HTTP and not accessible to client-side scripts.\n\nArgs:\n    self: The instance of the class.\n    app: The application instance containing configuration values.\n\nReturns:\n    bool: True if the session cookie should be HTTPOnly, False otherwise.\n\"\"\"",
                    "method_name": "get_cookie_httponly",
                    "second_doc": "\"\"\"\nDetermines whether the session cookie should be restricted from access by client-side scripts by retrieving the relevant configuration setting from the application.\n\nThis method helps enforce security best practices for session handling within the application, reducing the risk of session cookie exposure to unauthorized scripts.\n\nArgs:\n    self: The instance of the class.\n    app: The application instance containing configuration values.\n\nReturns:\n    bool: True if the session cookie is configured to be HTTPOnly, preventing access by client-side scripts; False otherwise.\n\"\"\"",
                    "source_code": "return app.config[\"SESSION_COOKIE_HTTPONLY\"]"
                },
                {
                    "docstring": "\"\"\"Returns True if the cookie should be secure.  This currently\n        just returns the value of the ``SESSION_COOKIE_SECURE`` setting.\n        \"\"\"",
                    "first_doc": "\"\"\"\nDetermines whether the session cookie should be marked as secure.\n\nChecks the application configuration to see if cookies should be marked as secure when being set, based on the SESSION_COOKIE_SECURE setting.\n\nArgs:\n    self: The instance of the class calling this method.\n    app: The application object containing configuration information.\n\nReturns:\n    bool: True if the session cookie should be secure, False otherwise.\n\"\"\"",
                    "method_name": "get_cookie_secure",
                    "second_doc": "\"\"\"\nDetermines if the session cookie requires the 'Secure' flag by reading the relevant application configuration setting. This ensures that cookies are only transmitted over HTTPS connections if the configuration indicates enhanced transport security is desired, aligning cookie handling with deployment requirements.\n\nArgs:\n    self: The instance of SessionInterface invoking this method.\n    app: The Flask application object containing configuration values.\n\nReturns:\n    bool: True if the session cookie should have the 'Secure' flag set (sent only over HTTPS), False otherwise.\n\"\"\"",
                    "source_code": "return app.config[\"SESSION_COOKIE_SECURE\"]"
                },
                {
                    "docstring": "\"\"\"Return ``'Strict'`` or ``'Lax'`` if the cookie should use the\n        ``SameSite`` attribute. This currently just returns the value of\n        the :data:`SESSION_COOKIE_SAMESITE` setting.\n        \"\"\"",
                    "first_doc": "\"\"\"\nReturns the SameSite attribute value for the cookie ('Strict' or 'Lax').\n\nThis method retrieves the configured value for the SameSite attribute of session cookies from the application's configuration.\n\nArgs:\n    self: The instance of the class.\n    app: The application instance from which the SESSION_COOKIE_SAMESITE setting is retrieved.\n\nReturns:\n    str: The value of the SESSION_COOKIE_SAMESITE configuration setting, commonly 'Strict' or 'Lax'.\n\"\"\"",
                    "method_name": "get_cookie_samesite",
                    "second_doc": "\"\"\"\nRetrieves the value of the SameSite attribute set for session cookies from the application's configuration to ensure proper client-side cookie handling and security policies.\n\nArgs:\n    self: The instance of the SessionInterface class.\n    app: The application instance containing configuration parameters.\n\nReturns:\n    str: The configured SameSite value for session cookies, typically 'Strict' or 'Lax', which influences how cookies are sent with cross-site requests.\n\"\"\"",
                    "source_code": "return app.config[\"SESSION_COOKIE_SAMESITE\"]"
                },
                {
                    "docstring": "\"\"\"A helper method that returns an expiration date for the session\n        or ``None`` if the session is linked to the browser session.  The\n        default implementation returns now + the permanent session\n        lifetime configured on the application.\n        \"\"\"",
                    "first_doc": "\"\"\"\nCalculates and returns the expiration date for the given session.\n\nThis method determines when a session should expire based on its permanence configuration. If the session is marked as permanent, the expiration is calculated as the current UTC time plus the application's configured permanent session lifetime. If the session is not permanent (browser session), None is returned.\n\nArgs:\n    app: The application instance containing session configuration, including `permanent_session_lifetime`.\n    session: The session object whose expiration time should be determined. Should have a `permanent` property indicating permanence.\n\nReturns:\n    datetime or None: The expiration datetime if the session is permanent, or None if it is a browser session.\n\"\"\"",
                    "method_name": "get_expiration_time",
                    "second_doc": "\"\"\"\nDetermines when a user session should end based on its configuration.\n\nThis method calculates the expiration time for a user session if it is set to be persistent across browser restarts. By setting an explicit expiration for permanent sessions, the system can manage user authorization duration, automatically log out inactive users, and reduce potential security risks associated with indefinitely valid sessions. For non-permanent sessions tied to the browser lifecycle, no expiration time is set.\n\nArgs:\n    app: The application instance that holds session configuration, specifically the `permanent_session_lifetime` attribute used to define how long a permanent session should last.\n    session: The session object to evaluate, expected to have a `permanent` attribute indicating whether the session should persist beyond the current browser session.\n\nReturns:\n    datetime or None: Returns the calculated expiration datetime for permanent sessions, or None if the session is not permanent and should expire with the browser session.\n\"\"\"",
                    "source_code": "if session.permanent:\n            return datetime.utcnow() + app.permanent_session_lifetime"
                },
                {
                    "docstring": "\"\"\"Used by session backends to determine if a ``Set-Cookie`` header\n        should be set for this session cookie for this response. If the session\n        has been modified, the cookie is set. If the session is permanent and\n        the ``SESSION_REFRESH_EACH_REQUEST`` config is true, the cookie is\n        always set.\n\n        This check is usually skipped if the session was deleted.\n\n        .. versionadded:: 0.11\n        \"\"\"",
                    "first_doc": "\"\"\"\nDetermines whether a Set-Cookie header should be set for the session cookie in the response.\n\nChecks if the session has been modified or if the session is permanent with the application's configuration requiring cookie refresh on each request. This method is typically skipped if the session has been deleted.\n\nArgs:\n    app: The Flask application instance, used to access configuration values.\n    session: The session object associated with the current request, containing its state and properties.\n\nReturns:\n    bool: True if a Set-Cookie header should be set for this session, False otherwise.\n\"\"\"",
                    "method_name": "should_set_cookie",
                    "second_doc": "\"\"\"\nDetermines if a Set-Cookie header needs to be sent for the session cookie in the response.\n\nThis decision ensures the client accurately maintains session state across requests. The header is set if the session data has changed or, when configured, if the session should be refreshed on each request to preserve session persistence.\n\nArgs:\n    app: The Flask application instance, allowing access to configuration settings relevant to session handling.\n    session: The session object associated with the current request, indicating its current state (modified, permanent, etc.).\n\nReturns:\n    bool: True if the session cookie should be updated in the response, False if no update is needed.\n\"\"\"",
                    "source_code": "return session.modified or (\n            session.permanent and app.config[\"SESSION_REFRESH_EACH_REQUEST\"]\n        )"
                },
                {
                    "docstring": "\"\"\"This method has to be implemented and must either return ``None``\n        in case the loading failed because of a configuration error or an\n        instance of a session object which implements a dictionary like\n        interface + the methods and attributes on :class:`SessionMixin`.\n        \"\"\"",
                    "first_doc": "\"\"\"\nAttempts to load a session for the given app and request.\n\nThis method should be implemented to return either None (in case loading fails due to a configuration error) or an instance of a session object that behaves like a dictionary and provides methods and attributes from SessionMixin.\n\nArgs:\n    app: The application instance associated with the session.\n    request: The request object for which the session is to be loaded.\n\nReturns:\n    An object implementing a dictionary-like interface and SessionMixin features representing the session, or None if loading fails due to a configuration error.\n\"\"\"",
                    "method_name": "open_session",
                    "second_doc": "\"\"\"\nDefines the mechanism for retrieving or initializing a session tied to a specific HTTP request and application instance.\n\nSession management allows persistence of user data across multiple requests, enabling features such as user authentication, preferences tracking, or other per-client state. By requiring subclasses to implement this method, the interface ensures the flexibility to customize session loading strategies depending on different storage backends or application needs.\n\nArgs:\n    app: The application instance for which the session is being managed.\n    request: The HTTP request object associated with the client.\n\nReturns:\n    A session object\u2014behaving like a mutable dictionary and supporting SessionMixin functionality\u2014representing the client's session data, or None if the session could not be loaded (e.g., due to misconfiguration).\n\"\"\"",
                    "source_code": "raise NotImplementedError()"
                },
                {
                    "docstring": "\"\"\"This is called for actual sessions returned by :meth:`open_session`\n        at the end of the request.  This is still called during a request\n        context so if you absolutely need access to the request you can do\n        that.\n        \"\"\"",
                    "first_doc": "\"\"\"\nSaves the session data to the response at the end of the request.\n\nArgs:\n    app: The application context in which the session operates.\n    session: The session object to be saved.\n    response: The response object to which the session data should be attached.\n\nReturns:\n    None: This method does not return anything.\n\"\"\"",
                    "method_name": "save_session",
                    "second_doc": "\"\"\"\nPersists session information into the outgoing response to maintain user data and application state across requests.\n\nArgs:\n    app: The application context managing the session lifecycle.\n    session: The session object containing data to be stored.\n    response: The response object that will carry the session data to the client.\n\nReturns:\n    None: This method serves as an interface and does not return a value.\n\"\"\"",
                    "source_code": "raise NotImplementedError()"
                }
            ],
            "name": "SessionInterface",
            "type": "class"
        },
        {
            "methods": [
                {
                    "docstring": null,
                    "method_name": "get_signing_serializer",
                    "second_doc": "\"\"\"\nCreates and returns a serializer for securely signing and verifying data stored in client-side sessions. This enables the application to ensure the authenticity and integrity of session data sent by the client.\n\nArgs:\n    app: The Flask application instance, used to access the secret key and configuration for signing.\n\nReturns:\n    An instance of URLSafeTimedSerializer configured with the application's secret key and serializer options, or None if no secret key is set.\n\"\"\"",
                    "source_code": "if not app.secret_key:\n            return None\n        signer_kwargs = dict(\n            key_derivation=self.key_derivation, digest_method=self.digest_method\n        )\n        return URLSafeTimedSerializer(\n            app.secret_key,\n            salt=self.salt,\n            serializer=self.serializer,\n            signer_kwargs=signer_kwargs,\n        )"
                },
                {
                    "docstring": null,
                    "method_name": "open_session",
                    "second_doc": "\"\"\"\nLoads and verifies the session data from the client-side cookie, ensuring data integrity and session continuity across requests. This method retrieves the session cookie, validates its signature and expiration, and reconstructs the session object accordingly. If validation fails or no cookie is present, a new empty session is provided to maintain secure and consistent session behavior.\n\nArgs:\n    app: The current Flask application instance.\n    request: The current request object containing client cookies.\n\nReturns:\n    An instance of the session class populated with session data if available and valid, or an empty session object otherwise.\n\"\"\"",
                    "source_code": "s = self.get_signing_serializer(app)\n        if s is None:\n            return None\n        val = request.cookies.get(self.get_cookie_name(app))\n        if not val:\n            return self.session_class()\n        max_age = total_seconds(app.permanent_session_lifetime)\n        try:\n            data = s.loads(val, max_age=max_age)\n            return self.session_class(data)\n        except BadSignature:\n            return self.session_class()"
                },
                {
                    "docstring": null,
                    "method_name": "save_session",
                    "second_doc": "\"\"\"\nSaves the current session data to the client's browser as a secure cookie, or removes the session cookie if the session is empty or has been cleared. Ensures the session's state is accurately reflected in the response based on whether it has been modified or accessed.\n\nThis method manages cookies and session data to maintain user state across HTTP requests, providing continuity and security for user interactions.\n\nArgs:\n    app: The Flask application object, used to retrieve cookie-related configuration.\n    session: The session object containing the user's session data.\n    response: The response object to which session-related cookie headers will be added or from which cookies may be removed.\n\nReturns:\n    None. The response object is modified in place to set or remove the session cookie as appropriate.\n\"\"\"",
                    "source_code": "name = self.get_cookie_name(app)\n        domain = self.get_cookie_domain(app)\n        path = self.get_cookie_path(app)\n\n        # If the session is modified to be empty, remove the cookie.\n        # If the session is empty, return without setting the cookie.\n        if not session:\n            if session.modified:\n                response.delete_cookie(name, domain=domain, path=path)\n\n            return\n\n        # Add a \"Vary: Cookie\" header if the session was accessed at all.\n        if session.accessed:\n            response.vary.add(\"Cookie\")\n\n        if not self.should_set_cookie(app, session):\n            return\n\n        httponly = self.get_cookie_httponly(app)\n        secure = self.get_cookie_secure(app)\n        samesite = self.get_cookie_samesite(app)\n        expires = self.get_expiration_time(app, session)\n        val = self.get_signing_serializer(app).dumps(dict(session))\n        response.set_cookie(\n            name,\n            val,\n            expires=expires,\n            httponly=httponly,\n            domain=domain,\n            path=path,\n            secure=secure,\n            samesite=samesite,\n        )"
                }
            ],
            "name": "SecureCookieSessionInterface",
            "type": "class"
        }
    ],
    "flask/src/flask/signals.py": [],
    "flask/src/flask/templating.py": [
        {
            "details": {
                "docstring": "\"\"\"Default template context processor.  Injects `request`,\n    `session` and `g`.\n    \"\"\"",
                "first_doc": "\"\"\"\nProvides a default context for template rendering by supplying commonly used objects.\n\nThis method retrieves the current application and request contexts, if available, and constructs a dictionary containing relevant context objects for use in templates. It adds the global application object (`g`), the current request object, and the session object, depending on which contexts are present.\n\nReturns:\n    dict: A dictionary containing available context objects (`g`, `request`, `session`) for use in templates.\n\"\"\"",
                "method_name": "_default_template_ctx_processor",
                "second_doc": "\"\"\"\nConstructs a dictionary of context variables to make key objects easily accessible within rendered templates.\n\nBy gathering relevant objects from the current application and request contexts, this method ensures that templates have direct access to important state and session data needed for dynamic content rendering.\n\nArgs:\n    None\n\nReturns:\n    dict: A dictionary containing available context objects such as `g` (global variables), `request` (the current request), and `session` (user session data), depending on which contexts are active.\n\"\"\"",
                "source_code": "reqctx = _request_ctx_stack.top\n    appctx = _app_ctx_stack.top\n    rv = {}\n    if appctx is not None:\n        rv[\"g\"] = appctx.g\n    if reqctx is not None:\n        rv[\"request\"] = reqctx.request\n        rv[\"session\"] = reqctx.session\n    return rv"
            },
            "type": "function"
        },
        {
            "methods": [
                {
                    "docstring": null,
                    "method_name": "__init__",
                    "second_doc": "\"\"\"\nInitializes the template environment using application-specific options, ensuring a loader is configured for template rendering.\n\nArgs:\n    app: The application instance providing configuration and loader creation methods.\n    options (dict): Optional environment settings that may include a template loader and other environment parameters.\n\nReturns:\n    None. This constructor sets up the environment and binds it to the application instance.\n\nWhy:\n    Ensuring a template loader is available enables dynamic rendering of templates, a core aspect of serving dynamic web content.\n\"\"\"",
                    "source_code": "if \"loader\" not in options:\n            options[\"loader\"] = app.create_global_jinja_loader()\n        BaseEnvironment.__init__(self, **options)\n        self.app = app"
                }
            ],
            "name": "Environment",
            "type": "class"
        },
        {
            "methods": [
                {
                    "docstring": null,
                    "method_name": "__init__",
                    "second_doc": "\"\"\"\nInitializes the dispatching Jinja template loader with the given Flask application instance.\n\nThis setup associates the loader with the application, allowing templates to be found and rendered according to the app's configuration and modular structure.\n\nArgs:\n    app: The Flask application instance to associate with this template loader.\n\nReturns:\n    None\n\"\"\"",
                    "source_code": "self.app = app"
                },
                {
                    "docstring": null,
                    "method_name": "get_source",
                    "second_doc": "\"\"\"\nRetrieve the source code, filename, and reload helper for a Jinja template, using either a fast path or an explanatory mode depending on configuration.\n\nThis method allows for conditional diagnostics or performance optimization when loading templates.\n\nArgs:\n    environment: The Jinja environment used for template rendering.\n    template: The name of the template to load.\n\nReturns:\n    A tuple (source, filename, uptodate) containing the template's source code as a string, its filename, and a callable that returns True if the template is unchanged.\n\"\"\"",
                    "source_code": "if self.app.config[\"EXPLAIN_TEMPLATE_LOADING\"]:\n            return self._get_source_explained(environment, template)\n        return self._get_source_fast(environment, template)"
                },
                {
                    "docstring": null,
                    "method_name": "_get_source_explained",
                    "second_doc": "\"\"\"\nAttempts to locate and retrieve the source code, filename, and up-to-date function for a given template by querying all configured template loaders, while providing diagnostic information about each loading attempt.\n\nThis method systematically tries each loader to find the requested template, enabling better debugging and transparency in template resolution processes.\n\nArgs:\n    environment: The Jinja environment used for template rendering.\n    template (str): The name of the template to be loaded.\n\nReturns:\n    tuple: A tuple containing the template source, filename, and a function to check if the template is up-to-date.\n\nRaises:\n    TemplateNotFound: If none of the loaders are able to provide the requested template.\n\"\"\"",
                    "source_code": "attempts = []\n        trv = None\n\n        for srcobj, loader in self._iter_loaders(template):\n            try:\n                rv = loader.get_source(environment, template)\n                if trv is None:\n                    trv = rv\n            except TemplateNotFound:\n                rv = None\n            attempts.append((loader, srcobj, rv))\n\n        from .debughelpers import explain_template_loading_attempts\n\n        explain_template_loading_attempts(self.app, template, attempts)\n\n        if trv is not None:\n            return trv\n        raise TemplateNotFound(template)"
                },
                {
                    "docstring": null,
                    "method_name": "_get_source_fast",
                    "second_doc": "\"\"\"\nAttempts to find and return the template source code from the available loaders for a given template name.\n\nThis method iterates through all registered template loaders, querying each one for the specified template. If a loader successfully provides the template source, it is returned immediately. If no loader can handle the template, an exception is raised. This mechanism ensures the correct template is located efficiently when rendering dynamic content.\n\nArgs:\n    environment: The current Jinja environment in use.\n    template: The name of the template to retrieve.\n\nReturns:\n    A tuple containing the template source, its filename, and a callable indicating if the template has changed.\n\nRaises:\n    TemplateNotFound: If none of the loaders can provide the requested template.\n\"\"\"",
                    "source_code": "for _srcobj, loader in self._iter_loaders(template):\n            try:\n                return loader.get_source(environment, template)\n            except TemplateNotFound:\n                continue\n        raise TemplateNotFound(template)"
                },
                {
                    "docstring": null,
                    "method_name": "_iter_loaders",
                    "second_doc": "\"\"\"\nYields all Jinja template loaders associated with the main application and its registered blueprints to ensure templates can be located and rendered regardless of their source within the project structure.\n\nYields:\n    Tuple[object, BaseLoader]: Pairs containing either the Flask application or a blueprint object along with its associated Jinja template loader, allowing template discovery across modular application components.\n\"\"\"",
                    "source_code": "loader = self.app.jinja_loader\n        if loader is not None:\n            yield self.app, loader\n\n        for blueprint in self.app.iter_blueprints():\n            loader = blueprint.jinja_loader\n            if loader is not None:\n                yield blueprint, loader"
                },
                {
                    "docstring": null,
                    "method_name": "list_templates",
                    "second_doc": "\"\"\"\nCollects and returns a list of all unique Jinja template names available in the application and its blueprints.\n\nThis method ensures that templates from both the main application and its modular components are discoverable, allowing the system to locate and render any template defined across the project.\n\nReturns:\n    list: A list of unique template names accessible by the application's Jinja loader and blueprint loaders.\n\"\"\"",
                    "source_code": "result = set()\n        loader = self.app.jinja_loader\n        if loader is not None:\n            result.update(loader.list_templates())\n\n        for blueprint in self.app.iter_blueprints():\n            loader = blueprint.jinja_loader\n            if loader is not None:\n                for template in loader.list_templates():\n                    result.add(template)\n\n        return list(result)"
                }
            ],
            "name": "DispatchingJinjaLoader",
            "type": "class"
        },
        {
            "details": {
                "docstring": "\"\"\"Renders the template and fires the signal\"\"\"",
                "first_doc": "\"\"\"\nRenders a given template with the provided context and sends render-related signals.\n\nArgs:\n    template: The template object to be rendered.\n    context: The context dictionary used for rendering the template.\n    app: The application instance used for sending signals.\n\nReturns:\n    The rendered template as a string.\n\"\"\"",
                "method_name": "_render",
                "second_doc": "\"\"\"\nTriggers signals before and after rendering a template with the given context, then returns the rendered result. This allows hooking custom logic into the template rendering process, facilitating actions such as logging, modification, or monitoring of rendering events.\n\nArgs:\n    template: The template object to render.\n    context: A dictionary providing variables for the template.\n    app: The application instance for dispatching signals.\n\nReturns:\n    str: The rendered template output.\n\"\"\"",
                "source_code": "before_render_template.send(app, template=template, context=context)\n    rv = template.render(context)\n    template_rendered.send(app, template=template, context=context)\n    return rv"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": "\"\"\"Renders a template from the template folder with the given\n    context.\n\n    :param template_name_or_list: the name of the template to be\n                                  rendered, or an iterable with template names\n                                  the first one existing will be rendered\n    :param context: the variables that should be available in the\n                    context of the template.\n    \"\"\"",
                "first_doc": "\"\"\"\nRenders a template using the current Flask application context and provided context variables.\n\nArgs:\n    template_name_or_list: The name of the template to be rendered, or a list of template names to try.\n\nReturns:\n    str: The rendered template as a string.\n\"\"\"",
                "method_name": "render_template",
                "second_doc": "\"\"\"\nGenerates a dynamic HTML response by combining the specified template with the current application's variables and the provided context. This allows web pages to adapt their content based on the application's state and user input.\n\nArgs:\n    template_name_or_list (str or list): The name of the template, or a list of template names, to be rendered.\n\nReturns:\n    str: The fully rendered template as a string, ready to be sent in an HTTP response.\n\"\"\"",
                "source_code": "ctx = _app_ctx_stack.top\n    ctx.app.update_template_context(context)\n    return _render(\n        ctx.app.jinja_env.get_or_select_template(template_name_or_list),\n        context,\n        ctx.app,\n    )"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": "\"\"\"Renders a template from the given template source string\n    with the given context. Template variables will be autoescaped.\n\n    :param source: the source code of the template to be\n                   rendered\n    :param context: the variables that should be available in the\n                    context of the template.\n    \"\"\"",
                "first_doc": "\"\"\"\nRenders a template from the given source string using the current application context.\n\nArgs:\n    source: The template source code as a string to be rendered.\n\nReturns:\n    The rendered template as a string.\n\"\"\"",
                "method_name": "render_template_string",
                "second_doc": "\"\"\"\nRenders a template from the provided source string by evaluating it with the current application context and variables.\n\nThis method allows dynamically generating content based on application-specific data, ensuring templates have access to the latest state and configurations.\n\nArgs:\n    source (str): The template source code as a string to be rendered.\n    context (dict, optional): Dictionary of variables to make available in the template. Defaults to None.\n\nReturns:\n    str: The rendered template as a string.\n\"\"\"",
                "source_code": "ctx = _app_ctx_stack.top\n    ctx.app.update_template_context(context)\n    return _render(ctx.app.jinja_env.from_string(source), context, ctx.app)"
            },
            "type": "function"
        }
    ],
    "flask/src/flask/testing.py": [
        {
            "methods": [
                {
                    "docstring": null,
                    "method_name": "__init__",
                    "second_doc": "\"\"\"\nInitializes a new environment builder for testing or simulating HTTP requests.\n\nThe method constructs the base URL and request path by consulting application configuration, handling cases where a subdomain or custom scheme is supplied, and ensuring appropriate defaults are used. This allows for accurate simulation of various request scenarios within the application context.\n\nArgs:\n    app: The Flask application instance whose configuration is used to determine host, scheme, and application root.\n    path: The path or URL to simulate in the request.\n    base_url: Optional explicit base URL to use for the request.\n    subdomain: Optional subdomain to prepend to the host.\n    url_scheme: Optional scheme (e.g., 'http', 'https') for the request URL.\n    *args: Additional positional arguments passed to the parent class.\n    **kwargs: Additional keyword arguments passed to the parent class.\n\nReturns:\n    None. The builder is initialized for use in constructing a request environment.\n\"\"\"",
                    "source_code": "assert not (base_url or subdomain or url_scheme) or (\n            base_url is not None\n        ) != bool(\n            subdomain or url_scheme\n        ), 'Cannot pass \"subdomain\" or \"url_scheme\" with \"base_url\".'\n\n        if base_url is None:\n            http_host = app.config.get(\"SERVER_NAME\") or \"localhost\"\n            app_root = app.config[\"APPLICATION_ROOT\"]\n\n            if subdomain:\n                http_host = f\"{subdomain}.{http_host}\"\n\n            if url_scheme is None:\n                url_scheme = app.config[\"PREFERRED_URL_SCHEME\"]\n\n            url = url_parse(path)\n            base_url = (\n                f\"{url.scheme or url_scheme}://{url.netloc or http_host}\"\n                f\"/{app_root.lstrip('/')}\"\n            )\n            path = url.path\n\n            if url.query:\n                sep = b\"?\" if isinstance(url.query, bytes) else \"?\"\n                path += sep + url.query\n\n        self.app = app\n        super().__init__(path, base_url, *args, **kwargs)"
                },
                {
                    "docstring": "\"\"\"Serialize ``obj`` to a JSON-formatted string.\n\n        The serialization will be configured according to the config associated\n        with this EnvironBuilder's ``app``.\n        \"\"\"",
                    "first_doc": "\"\"\"\nSerializes the given object to a JSON-formatted string using the app's configuration.\n\nArgs:\n    self: The EnvironBuilder instance.\n    obj: The object to serialize to a JSON-formatted string.\n\nReturns:\n    str: A JSON-formatted string representation of the provided object, serialized according to the configuration associated with this EnvironBuilder's app.\n\"\"\"",
                    "method_name": "json_dumps",
                    "second_doc": "\"\"\"\nConverts the provided object into a JSON-formatted string using the serialization rules associated with this builder's application context. This ensures that objects are encoded in a manner consistent with the application's expected JSON handling, which is particularly important for generating accurate request or response data during web interactions.\n\nArgs:\n    obj: The Python object to be serialized into a JSON-formatted string.\n\nReturns:\n    str: A JSON-formatted string representation of the provided object, serialized according to the JSON configuration linked to this builder's application.\n\"\"\"",
                    "source_code": "kwargs.setdefault(\"app\", self.app)\n        return json_dumps(obj, **kwargs)"
                }
            ],
            "name": "EnvironBuilder",
            "type": "class"
        },
        {
            "methods": [
                {
                    "docstring": null,
                    "method_name": "__init__",
                    "second_doc": "\"\"\"\nInitializes the FlaskClient with default environment settings used for simulating HTTP requests during test scenarios. By setting default values for the remote address and user agent, this setup ensures controlled and consistent test environments for client-server interactions, simplifying the process of validating application behavior during development.\n\nArgs:\n    *args: Positional arguments forwarded to the parent client initializer.\n    **kwargs: Keyword arguments forwarded to the parent client initializer.\n\nReturns:\n    None\n\"\"\"",
                    "source_code": "super().__init__(*args, **kwargs)\n        self.environ_base = {\n            \"REMOTE_ADDR\": \"127.0.0.1\",\n            \"HTTP_USER_AGENT\": f\"werkzeug/{werkzeug.__version__}\",\n        }"
                },
                {
                    "docstring": "\"\"\"When used in combination with a ``with`` statement this opens a\n        session transaction.  This can be used to modify the session that\n        the test client uses.  Once the ``with`` block is left the session is\n        stored back.\n\n        ::\n\n            with client.session_transaction() as session:\n                session['value'] = 42\n\n        Internally this is implemented by going through a temporary test\n        request context and since session handling could depend on\n        request variables this function accepts the same arguments as\n        :meth:`~flask.Flask.test_request_context` which are directly\n        passed through.\n        \"\"\"",
                    "first_doc": "\"\"\"\nProvides a context manager for interacting with the client session during testing.\n\nThis method is intended to be used with a `with` statement to temporarily open and modify the session used by the test client. Any changes made to the session within the block are persisted when the block is exited. The session is accessed through a temporary test request context to ensure consistency with Flask's session management.\n\nArgs:\n    self: The test client instance.\n\nReturns:\n    generator: Yields a session object that can be modified within the context manager. Persists changes to the session after the context manager exits.\n\"\"\"",
                    "method_name": "session_transaction",
                    "second_doc": "\"\"\"\nEnables temporary access and modification of the client session within tests using a context manager.\n\nThis method allows you to manipulate the session data of the test client in an isolated context, ensuring any updates made during the block are correctly synchronized with the client\u2019s session. By doing so, it simulates real-world session behavior, letting tests accurately reflect how session data would be handled in actual requests. It also manages the complexities of Flask's session backend and cookie handling, so changes persist as they would in normal usage.\n\nArgs:\n    self: The test client instance used to interact with the application during tests.\n\nReturns:\n    generator: Yields a session object that can be modified inside the 'with' block. Session changes are committed when exiting the context, keeping the test client\u2019s session in sync with application logic and simulating real HTTP session persistence.\n\"\"\"",
                    "source_code": "if self.cookie_jar is None:\n            raise RuntimeError(\n                \"Session transactions only make sense with cookies enabled.\"\n            )\n        app = self.application\n        environ_overrides = kwargs.setdefault(\"environ_overrides\", {})\n        self.cookie_jar.inject_wsgi(environ_overrides)\n        outer_reqctx = _request_ctx_stack.top\n        with app.test_request_context(*args, **kwargs) as c:\n            session_interface = app.session_interface\n            sess = session_interface.open_session(app, c.request)\n            if sess is None:\n                raise RuntimeError(\n                    \"Session backend did not open a session. Check the configuration\"\n                )\n\n            # Since we have to open a new request context for the session\n            # handling we want to make sure that we hide out own context\n            # from the caller.  By pushing the original request context\n            # (or None) on top of this and popping it we get exactly that\n            # behavior.  It's important to not use the push and pop\n            # methods of the actual request context object since that would\n            # mean that cleanup handlers are called\n            _request_ctx_stack.push(outer_reqctx)\n            try:\n                yield sess\n            finally:\n                _request_ctx_stack.pop()\n\n            resp = app.response_class()\n            if not session_interface.is_null_session(sess):\n                session_interface.save_session(app, sess, resp)\n            headers = resp.get_wsgi_headers(c.request.environ)\n            self.cookie_jar.extract_wsgi(c.request.environ, headers)"
                },
                {
                    "docstring": null,
                    "method_name": "open",
                    "second_doc": "\"\"\"\nSimulates making an HTTP request to the application for testing purposes by building an appropriate WSGI environment and invoking the test client. This method is designed to accurately recreate request scenarios, allowing developers to inspect and validate the application's behavior in a controlled environment.\n\nArgs:\n    *args: Positional arguments that can be a werkzeug.test.EnvironBuilder or a dict representing the environment.\n    as_tuple (bool, optional): If True, the response is returned as a tuple of (environ, response, request context). Defaults to False.\n    buffered (bool, optional): If True, the response is buffered so user code can access response data multiple times. Defaults to False.\n    follow_redirects (bool, optional): If True, the client will follow HTTP redirects until a final response is received. Defaults to False.\n    **kwargs: Additional arguments for request configuration, such as environ_overrides or environ_base.\n\nReturns:\n    Response object or tuple: The HTTP response from the application, or a tuple containing environment, response, and request context if as_tuple is True.\n\nWhy:\n    This method enables thorough testing of web application endpoints by simulating HTTP requests and responses, helping developers ensure correctness and reliability of their application's handling of various request scenarios.\n\"\"\"",
                    "source_code": "as_tuple = kwargs.pop(\"as_tuple\", False)\n        buffered = kwargs.pop(\"buffered\", False)\n        follow_redirects = kwargs.pop(\"follow_redirects\", False)\n\n        if (\n            not kwargs\n            and len(args) == 1\n            and isinstance(args[0], (werkzeug.test.EnvironBuilder, dict))\n        ):\n            environ = self.environ_base.copy()\n\n            if isinstance(args[0], werkzeug.test.EnvironBuilder):\n                environ.update(args[0].get_environ())\n            else:\n                environ.update(args[0])\n\n            environ[\"flask._preserve_context\"] = self.preserve_context\n        else:\n            kwargs.setdefault(\"environ_overrides\", {})[\n                \"flask._preserve_context\"\n            ] = self.preserve_context\n            kwargs.setdefault(\"environ_base\", self.environ_base)\n            builder = EnvironBuilder(self.application, *args, **kwargs)\n\n            try:\n                environ = builder.get_environ()\n            finally:\n                builder.close()\n\n        return Client.open(\n            self,\n            environ,\n            as_tuple=as_tuple,\n            buffered=buffered,\n            follow_redirects=follow_redirects,\n        )"
                },
                {
                    "docstring": null,
                    "method_name": "__enter__",
                    "second_doc": "\"\"\"\nEnters the client context for testing Flask applications, ensuring that the application context is preserved for the duration of test operations and preventing nested client invocations.\n\nThis method enables accurate simulation of request handling within a controlled testing environment by maintaining necessary state and isolation.\n\nRaises:\n    RuntimeError: If the client context is already active, preventing nested uses.\n\nReturns:\n    FlaskClient: The current client instance with context-preservation enabled.\n\"\"\"",
                    "source_code": "if self.preserve_context:\n            raise RuntimeError(\"Cannot nest client invocations\")\n        self.preserve_context = True\n        return self"
                },
                {
                    "docstring": null,
                    "method_name": "__exit__",
                    "second_doc": "\"\"\"\nCleans up any preserved request contexts when exiting the client.\n\nThis method ensures that all preserved request contexts are properly removed from the context stack when the client is no longer in use. By popping out lingering contexts, it helps prevent issues related to resource management and subsequent test isolation.\n\nArgs:\n    exc_type (type): The exception type, if an exception was raised.\n    exc_value (Exception): The exception instance, if any.\n    traceback (TracebackType): The traceback object, if an exception was raised.\n\nReturns:\n    None\n\"\"\"",
                    "source_code": "self.preserve_context = False\n\n        # Normally the request context is preserved until the next\n        # request in the same thread comes. When the client exits we\n        # want to clean up earlier. Pop request contexts until the stack\n        # is empty or a non-preserved one is found.\n        while True:\n            top = _request_ctx_stack.top\n\n            if top is not None and top.preserved:\n                top.pop()\n            else:\n                break"
                }
            ],
            "name": "FlaskClient",
            "type": "class"
        },
        {
            "methods": [
                {
                    "docstring": null,
                    "method_name": "__init__",
                    "second_doc": "\"\"\"\nInitializes the FlaskCliRunner instance by associating it with a specific Flask application and configuring it for command-line operations.\n\nArgs:\n    app: The Flask application instance to be used by this CLI runner.\n    **kwargs: Additional keyword arguments passed to the base runner class.\n\nReturns:\n    None\n\nThis initialization allows the CLI runner to interact directly with the application instance, ensuring that CLI commands and operations are executed in the correct application context.\n\"\"\"",
                    "source_code": "self.app = app\n        super().__init__(**kwargs)"
                },
                {
                    "docstring": "\"\"\"Invokes a CLI command in an isolated environment. See\n        :meth:`CliRunner.invoke <click.testing.CliRunner.invoke>` for\n        full method documentation. See :ref:`testing-cli` for examples.\n\n        If the ``obj`` argument is not given, passes an instance of\n        :class:`~flask.cli.ScriptInfo` that knows how to load the Flask\n        app being tested.\n\n        :param cli: Command object to invoke. Default is the app's\n            :attr:`~flask.app.Flask.cli` group.\n        :param args: List of strings to invoke the command with.\n\n        :return: a :class:`~click.testing.Result` object.\n        \"\"\"",
                    "first_doc": "\"\"\"\nInvokes a CLI command in an isolated environment for testing purposes.\n\nThis method serves as a wrapper around the underlying Click testing runner, setting up a context suitable for testing Flask CLI commands. If no CLI command object or context is provided, it uses defaults associated with the application under test.\n\nParameters:\n  self: The instance of the class on which this method is called.\n\nReturns:\n  click.testing.Result: The result object containing the outcome of the invoked command, including exit code, output, and exception information.\n\"\"\"",
                    "method_name": "invoke",
                    "second_doc": "\"\"\"\nExecutes a CLI command within an isolated environment to simulate real command-line usage in a controlled setting.\n\nThis method helps ensure reliable and repeatable testing of command-line interface commands by constructing the necessary context and environment. It streamlines command testing by automatically handling defaults for the CLI object and execution context when they are not explicitly provided.\n\nArgs:\n  cli (optional): The CLI command object to be invoked. Defaults to the application's CLI if not specified.\n  args (optional): List of arguments to pass to the CLI command.\n  **kwargs: Additional keyword arguments to customize command invocation and context. If \"obj\" is not provided, a suitable ScriptInfo is created for application context.\n\nReturns:\n  click.testing.Result: An object containing the result of running the CLI command, with details such as exit code, command output, and any exception information.\n\"\"\"",
                    "source_code": "if cli is None:\n            cli = self.app.cli\n\n        if \"obj\" not in kwargs:\n            kwargs[\"obj\"] = ScriptInfo(create_app=lambda: self.app)\n\n        return super().invoke(cli, args, **kwargs)"
                }
            ],
            "name": "FlaskCliRunner",
            "type": "class"
        }
    ],
    "flask/src/flask/views.py": [
        {
            "methods": [
                {
                    "docstring": "\"\"\"Subclasses have to override this method to implement the\n        actual view function code.  This method is called with all\n        the arguments from the URL rule.\n        \"\"\"",
                    "first_doc": "\"\"\"\nInvokes the actual view logic for the request. Subclasses must override this method to implement the view function code, which will be called with arguments derived from the URL rule.\n\nArgs:\n    self: The instance of the view class.\n\nReturns:\n    The result of the view function, which will typically be a response object or data representing the HTTP response.\n\"\"\"",
                    "method_name": "dispatch_request",
                    "second_doc": "\"\"\"\nHandles incoming HTTP requests by delegating them to the appropriate view logic defined in subclasses. This method must be overridden by subclasses to specify how requests matching the route should be processed, ensuring custom behavior for each endpoint.\n\nRaises:\n    NotImplementedError: If the method is not overridden in a subclass.\n\nArgs:\n    self: The instance of the view class.\n\nReturns:\n    The response generated by the view function, typically as an HTTP response object or structured data for the client.\n\nWhy:\n    This method enforces that each view explicitly defines how to process requests, allowing the framework to route incoming requests to user-defined logic for dynamic and flexible web application development.\n\"\"\"",
                    "source_code": "raise NotImplementedError()"
                },
                {
                    "docstring": "\"\"\"Converts the class into an actual view function that can be used\n        with the routing system.  Internally this generates a function on the\n        fly which will instantiate the :class:`View` on each request and call\n        the :meth:`dispatch_request` method on it.\n\n        The arguments passed to :meth:`as_view` are forwarded to the\n        constructor of the class.\n        \"\"\"",
                    "first_doc": "\"\"\"\nConverts the class into a view function compatible with the routing system.\n\nCreates and returns a function that, when called, instantiates the class and dispatches the request using the class's dispatch_request method. Arguments passed to as_view are used to identify the view and customize behavior with decorators.\n\nArgs:\n    cls: The class from which the view function is generated.\n    name: The name to assign to the generated view function.\n\nReturns:\n    A function that can be registered as a route handler, instantiating the view class and calling its dispatch_request method for each request.\n\"\"\"",
                    "method_name": "as_view",
                    "second_doc": "\"\"\"\nTransforms the class into a callable view function suitable for route handling.\n\nBy wrapping the class logic into a function, this method enables per-request instantiation of the view and applies any class-level decorators, ensuring each request is processed independently and can leverage additional behavior as needed. This design supports modular, reusable route handlers that can be extended or customized for various application needs, and attaches class metadata for easier debugging and testing.\n\nArgs:\n    name (str): The identifier to assign to the generated view function, used by the routing system.\n\nReturns:\n    function: A view function that instantiates the class and delegates the request to its dispatch_request method, ready to be registered with the application's routing system.\n\"\"\"",
                    "source_code": "def view(*args, **kwargs):\n            self = view.view_class(*class_args, **class_kwargs)\n            return self.dispatch_request(*args, **kwargs)\n\n        if cls.decorators:\n            view.__name__ = name\n            view.__module__ = cls.__module__\n            for decorator in cls.decorators:\n                view = decorator(view)\n\n        # We attach the view class to the view function for two reasons:\n        # first of all it allows us to easily figure out what class-based\n        # view this thing came from, secondly it's also used for instantiating\n        # the view class so you can actually replace it with something else\n        # for testing purposes and debugging.\n        view.view_class = cls\n        view.__name__ = name\n        view.__doc__ = cls.__doc__\n        view.__module__ = cls.__module__\n        view.methods = cls.methods\n        view.provide_automatic_options = cls.provide_automatic_options\n        return view"
                }
            ],
            "name": "View",
            "type": "class"
        },
        {
            "methods": [
                {
                    "docstring": null,
                    "method_name": "__init__",
                    "second_doc": "\"\"\"\nInitializes the metaclass for class-based views by collecting and registering supported HTTP methods from the provided class and its base classes. This process ensures that the resulting view class correctly advertises which HTTP request methods it can handle, enabling proper routing of web requests.\n\nArgs:\n    name (str): The name of the new class being created.\n    bases (tuple): A tuple containing the base classes.\n    d (dict): A dictionary with attributes for the new class.\n\nReturns:\n    None\n\"\"\"",
                    "source_code": "super().__init__(name, bases, d)\n\n        if \"methods\" not in d:\n            methods = set()\n\n            for base in bases:\n                if getattr(base, \"methods\", None):\n                    methods.update(base.methods)\n\n            for key in http_method_funcs:\n                if hasattr(cls, key):\n                    methods.add(key.upper())\n\n            # If we have no method at all in there we don't want to add a\n            # method list. This is for instance the case for the base class\n            # or another subclass of a base method view that does not introduce\n            # new methods.\n            if methods:\n                cls.methods = methods"
                }
            ],
            "name": "MethodViewType",
            "type": "class"
        },
        {
            "methods": [
                {
                    "docstring": null,
                    "method_name": "dispatch_request",
                    "second_doc": "\"\"\"\nDispatches an HTTP request by determining the appropriate handler method based on the request's method (e.g., GET, POST) and invoking it with the provided arguments. If a specific handler for HEAD requests is not implemented, it falls back to the GET handler to ensure a valid response is generated.\n\nArgs:\n    *args: Positional arguments passed to the handler method.\n    **kwargs: Keyword arguments passed to the handler method.\n\nReturns:\n    The response object returned by the invoked handler method.\n\nRaises:\n    AssertionError: If no appropriate method handler is found for the incoming request.\n\nWhy:\n    This method ensures that each incoming HTTP request is routed to the correct logic based on its method, providing a structured way for developers to implement specific behaviors for different request types and ensuring robust handling even for unimplemented methods like HEAD.\n\"\"\"",
                    "source_code": "meth = getattr(self, request.method.lower(), None)\n\n        # If the request method is HEAD and we don't have a handler for it\n        # retry with GET.\n        if meth is None and request.method == \"HEAD\":\n            meth = getattr(self, \"get\", None)\n\n        assert meth is not None, f\"Unimplemented method {request.method!r}\"\n        return meth(*args, **kwargs)"
                }
            ],
            "name": "MethodView",
            "type": "class"
        }
    ],
    "flask/src/flask/wrappers.py": [
        {
            "methods": [
                {
                    "docstring": null,
                    "method_name": "on_json_loading_failed",
                    "second_doc": "\"\"\"\nHandles failures during JSON decoding and responds with an appropriate error, optionally including debug information during development.\n\nArgs:\n    e (Exception): The exception encountered while trying to decode the JSON payload.\n\nReturns:\n    None: This method raises a BadRequest exception to signal invalid JSON input.\n\nWhy:\n    This ensures that clients are informed of malformed or invalid JSON in their requests, which maintains data integrity and helps with debugging during application development.\n\"\"\"",
                    "source_code": "if current_app and current_app.debug:\n            raise BadRequest(f\"Failed to decode JSON object: {e}\")\n\n        raise BadRequest()"
                }
            ],
            "name": "JSONMixin",
            "type": "class"
        },
        {
            "methods": [
                {
                    "docstring": "\"\"\"Read-only view of the ``MAX_CONTENT_LENGTH`` config key.\"\"\"",
                    "first_doc": "\"\"\"\nReturns the value of the MAX_CONTENT_LENGTH configuration for the current application.\n\nArgs:\n    self: The instance of the class.\n\nReturns:\n    The MAX_CONTENT_LENGTH configuration value from the current application's config. This value represents the maximum allowed size of incoming request bodies.\n\"\"\"",
                    "method_name": "max_content_length",
                    "second_doc": "\"\"\"\nRetrieves the maximum permitted size for incoming request bodies as defined in the application's configuration. This helps the application enforce limits on client uploads and ensures server resources are managed effectively.\n\nArgs:\n    self: The Request instance.\n\nReturns:\n    int or None: The maximum content length in bytes allowed for a request, or None if not set.\n\"\"\"",
                    "source_code": "if current_app:\n            return current_app.config[\"MAX_CONTENT_LENGTH\"]"
                },
                {
                    "docstring": "\"\"\"The endpoint that matched the request.  This in combination with\n        :attr:`view_args` can be used to reconstruct the same or a\n        modified URL.  If an exception happened when matching, this will\n        be ``None``.\n        \"\"\"",
                    "first_doc": "\"\"\"\nReturns the endpoint that matched the request.\n\nThis property retrieves the name of the endpoint associated with the matched URL rule. It can be used together with the view arguments to reconstruct the same URL or to construct a modified one. If no URL rule was matched (e.g., due to an exception during matching), the property will return None.\n\nArgs:\n    self: The instance of the class.\n\nReturns:\n    The endpoint name as a string if a URL rule was matched; otherwise, None.\n\"\"\"",
                    "method_name": "endpoint",
                    "second_doc": "\"\"\"\nRetrieves the name of the endpoint corresponding to the matched URL rule for the current request.\n\nThis property allows the application to identify which handler was selected for a given HTTP request, enabling useful patterns such as URL reconstruction or modification based on routing outcomes. If no URL rule was matched (for example, due to routing errors), it returns None to indicate that no endpoint was identified.\n\nArgs:\n    self: The Request instance representing the current HTTP request.\n\nReturns:\n    str or None: The name of the matched endpoint as a string if a URL rule was found; otherwise, None.\n\"\"\"",
                    "source_code": "if self.url_rule is not None:\n            return self.url_rule.endpoint"
                },
                {
                    "docstring": "\"\"\"The name of the current blueprint\"\"\"",
                    "first_doc": "\"\"\"\nReturns the name of the current blueprint associated with the URL rule.\n\nArgs:\n    self: The instance of the class.\n\nReturns:\n    str: The name of the blueprint if available; otherwise, None.\n\"\"\"",
                    "method_name": "blueprint",
                    "second_doc": "\"\"\"\nDetermines and returns the name of the blueprint associated with the current request by extracting it from the URL rule's endpoint. \n\nThis allows the framework to correctly map the request to the appropriate group of related views and functionality.\n\nArgs:\n    self: The Request instance.\n\nReturns:\n    str or None: The name of the blueprint if the endpoint is namespaced; otherwise, None.\n\"\"\"",
                    "source_code": "if self.url_rule and \".\" in self.url_rule.endpoint:\n            return self.url_rule.endpoint.rsplit(\".\", 1)[0]"
                },
                {
                    "docstring": null,
                    "method_name": "_load_form_data",
                    "second_doc": "\"\"\"\nLoads and processes the form data submitted with the request, preparing it for further handling. In debug mode, replaces the files data structure with a special version that raises informative errors when files are accessed incorrectly, aiding in debugging form submission issues.\n\nArgs:\n    self: The Request instance for which form data is being loaded.\n\nReturns:\n    None\n\"\"\"",
                    "source_code": "RequestBase._load_form_data(self)\n\n        # In debug mode we're replacing the files multidict with an ad-hoc\n        # subclass that raises a different error for key errors.\n        if (\n            current_app\n            and current_app.debug\n            and self.mimetype != \"multipart/form-data\"\n            and not self.files\n        ):\n            from .debughelpers import attach_enctype_error_multidict\n\n            attach_enctype_error_multidict(self)"
                }
            ],
            "name": "Request",
            "type": "class"
        },
        {
            "methods": [
                {
                    "docstring": null,
                    "method_name": "_get_data_for_json",
                    "second_doc": "\"\"\"\nPrepares the response data for JSON serialization by retrieving the current response content.\n\nReturns:\n    bytes: The data content of the response ready to be processed for JSON output.\n\nWhy:\n    This method ensures that the response\u2019s data is accessible in a consistent format for serialization or transmission, which is necessary for constructing API responses or other JSON-based outputs.\n\"\"\"",
                    "source_code": "return self.get_data()"
                },
                {
                    "docstring": "\"\"\"Read-only view of the :data:`MAX_COOKIE_SIZE` config key.\n\n        See :attr:`~werkzeug.wrappers.BaseResponse.max_cookie_size` in\n        Werkzeug's docs.\n        \"\"\"",
                    "first_doc": "\"\"\"\nProvides a read-only view of the maximum allowed cookie size as specified by the application's configuration.\n\nReturns:\n    The maximum allowed cookie size, either from the current application's configuration or the Werkzeug default if not in an application context.\n\"\"\"",
                    "method_name": "max_cookie_size",
                    "second_doc": "\"\"\"\nRetrieves the current limit on cookie size enforced by the configuration to ensure response cookies adhere to application or framework constraints.\n\nArgs:\n    None\n\nReturns:\n    int: The maximum permissible size for a cookie, as determined by either the current application's configuration or the framework's default if not in an application context.\n\"\"\"",
                    "source_code": "if current_app:\n            return current_app.config[\"MAX_COOKIE_SIZE\"]\n\n        # return Werkzeug's default when not in an app context\n        return super().max_cookie_size"
                }
            ],
            "name": "Response",
            "type": "class"
        }
    ],
    "flask/tests/conftest.py": [
        {
            "details": {
                "docstring": "\"\"\"Set up ``os.environ`` at the start of the test session to have\n    standard values. Returns a list of operations that is used by\n    :func:`._reset_os_environ` after each test.\n    \"\"\"",
                "first_doc": "\"\"\"\nEnsures a standard environment variable state for Flask-related environment variables during test sessions.\n\nThis fixture prepares and manages the specified environment variables, either deleting or setting them according to their values, to provide a clean testing environment for each session. Upon test completion, it restores the original environment state.\n\nReturns:\n    tuple: A tuple of tuples, each containing the environment dictionary, environment variable key, and the value that was set or deleted.\n\"\"\"",
                "method_name": "_standard_os_environ",
                "second_doc": "\"\"\"\nResets specified environment variables related to the application runtime context before each testing session to ensure test isolation and eliminate unintended side effects. By clearing or appropriately setting these variables, the fixture guarantees that individual test results are not influenced by any previous or external environment configuration, supporting consistency and reliability in automated testing. After the session, the original environment state is restored.\n\nArgs:\n    None\n\nReturns:\n    tuple: A tuple of tuples, each containing (os.environ dict, environment variable key, variable value or monkeypatch.notset) to facilitate environment restoration after tests.\n\"\"\"",
                "source_code": "mp = monkeypatch.MonkeyPatch()\n    out = (\n        (os.environ, \"FLASK_APP\", monkeypatch.notset),\n        (os.environ, \"FLASK_ENV\", monkeypatch.notset),\n        (os.environ, \"FLASK_DEBUG\", monkeypatch.notset),\n        (os.environ, \"FLASK_RUN_FROM_CLI\", monkeypatch.notset),\n        (os.environ, \"WERKZEUG_RUN_MAIN\", monkeypatch.notset),\n    )\n\n    for _, key, value in out:\n        if value is monkeypatch.notset:\n            mp.delenv(key, False)\n        else:\n            mp.setenv(key, value)\n\n    yield out\n    mp.undo()"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": "\"\"\"Reset ``os.environ`` to the standard environ after each test,\n    in case a test changed something without cleaning up.\n    \"\"\"",
                "first_doc": "\"\"\"\nAutomatically resets the operating system environment variables after each test.\n\nThis fixture ensures that any changes made to the OS environment variables during a test are reverted, preserving the original environment state.\n\nArgs:\n    monkeypatch: The pytest monkeypatch fixture used to modify environment variables.\n    _standard_os_environ: A dictionary containing the original OS environment variables to restore after the test.\n\nReturns:\n    None: This is a pytest fixture and does not return a value.\n\"\"\"",
                "method_name": "_reset_os_environ",
                "second_doc": "\"\"\"\nEnsures that any modifications to operating system environment variables made during a test are reverted afterward, maintaining test isolation and preventing interactions between tests.\n\nArgs:\n    monkeypatch: The pytest fixture used to temporarily modify environment variables during testing.\n    _standard_os_environ: A dictionary containing the original environment variables snapshot to restore after each test.\n\nReturns:\n    None: This is an automatically applied pytest fixture used for environment management and does not return a value.\n\"\"\"",
                "source_code": "monkeypatch._setitem.extend(_standard_os_environ)"
            },
            "type": "function"
        },
        {
            "methods": [],
            "name": "Flask",
            "type": "class"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "app",
                "second_doc": "\"\"\"\nInitializes and returns a Flask application instance configured with the current file's directory as its root path.\n\nThis setup delivers a configured web application object, ready to be further developed or run, thereby enabling the creation and management of web server components and routing.\n\nArgs:\n    None\n\nReturns:\n    Flask: An instance of the Flask web application class, pre-configured with the specified application name and root directory.\n\"\"\"",
                "source_code": "app = Flask(\"flask_test\", root_path=os.path.dirname(__file__))\n    return app"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "app_ctx",
                "second_doc": "\"\"\"\nContext manager that sets up and provides the active application context for Flask operations.\n\nThis method temporarily makes the application's context active, allowing access to resources like configuration, request variables, and database connections within its scope. It is useful for ensuring that Flask-specific functions work correctly outside the standard request-response cycle or during testing.\n\nArgs:\n    None\n\nYields:\n    ctx: The active Flask application context object.\n\"\"\"",
                "source_code": "with app.app_context() as ctx:\n        yield ctx"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "req_ctx",
                "second_doc": "\"\"\"\nCreate and yield a Flask test request context for use within a code block or test.\n\nThis allows for the simulation of request-specific variables and environment, enabling code that relies on request context to be safely tested or executed outside of an actual HTTP request.\n\nYields:\n    flask.ctx.RequestContext: The Flask request context created for testing.\n\"\"\"",
                "source_code": "with app.test_request_context() as ctx:\n        yield ctx"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "client",
                "second_doc": "\"\"\"\nCreates and returns a test client for the application, enabling simulation of HTTP requests to the app in a controlled testing environment.\n\nThis helps ensure that application routes and logic can be verified without running a live server.\n\nReturns:\n    flask.testing.FlaskClient: An instance for simulating requests to the application for testing purposes.\n\"\"\"",
                "source_code": "return app.test_client()"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_apps",
                "second_doc": "\"\"\"\nPrepend the path to the 'test_apps' directory to the system module search path, ensuring that test-specific application modules can be imported during the testing process.\n\nArgs:\n    monkeypatch: A pytest fixture used to safely modify and restore the Python runtime environment for testing.\n\nReturns:\n    None\n\nWhy:\n    This setup is necessary so that Python can locate and load modules from the designated test applications directory, enabling isolated and reliable testing of application components that depend on those modules.\n\"\"\"",
                "source_code": "monkeypatch.syspath_prepend(\n        os.path.abspath(os.path.join(os.path.dirname(__file__), \"test_apps\"))\n    )"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "leak_detector",
                "second_doc": "\"\"\"\nAutomatically checks each test for leaked Flask request contexts and cleans them up.\n\nThis fixture ensures that no lingering request contexts remain after a test has run, which prevents interference between tests and maintains isolation in test execution.\n\nWhy:\nRequest contexts in Flask manage variables and state for each HTTP request. Not cleaning them up after tests could lead to state leakage between tests, resulting in unpredictable test outcomes.\n\nYields:\n    None: Allows the test to execute, and then performs cleanup and leak detection afterwards.\n\"\"\"",
                "source_code": "yield\n\n    # make sure we're not leaking a request context since we are\n    # testing flask internally in debug mode in a few cases\n    leaks = []\n    while flask._request_ctx_stack.top is not None:\n        leaks.append(flask._request_ctx_stack.pop())\n    assert leaks == []"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": "\"\"\"Patch pkgutil.get_loader to give loader without get_filename or archive.\n\n    This provides for tests where a system has custom loaders, e.g. Google App\n    Engine's HardenedModulesHook, which have neither the `get_filename` method\n    nor the `archive` attribute.\n\n    This fixture will run the testcase twice, once with and once without the\n    limitation/mock.\n    \"\"\"",
                "first_doc": "\"\"\"\nModifies the pkgutil.get_loader function within the test scope, limiting access to certain attributes for loader objects.\n\nArgs:\n    request: Pytest fixture request object, provides access to the current parameter.\n    monkeypatch: Utility to temporarily modify or replace objects for testing.\n\nReturns:\n    None: This fixture modifies behavior by patching pkgutil.get_loader and does not return a value.\n\nClass Fields Initialized:\n    loader: Stores the original loader object to delegate most attribute accesses.\n\"\"\"",
                "method_name": "limit_loader",
                "second_doc": "\"\"\"\nTemporarily replaces pkgutil.get_loader during test execution to simulate a loader lacking specific attributes, enhancing test coverage for code paths that must handle such cases.\n\nArgs:\n    request: Pytest fixture request object that determines whether the patch should be applied for this test case.\n    monkeypatch: Pytest utility for dynamically modifying or replacing objects for the duration of the test.\n\nReturns:\n    None: The function acts as a fixture and does not return a value; it operates by altering the environment for the scope of the test.\n\nClass Fields Initialized:\n    loader: Stores the original loader instance, enabling the proxy object to delegate attribute access except for explicitly blocked attributes ('archive' and 'get_filename').\n\"\"\"",
                "source_code": "if not request.param:\n        return\n\n    class LimitedLoader:\n        def __init__(self, loader):\n            self.loader = loader\n\n        def __getattr__(self, name):\n            if name in {\"archive\", \"get_filename\"}:\n                raise AttributeError(f\"Mocking a loader which does not have {name!r}.\")\n            return getattr(self.loader, name)\n\n    old_get_loader = pkgutil.get_loader\n\n    def get_loader(*args, **kwargs):\n        return LimitedLoader(old_get_loader(*args, **kwargs))\n\n    monkeypatch.setattr(pkgutil, \"get_loader\", get_loader)"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": "\"\"\"A tmpdir added to sys.path.\"\"\"",
                "first_doc": "\"\"\"\nCreates a temporary directory for modules and prepends it to the system path.\n\nThis method creates a new temporary directory under the provided tmpdir for storing modules. It also prepends this directory to the system path using the given monkeypatch utility, allowing Python to import modules from the temporary location.\n\nArgs:\n    tmpdir: A directory object used as the base for creating the temporary modules directory.\n    monkeypatch: An object used to temporarily modify sys.path for the duration of the test.\n\nReturns:\n    The created temporary directory object for module storage.\n\"\"\"",
                "method_name": "modules_tmpdir",
                "second_doc": "\"\"\"\nSets up a temporary directory specifically for Python modules and ensures it is discovered first during module import resolution.\n\nBy creating a temporary storage location and prioritizing it in the system's import path, the method provides an isolated environment for dynamically created or test-specific modules. This isolation is essential for tests that require custom modules or need to avoid side effects on or from the global module search path.\n\nArgs:\n    tmpdir: The base directory used to create the temporary modules subdirectory.\n    monkeypatch: Utility for temporarily modifying the Python system path during test execution.\n\nReturns:\n    The temporary directory object where module files can be stored and from which they will be imported.\n\"\"\"",
                "source_code": "rv = tmpdir.mkdir(\"modules_tmpdir\")\n    monkeypatch.syspath_prepend(str(rv))\n    return rv"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "modules_tmpdir_prefix",
                "second_doc": "\"\"\"\nTemporarily modifies the Python sys.prefix to point to the given modules_tmpdir directory, allowing runtime components to behave as if installed under this new path.\n\nArgs:\n    monkeypatch: A pytest fixture for safely modifying attributes during test execution.\n    modules_tmpdir: A temporary directory object to use as the Python prefix.\n\nReturns:\n    The modules_tmpdir directory, now set as sys.prefix.\n    \nThis is done to enable testing of code behavior in an isolated or non-standard environment, simulating how components would operate if installed to a different Python environment root.\n\"\"\"",
                "source_code": "monkeypatch.setattr(sys, \"prefix\", str(modules_tmpdir))\n    return modules_tmpdir"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": "\"\"\"Create a fake site-packages.\"\"\"",
                "first_doc": "\"\"\"\nCreates and returns a temporary 'site-packages' directory for testing, and prepends its path to sys.path.\n\nArgs:\n    modules_tmpdir: The temporary directory fixture to create nested directories for the test environment.\n    monkeypatch: The fixture used to modify sys.path during tests.\n\nReturns:\n    The path object representing the created 'site-packages' directory.\n\"\"\"",
                "method_name": "site_packages",
                "second_doc": "\"\"\"\nSets up an isolated 'site-packages' directory within a temporary structure for use in tests, and ensures it is prioritized in the Python import path. This enables accurate simulation of package installations and import behaviors in a controlled environment, which is essential for testing scenarios without interference from globally installed packages.\n\nArgs:\n    modules_tmpdir: A temporary directory fixture used to create nested test environment directories.\n    monkeypatch: A test fixture for modifying sys.path during test execution.\n\nReturns:\n    pathlib.Path: Path object representing the newly created 'site-packages' directory.\n\"\"\"",
                "source_code": "rv = (\n        modules_tmpdir.mkdir(\"lib\")\n        .mkdir(f\"python{sys.version_info.major}.{sys.version_info.minor}\")\n        .mkdir(\"site-packages\")\n    )\n    monkeypatch.syspath_prepend(str(rv))\n    return rv"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": "\"\"\"Generate egg from package name inside base and put the egg into\n    sys.path.\"\"\"",
                "first_doc": "\"\"\"\nCreates a Python package directory, writes basic setup files, builds a distributable egg, and prepends the egg's path to sys.path for module import.\n\nArgs:\n    name: The name of the Python package to create and install as an egg.\n    base: The temporary directory path where the package structure and its files will be created. Defaults to the provided modules_tmpdir.\n\nReturns:\n    The path to the generated egg file, which has been added to the beginning of sys.path for immediate use.\n\"\"\"",
                "method_name": "install_egg",
                "second_doc": "\"\"\"\nCreates a new Python package in a temporary directory, generates necessary setup files, builds a distributable egg package, and adds it to the beginning of sys.path to make the package immediately importable for testing or dynamic use.\n\nThis approach enables rapid creation and use of isolated test modules, which is helpful for testing and experimenting with dynamic imports and package distribution workflows.\n\nArgs:\n    name (str): The name of the Python package to create and install as an egg.\n    base (LocalPath, optional): The temporary directory path for package creation. Defaults to modules_tmpdir.\n\nReturns:\n    LocalPath: The path to the generated egg file, now accessible on sys.path.\n\"\"\"",
                "source_code": "def inner(name, base=modules_tmpdir):\n        base.join(name).ensure_dir()\n        base.join(name).join(\"__init__.py\").ensure()\n\n        egg_setup = base.join(\"setup.py\")\n        egg_setup.write(\n            textwrap.dedent(\n                f\"\"\"\n                from setuptools import setup\n                setup(\n                    name=\"{name}\",\n                    version=\"1.0\",\n                    packages=[\"site_egg\"],\n                    zip_safe=True,\n                )\n                \"\"\"\n            )\n        )\n\n        import subprocess\n\n        subprocess.check_call(\n            [sys.executable, \"setup.py\", \"bdist_egg\"], cwd=str(modules_tmpdir)\n        )\n        (egg_path,) = modules_tmpdir.join(\"dist/\").listdir()\n        monkeypatch.syspath_prepend(str(egg_path))\n        return egg_path\n\n    return inner"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "purge_module",
                "second_doc": "\"\"\"\nRemoves a specified module from the system modules cache after test finalization to ensure a clean test environment and prevent side effects from module reuse.\n\nArgs:\n    name (str): The name of the module to be removed from sys.modules.\n\nReturns:\n    function: A function that, when called, schedules the removal of the specified module after test execution.\n\"\"\"",
                "source_code": "def inner(name):\n        request.addfinalizer(lambda: sys.modules.pop(name, None))\n\n    return inner"
            },
            "type": "function"
        }
    ],
    "flask/tests/test_appctx.py": [
        {
            "details": {
                "docstring": null,
                "method_name": "test_basic_url_generation",
                "second_doc": "\"\"\"\nTests that URL generation takes application configuration (server name and preferred scheme) into account to produce the expected absolute URL for a defined route.\n\nArgs:\n    None\n\nReturns:\n    None\n\nWhy:\n    Ensures that URL building within the application's context correctly reflects configuration settings, providing reliable and predictable URL generation for various deployment scenarios.\n\"\"\"",
                "source_code": "app.config[\"SERVER_NAME\"] = \"localhost\"\n    app.config[\"PREFERRED_URL_SCHEME\"] = \"https\"\n\n    @app.route(\"/\")\n    def index():\n        pass\n\n    with app.app_context():\n        rv = flask.url_for(\"index\")\n        assert rv == \"https://localhost/\""
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_url_generation_requires_server_name",
                "second_doc": "\"\"\"\nTests that generating a URL with flask.url_for outside a request context raises a RuntimeError.\n\nThis enforces correct context usage when generating URLs within the application, helping to prevent errors due to missing configuration or request information.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "with app.app_context():\n        with pytest.raises(RuntimeError):\n            flask.url_for(\"index\")"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_url_generation_without_context_fails",
                "second_doc": "\"\"\"\nTests that attempting to generate a URL with flask.url_for outside of an application or request context raises a RuntimeError.\n\nThis ensures that url_for is correctly restricted to valid application or request contexts to prevent misuse and accidental errors.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "with pytest.raises(RuntimeError):\n        flask.url_for(\"index\")"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_request_context_means_app_context",
                "second_doc": "\"\"\"\nEnsures that entering a request context also sets up the corresponding application context, and that the context stack is cleaned up after exiting.\n\nThis test verifies context management to guarantee that resources and configurations bound to the application are available during a request and correctly disposed when the request ends.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "with app.test_request_context():\n        assert flask.current_app._get_current_object() == app\n    assert flask._app_ctx_stack.top is None"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_app_context_provides_current_app",
                "second_doc": "\"\"\"\nVerifies that within an application context, the correct application instance is accessible as the current app, and confirms proper cleanup of the application context stack afterwards.\n\nThis ensures reliable access to application-specific objects during context-managed operations and validates that no residual context remains after exiting.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "with app.app_context():\n        assert flask.current_app._get_current_object() == app\n    assert flask._app_ctx_stack.top is None"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_app_tearing_down",
                "second_doc": "\"\"\"\nTests that functions registered with the application context teardown mechanism are properly invoked when the application context ends.\n\nThis method verifies that registered teardown callbacks receive the correct exception argument (None when no exception occurs), ensuring reliable cleanup of resources and state after the application context is closed.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "cleanup_stuff = []\n\n    @app.teardown_appcontext\n    def cleanup(exception):\n        cleanup_stuff.append(exception)\n\n    with app.app_context():\n        pass\n\n    assert cleanup_stuff == [None]"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_app_tearing_down_with_previous_exception",
                "second_doc": "\"\"\"\nTests that the teardown handler for the application context is called with the correct exception argument when an exception has previously occurred and been handled.\n\nArgs:\n    None\n\nReturns:\n    None\n\nWhy: Ensures that resource cleanup functions are consistently invoked upon context teardown, whether or not an exception was propagated, providing predictable context management and reliability in application behavior.\n\"\"\"",
                "source_code": "cleanup_stuff = []\n\n    @app.teardown_appcontext\n    def cleanup(exception):\n        cleanup_stuff.append(exception)\n\n    try:\n        raise Exception(\"dummy\")\n    except Exception:\n        pass\n\n    with app.app_context():\n        pass\n\n    assert cleanup_stuff == [None]"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_app_tearing_down_with_handled_exception_by_except_block",
                "second_doc": "\"\"\"\nTests that the teardown mechanism for the application context correctly calls registered cleanup functions and supplies the expected exception value when an exception is handled within a try/except block.\n\nArgs:\n    None\n\nReturns:\n    None\n\nThis test ensures that, when an exception is raised and handled within the application context, the teardown function receives None as the exception argument, confirming the application's cleanup logic behaves as intended even in exception scenarios.\n\"\"\"",
                "source_code": "cleanup_stuff = []\n\n    @app.teardown_appcontext\n    def cleanup(exception):\n        cleanup_stuff.append(exception)\n\n    with app.app_context():\n        try:\n            raise Exception(\"dummy\")\n        except Exception:\n            pass\n\n    assert cleanup_stuff == [None]"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_app_tearing_down_with_handled_exception_by_app_handler",
                "second_doc": "\"\"\"\nTest that the application correctly cleans up resources when a handled exception occurs within a request, ensuring teardown functions are executed regardless of error handling.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "app.config[\"PROPAGATE_EXCEPTIONS\"] = True\n    cleanup_stuff = []\n\n    @app.teardown_appcontext\n    def cleanup(exception):\n        cleanup_stuff.append(exception)\n\n    @app.route(\"/\")\n    def index():\n        raise Exception(\"dummy\")\n\n    @app.errorhandler(Exception)\n    def handler(f):\n        return flask.jsonify(str(f))\n\n    with app.app_context():\n        client.get(\"/\")\n\n    assert cleanup_stuff == [None]"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_app_tearing_down_with_unhandled_exception",
                "second_doc": "\"\"\"\nTests that the teardown application context handler receives the exception object when an unhandled exception occurs during a request. This ensures that resource cleanup and error handling routines have access to exception details after an error in the request lifecycle.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "app.config[\"PROPAGATE_EXCEPTIONS\"] = True\n    cleanup_stuff = []\n\n    @app.teardown_appcontext\n    def cleanup(exception):\n        cleanup_stuff.append(exception)\n\n    @app.route(\"/\")\n    def index():\n        raise Exception(\"dummy\")\n\n    with pytest.raises(Exception):\n        with app.app_context():\n            client.get(\"/\")\n\n    assert len(cleanup_stuff) == 1\n    assert isinstance(cleanup_stuff[0], Exception)\n    assert str(cleanup_stuff[0]) == \"dummy\""
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_app_ctx_globals_methods",
                "second_doc": "\"\"\"\nTests the key-value storage and manipulation methods of the application context global object. This ensures that the context-specific storage correctly supports standard dictionary-like operations such as getting, setting, checking containment, default value assignment, popping values, iteration, and string representation.\n\nArgs:\n    None\n\nReturns:\n    None\n\nWhy:\n    Verifying these behaviors is crucial for confirming that application-scoped data can be reliably stored and accessed during a request lifecycle, which is fundamental for functions that depend on temporary, per-request data.\n\"\"\"",
                "source_code": "assert flask.g.get(\"foo\") is None\n    assert flask.g.get(\"foo\", \"bar\") == \"bar\"\n    # __contains__\n    assert \"foo\" not in flask.g\n    flask.g.foo = \"bar\"\n    assert \"foo\" in flask.g\n    # setdefault\n    flask.g.setdefault(\"bar\", \"the cake is a lie\")\n    flask.g.setdefault(\"bar\", \"hello world\")\n    assert flask.g.bar == \"the cake is a lie\"\n    # pop\n    assert flask.g.pop(\"bar\") == \"the cake is a lie\"\n    with pytest.raises(KeyError):\n        flask.g.pop(\"bar\")\n    assert flask.g.pop(\"bar\", \"more cake\") == \"more cake\"\n    # __iter__\n    assert list(flask.g) == [\"foo\"]\n    # __repr__\n    assert repr(flask.g) == \"<flask.g of 'flask_test'>\""
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_custom_app_ctx_globals_class",
                "second_doc": "\"\"\"\nTest that a custom global object class is correctly used within the application context.\n\nThis ensures that developers can customize the application context's g object to store arbitrary data, allowing for greater flexibility and extensibility in how global data is managed during request handling and template rendering.\n\nArgs:\n    None\n\nReturns:\n    None; asserts that a custom attribute set on the global object is available within templates rendered in the application context.\n\"\"\"",
                "source_code": "class CustomRequestGlobals:\n        def __init__(self):\n            self.spam = \"eggs\"\n\n    app.app_ctx_globals_class = CustomRequestGlobals\n    with app.app_context():\n        assert flask.render_template_string(\"{{ g.spam }}\") == \"eggs\""
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_context_refcounts",
                "second_doc": "\"\"\"\nTests that the teardown request and application context handlers are called in the correct order and the context references are managed properly to avoid resource leaks.\n\nArgs:\n    None\n\nReturns:\n    None\n\nWhy:\n    Ensuring proper teardown of request and application contexts is crucial for cleaning up resources and maintaining application stability after processing each request.\n\"\"\"",
                "source_code": "called = []\n\n    @app.teardown_request\n    def teardown_req(error=None):\n        called.append(\"request\")\n\n    @app.teardown_appcontext\n    def teardown_app(error=None):\n        called.append(\"app\")\n\n    @app.route(\"/\")\n    def index():\n        with flask._app_ctx_stack.top:\n            with flask._request_ctx_stack.top:\n                pass\n        env = flask._request_ctx_stack.top.request.environ\n        assert env[\"werkzeug.request\"] is not None\n        return \"\"\n\n    res = client.get(\"/\")\n    assert res.status_code == 200\n    assert res.data == b\"\"\n    assert called == [\"request\", \"app\"]"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_clean_pop",
                "second_doc": "\"\"\"\nTests that the teardown procedures for requests and application context are executed properly, ensuring resources are cleaned up and application state is correctly reset at the end of a request cycle.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "app.testing = False\n    called = []\n\n    @app.teardown_request\n    def teardown_req(error=None):\n        1 / 0\n\n    @app.teardown_appcontext\n    def teardown_app(error=None):\n        called.append(\"TEARDOWN\")\n\n    try:\n        with app.test_request_context():\n            called.append(flask.current_app.name)\n    except ZeroDivisionError:\n        pass\n\n    assert called == [\"flask_test\", \"TEARDOWN\"]\n    assert not flask.current_app"
            },
            "type": "function"
        }
    ],
    "flask/tests/test_apps/blueprintapp/__init__.py": [],
    "flask/tests/test_apps/blueprintapp/apps/__init__.py": [],
    "flask/tests/test_apps/blueprintapp/apps/admin/__init__.py": [
        {
            "details": {
                "docstring": null,
                "method_name": "index",
                "second_doc": "\"\"\"\nRenders the main page of the admin interface by returning the corresponding HTML template.\n\nThis method enables users to access the entry point of the administrative section, facilitating further navigation and management actions.\n\nReturns:\n    str: Rendered HTML content for the admin index page.\n\"\"\"",
                "source_code": "return render_template(\"admin/index.html\")"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "index2",
                "second_doc": "\"\"\"\nRenders the admin dashboard template when the corresponding route is accessed.  \nThis method serves the HTML content for the admin interface, providing a web-based point of interaction for administrative users.\n\nReturns:\n    str: Rendered HTML content of the admin dashboard page.\n\"\"\"",
                "source_code": "return render_template(\"./admin/index.html\")"
            },
            "type": "function"
        }
    ],
    "flask/tests/test_apps/blueprintapp/apps/frontend/__init__.py": [
        {
            "details": {
                "docstring": null,
                "method_name": "index",
                "second_doc": "\"\"\"\nHandles requests to the root URL and renders the main landing page template.\n\nThis method responds to user visits at the site's base address by displaying the initial HTML interface of the application, enabling interaction with the web application's core features.\n\nReturns:\n    str: The rendered HTML content of the 'frontend/index.html' template for display in the user's browser.\n\"\"\"",
                "source_code": "return render_template(\"frontend/index.html\")"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "missing_template",
                "second_doc": "\"\"\"\nHandles HTTP requests to the '/missing' route by rendering a specific template for missing or unavailable resources. This helps inform users when the requested content cannot be found or is temporarily inaccessible.\n\nArgs:\n    None\n\nReturns:\n    A rendered HTML page from 'missing_template.html', returned as a Flask response object.\n\"\"\"",
                "source_code": "return render_template(\"missing_template.html\")"
            },
            "type": "function"
        }
    ],
    "flask/tests/test_apps/cliapp/__init__.py": [],
    "flask/tests/test_apps/cliapp/app.py": [],
    "flask/tests/test_apps/cliapp/factory.py": [
        {
            "details": {
                "docstring": null,
                "method_name": "create_app",
                "second_doc": "\"\"\"\nInitializes and returns a new Flask application instance.\n\nThis method serves as a starting point for configuring and running a web application, enabling the registration of routes, middleware, extensions, and configuration settings. By returning a Flask app object, it allows the developer to set up the application's behavior and respond to incoming web requests.\n\nReturns:\n    Flask: A new instance of a Flask web application.\n\"\"\"",
                "source_code": "return Flask(\"app\")"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "create_app2",
                "second_doc": "\"\"\"\nCreates and returns a new Flask application instance with a unique name constructed from the provided parameters.\n\nArgs:\n    foo (str): A string segment to include in the application name.\n    bar (str): Another string segment to include in the application name.\n\nReturns:\n    Flask: A new Flask application object with a name incorporating the given parameters.\n\nThis method enables the differentiation of multiple Flask applications, which can be useful in scenarios where separate app contexts or configurations are required.\n\"\"\"",
                "source_code": "return Flask(\"_\".join([\"app2\", foo, bar]))"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "no_app",
                "second_doc": "\"\"\"\nPlaceholder method with no implementation.\n\nThis method exists to reserve a spot for potential functionality within the framework, ensuring extensibility or maintaining a consistent interface as the application evolves.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "pass"
            },
            "type": "function"
        }
    ],
    "flask/tests/test_apps/cliapp/importerrorapp.py": [],
    "flask/tests/test_apps/cliapp/inner1/__init__.py": [],
    "flask/tests/test_apps/cliapp/inner1/inner2/__init__.py": [],
    "flask/tests/test_apps/cliapp/inner1/inner2/flask.py": [],
    "flask/tests/test_apps/cliapp/multiapp.py": [],
    "flask/tests/test_apps/helloworld/hello.py": [
        {
            "details": {
                "docstring": null,
                "method_name": "hello",
                "second_doc": "\"\"\"\nHandles HTTP GET requests to the root URL path by returning a simple greeting message.\n\nThis route provides a basic response to verify that the web server is running and accessible by clients.\n\nReturns:\n    str: A plain text message, \"Hello World!\", indicating successful server response.\n\"\"\"",
                "source_code": "return \"Hello World!\""
            },
            "type": "function"
        }
    ],
    "flask/tests/test_apps/helloworld/wsgi.py": [],
    "flask/tests/test_apps/subdomaintestmodule/__init__.py": [],
    "flask/tests/test_basic.py": [
        {
            "details": {
                "docstring": null,
                "method_name": "test_options_work",
                "second_doc": "\"\"\"\nTests that sending an OPTIONS request to the server's root endpoint returns the expected set of allowed HTTP methods and an empty response body.\n\nArgs:\n    None\n\nReturns:\n    None\n\nWhy:\n    To ensure that the server correctly handles OPTIONS requests, which are important for clients to discover available methods and for compliance with HTTP standards.\n\"\"\"",
                "source_code": "@app.route(\"/\", methods=[\"GET\", \"POST\"])\n    def index():\n        return \"Hello World\"\n\n    rv = client.open(\"/\", method=\"OPTIONS\")\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\", \"OPTIONS\", \"POST\"]\n    assert rv.data == b\"\""
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_options_on_multiple_rules",
                "second_doc": "\"\"\"\nTests that the HTTP OPTIONS method correctly reflects all available HTTP methods for a given route when multiple rules are defined. This verifies that clients can accurately discover which actions are supported on a specific endpoint.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "@app.route(\"/\", methods=[\"GET\", \"POST\"])\n    def index():\n        return \"Hello World\"\n\n    @app.route(\"/\", methods=[\"PUT\"])\n    def index_put():\n        return \"Aha!\"\n\n    rv = client.open(\"/\", method=\"OPTIONS\")\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\", \"OPTIONS\", \"POST\", \"PUT\"]"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_provide_automatic_options_attr",
                "second_doc": "\"\"\"\nTests how the manual control of automatic handling of HTTP OPTIONS requests affects route responses by adjusting the provide_automatic_options attribute on view functions.\n\nArgs:\n    None\n\nReturns:\n    None\n\nWhy:\n    This method evaluates whether disabling or enabling Flask's automatic OPTIONS handling leads to expected HTTP status codes and allowed methods for a route, ensuring the developer can explicitly control request method handling when necessary.\n\"\"\"",
                "source_code": "app = flask.Flask(__name__)\n\n    def index():\n        return \"Hello World!\"\n\n    index.provide_automatic_options = False\n    app.route(\"/\")(index)\n    rv = app.test_client().open(\"/\", method=\"OPTIONS\")\n    assert rv.status_code == 405\n\n    app = flask.Flask(__name__)\n\n    def index2():\n        return \"Hello World!\"\n\n    index2.provide_automatic_options = True\n    app.route(\"/\", methods=[\"OPTIONS\"])(index2)\n    rv = app.test_client().open(\"/\", method=\"OPTIONS\")\n    assert sorted(rv.allow) == [\"OPTIONS\"]"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_provide_automatic_options_kwarg",
                "second_doc": "\"\"\"\nTests that when the automatic handling of HTTP OPTIONS requests is disabled for specific routes, the application explicitly enforces allowed methods and returns correct responses for unsupported methods. \n\nArgs:\n    None\n\nReturns:\n    None\n\nWhy:\n    This ensures that method restrictions and error responses are handled according to the developer's explicit configuration, providing greater control over route behavior and HTTP compliance when default automated handling is not desired.\n\"\"\"",
                "source_code": "def index():\n        return flask.request.method\n\n    def more():\n        return flask.request.method\n\n    app.add_url_rule(\"/\", view_func=index, provide_automatic_options=False)\n    app.add_url_rule(\n        \"/more\",\n        view_func=more,\n        methods=[\"GET\", \"POST\"],\n        provide_automatic_options=False,\n    )\n    assert client.get(\"/\").data == b\"GET\"\n\n    rv = client.post(\"/\")\n    assert rv.status_code == 405\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\"]\n\n    rv = client.open(\"/\", method=\"OPTIONS\")\n    assert rv.status_code == 405\n\n    rv = client.head(\"/\")\n    assert rv.status_code == 200\n    assert not rv.data  # head truncates\n    assert client.post(\"/more\").data == b\"POST\"\n    assert client.get(\"/more\").data == b\"GET\"\n\n    rv = client.delete(\"/more\")\n    assert rv.status_code == 405\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\", \"POST\"]\n\n    rv = client.open(\"/more\", method=\"OPTIONS\")\n    assert rv.status_code == 405"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_request_dispatching",
                "second_doc": "\"\"\"\nTests how different HTTP request methods are dispatched and handled by route endpoints, verifying method-specific behavior and proper HTTP status code responses.\n\nArgs:\n    None\n\nReturns:\n    None\n\nWhy:\n    Ensures that the routing and request method handling logic of the application returns correct responses and errors according to standard HTTP semantics, which is critical for web framework reliability and correctness.\n\"\"\"",
                "source_code": "@app.route(\"/\")\n    def index():\n        return flask.request.method\n\n    @app.route(\"/more\", methods=[\"GET\", \"POST\"])\n    def more():\n        return flask.request.method\n\n    assert client.get(\"/\").data == b\"GET\"\n    rv = client.post(\"/\")\n    assert rv.status_code == 405\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\", \"OPTIONS\"]\n    rv = client.head(\"/\")\n    assert rv.status_code == 200\n    assert not rv.data  # head truncates\n    assert client.post(\"/more\").data == b\"POST\"\n    assert client.get(\"/more\").data == b\"GET\"\n    rv = client.delete(\"/more\")\n    assert rv.status_code == 405\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\", \"OPTIONS\", \"POST\"]"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_disallow_string_for_allowed_methods",
                "second_doc": "\"\"\"\nTest that passing a string instead of an iterable to the route's 'methods' argument raises a TypeError.\n\nArgs:\n    None\n\nReturns:\n    None\n\nRaises:\n    TypeError: If the 'methods' parameter is not an iterable as expected.\n    \nWhy:\n    Ensures that only appropriate data types are accepted for defining allowed HTTP methods on a route, helping prevent configuration errors and ensuring consistent request handling.\n\"\"\"",
                "source_code": "with pytest.raises(TypeError):\n\n        @app.route(\"/\", methods=\"GET POST\")\n        def index():\n            return \"Hey\""
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_url_mapping",
                "second_doc": "\"\"\"\nTests that URL routing, HTTP method handling, and automatic OPTIONS responses behave as expected for different endpoints.\n\nThis method verifies that the application responds correctly to various HTTP methods for defined routes, ensuring method restrictions and automatic response behavior align with the application's URL rule configurations. This is essential for maintaining reliable API behavior and enforcing route access control in web applications.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "random_uuid4 = \"7eb41166-9ebf-4d26-b771-ea3f54f8b383\"\n\n    def index():\n        return flask.request.method\n\n    def more():\n        return flask.request.method\n\n    def options():\n        return random_uuid4\n\n    app.add_url_rule(\"/\", \"index\", index)\n    app.add_url_rule(\"/more\", \"more\", more, methods=[\"GET\", \"POST\"])\n\n    # Issue 1288: Test that automatic options are not added\n    #             when non-uppercase 'options' in methods\n    app.add_url_rule(\"/options\", \"options\", options, methods=[\"options\"])\n\n    assert client.get(\"/\").data == b\"GET\"\n    rv = client.post(\"/\")\n    assert rv.status_code == 405\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\", \"OPTIONS\"]\n    rv = client.head(\"/\")\n    assert rv.status_code == 200\n    assert not rv.data  # head truncates\n    assert client.post(\"/more\").data == b\"POST\"\n    assert client.get(\"/more\").data == b\"GET\"\n    rv = client.delete(\"/more\")\n    assert rv.status_code == 405\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\", \"OPTIONS\", \"POST\"]\n    rv = client.open(\"/options\", method=\"OPTIONS\")\n    assert rv.status_code == 200\n    assert random_uuid4 in rv.data.decode(\"utf-8\")"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_werkzeug_routing",
                "second_doc": "\"\"\"\nTests the application's URL routing by adding sub-routes under a common path and verifying that each path correctly resolves to its associated view function.\n\nArgs:\n    None\n\nReturns:\n    None\n\nWhy:\n    This method ensures that the application's route mapping is configured correctly, so that incoming requests are properly matched with their handler functions for both normal and submounted URL paths.\n\"\"\"",
                "source_code": "from werkzeug.routing import Submount, Rule\n\n    app.url_map.add(\n        Submount(\"/foo\", [Rule(\"/bar\", endpoint=\"bar\"), Rule(\"/\", endpoint=\"index\")])\n    )\n\n    def bar():\n        return \"bar\"\n\n    def index():\n        return \"index\"\n\n    app.view_functions[\"bar\"] = bar\n    app.view_functions[\"index\"] = index\n\n    assert client.get(\"/foo/\").data == b\"index\"\n    assert client.get(\"/foo/bar\").data == b\"bar\""
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_endpoint_decorator",
                "second_doc": "\"\"\"\nTests that URL rules grouped under a submount are correctly routed to their respective endpoint handlers, verifying route resolution and endpoint registration.\n\nArgs:\n    None\n\nReturns:\n    None\n\nWhy:\n    Ensures that the application's routing system appropriately maps incoming HTTP requests to their defined Python handler functions, maintaining route correctness and handler association within grouped URL patterns.\n\"\"\"",
                "source_code": "from werkzeug.routing import Submount, Rule\n\n    app.url_map.add(\n        Submount(\"/foo\", [Rule(\"/bar\", endpoint=\"bar\"), Rule(\"/\", endpoint=\"index\")])\n    )\n\n    @app.endpoint(\"bar\")\n    def bar():\n        return \"bar\"\n\n    @app.endpoint(\"index\")\n    def index():\n        return \"index\"\n\n    assert client.get(\"/foo/\").data == b\"index\"\n    assert client.get(\"/foo/bar\").data == b\"bar\""
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_session",
                "second_doc": "\"\"\"\nTests the session management behavior by verifying that session access and modification flags are set appropriately when storing and retrieving values through POST and GET requests.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "@app.route(\"/set\", methods=[\"POST\"])\n    def set():\n        assert not flask.session.accessed\n        assert not flask.session.modified\n        flask.session[\"value\"] = flask.request.form[\"value\"]\n        assert flask.session.accessed\n        assert flask.session.modified\n        return \"value set\"\n\n    @app.route(\"/get\")\n    def get():\n        assert not flask.session.accessed\n        assert not flask.session.modified\n        v = flask.session.get(\"value\", \"None\")\n        assert flask.session.accessed\n        assert not flask.session.modified\n        return v\n\n    assert client.post(\"/set\", data={\"value\": \"42\"}).data == b\"value set\"\n    assert client.get(\"/get\").data == b\"42\""
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_session_using_server_name",
                "second_doc": "\"\"\"\nTests that setting the application server name correctly configures session cookies for the appropriate domain and security settings.\n\nArgs:\n    None\n\nReturns:\n    None\n\nWhy:\n    Ensuring the session cookie's domain and security attributes are set as expected verifies that client sessions are reliably scoped to the correct server and protected, which is essential for secure and predictable session management in web applications.\n\"\"\"",
                "source_code": "app.config.update(SERVER_NAME=\"example.com\")\n\n    @app.route(\"/\")\n    def index():\n        flask.session[\"testing\"] = 42\n        return \"Hello World\"\n\n    rv = client.get(\"/\", \"http://example.com/\")\n    assert \"domain=.example.com\" in rv.headers[\"set-cookie\"].lower()\n    assert \"httponly\" in rv.headers[\"set-cookie\"].lower()"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_session_using_server_name_and_port",
                "second_doc": "\"\"\"\nTests whether session cookies are set correctly when the application is configured with a specific server name and port, ensuring that cookies include the correct domain attributes for client-server interactions.\n\nArgs:\n    None\n\nReturns:\n    None\n\nWhy:\n    By verifying cookie domain and flags such as \"httponly,\" the test ensures that session management functions correctly under custom server configuration, which is important for maintaining secure, consistent user sessions and correct cookie scoping in deployed web environments.\n\"\"\"",
                "source_code": "app.config.update(SERVER_NAME=\"example.com:8080\")\n\n    @app.route(\"/\")\n    def index():\n        flask.session[\"testing\"] = 42\n        return \"Hello World\"\n\n    rv = client.get(\"/\", \"http://example.com:8080/\")\n    assert \"domain=.example.com\" in rv.headers[\"set-cookie\"].lower()\n    assert \"httponly\" in rv.headers[\"set-cookie\"].lower()"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_session_using_server_name_port_and_path",
                "second_doc": "\"\"\"\nTests that the session cookie is set with the correct domain and path attributes based on the application's server name and root configuration. This ensures session cookies are properly scoped to the specified domain and application path for secure and predictable client behavior.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "app.config.update(SERVER_NAME=\"example.com:8080\", APPLICATION_ROOT=\"/foo\")\n\n    @app.route(\"/\")\n    def index():\n        flask.session[\"testing\"] = 42\n        return \"Hello World\"\n\n    rv = client.get(\"/\", \"http://example.com:8080/foo\")\n    assert \"domain=example.com\" in rv.headers[\"set-cookie\"].lower()\n    assert \"path=/foo\" in rv.headers[\"set-cookie\"].lower()\n    assert \"httponly\" in rv.headers[\"set-cookie\"].lower()"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_session_using_application_root",
                "second_doc": "\"\"\"\nTests that the session cookie path is correctly set according to the application root prefix, ensuring session data remains scoped and consistent for applications deployed under a specific URL subpath.\n\nArgs:\n    None\n\nReturns:\n    None\n\nWhy:\n    Ensuring session cookies are set with the correct path attribute is critical for isolating user state between applications mounted at different locations and for the secure, predictable functioning of session management in web applications.\n\"\"\"",
                "source_code": "class PrefixPathMiddleware:\n        def __init__(self, app, prefix):\n            self.app = app\n            self.prefix = prefix\n\n        def __call__(self, environ, start_response):\n            environ[\"SCRIPT_NAME\"] = self.prefix\n            return self.app(environ, start_response)\n\n    app.wsgi_app = PrefixPathMiddleware(app.wsgi_app, \"/bar\")\n    app.config.update(APPLICATION_ROOT=\"/bar\")\n\n    @app.route(\"/\")\n    def index():\n        flask.session[\"testing\"] = 42\n        return \"Hello World\"\n\n    rv = client.get(\"/\", \"http://example.com:8080/\")\n    assert \"path=/bar\" in rv.headers[\"set-cookie\"].lower()"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_session_using_session_settings",
                "second_doc": "\"\"\"\nTests whether session cookies are set according to custom application session settings.\nThis method verifies that Flask correctly implements session cookie attributes such as domain, path, security flags, and SameSite policy as configured. By emulating a client request and inspecting response headers, it ensures that user sessions will behave and be protected as intended under various deployment environments.\n\nArgs:\n    app: The Flask application instance with session-related configuration.\n    client: The test client used to simulate HTTP requests to the application.\n\nReturns:\n    None. Assertions are used to validate behavior; failures will raise exceptions.\n\"\"\"",
                "source_code": "app.config.update(\n        SERVER_NAME=\"www.example.com:8080\",\n        APPLICATION_ROOT=\"/test\",\n        SESSION_COOKIE_DOMAIN=\".example.com\",\n        SESSION_COOKIE_HTTPONLY=False,\n        SESSION_COOKIE_SECURE=True,\n        SESSION_COOKIE_SAMESITE=\"Lax\",\n        SESSION_COOKIE_PATH=\"/\",\n    )\n\n    @app.route(\"/\")\n    def index():\n        flask.session[\"testing\"] = 42\n        return \"Hello World\"\n\n    rv = client.get(\"/\", \"http://www.example.com:8080/test/\")\n    cookie = rv.headers[\"set-cookie\"].lower()\n    assert \"domain=.example.com\" in cookie\n    assert \"path=/\" in cookie\n    assert \"secure\" in cookie\n    assert \"httponly\" not in cookie\n    assert \"samesite\" in cookie"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_session_using_samesite_attribute",
                "second_doc": "\"\"\"\nTests the handling of different values for the session cookie's SameSite attribute and verifies that invalid configurations raise an error while valid ones correctly configure the cookie. This ensures session cookies behave as expected based on security and browser compatibility requirements.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "@app.route(\"/\")\n    def index():\n        flask.session[\"testing\"] = 42\n        return \"Hello World\"\n\n    app.config.update(SESSION_COOKIE_SAMESITE=\"invalid\")\n\n    with pytest.raises(ValueError):\n        client.get(\"/\")\n\n    app.config.update(SESSION_COOKIE_SAMESITE=None)\n    rv = client.get(\"/\")\n    cookie = rv.headers[\"set-cookie\"].lower()\n    assert \"samesite\" not in cookie\n\n    app.config.update(SESSION_COOKIE_SAMESITE=\"Strict\")\n    rv = client.get(\"/\")\n    cookie = rv.headers[\"set-cookie\"].lower()\n    assert \"samesite=strict\" in cookie\n\n    app.config.update(SESSION_COOKIE_SAMESITE=\"Lax\")\n    rv = client.get(\"/\")\n    cookie = rv.headers[\"set-cookie\"].lower()\n    assert \"samesite=lax\" in cookie"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_session_localhost_warning",
                "second_doc": "\"\"\"\nTests that when the application is configured with a server name set to \"localhost\", Flask correctly issues a warning regarding the validity of the cookie domain and ensures the session cookie does not include an explicit domain attribute.\n\nArgs:\n    None\n\nReturns:\n    None\n\nThis method verifies that session management is handled securely and according to web standards, helping to prevent invalid cookies from being set when using local development domains.\n\"\"\"",
                "source_code": "app.config.update(SERVER_NAME=\"localhost:5000\")\n\n    @app.route(\"/\")\n    def index():\n        flask.session[\"testing\"] = 42\n        return \"testing\"\n\n    rv = client.get(\"/\", \"http://localhost:5000/\")\n    assert \"domain\" not in rv.headers[\"set-cookie\"].lower()\n    w = recwarn.pop(UserWarning)\n    assert \"'localhost' is not a valid cookie domain\" in str(w.message)"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_session_ip_warning",
                "second_doc": "\"\"\"\nTests that a warning is issued when the session cookie domain is an IP address rather than a hostname. \nThis ensures users are alerted to potential security or deployment issues caused by setting cookies on IP domains.\n\nArgs:\n    None\n\nReturns:\n    None\n\nRaises:\n    AssertionError: If the cookie domain is not set to the IP address or if the expected warning is not issued.\n\"\"\"",
                "source_code": "app.config.update(SERVER_NAME=\"127.0.0.1:5000\")\n\n    @app.route(\"/\")\n    def index():\n        flask.session[\"testing\"] = 42\n        return \"testing\"\n\n    rv = client.get(\"/\", \"http://127.0.0.1:5000/\")\n    assert \"domain=127.0.0.1\" in rv.headers[\"set-cookie\"].lower()\n    w = recwarn.pop(UserWarning)\n    assert \"cookie domain is an IP\" in str(w.message)"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_missing_session",
                "second_doc": "\"\"\"\nTests the behavior of Flask's session handling when the secret key is not set, ensuring that operations requiring secure sessions raise appropriate errors.\n\nArgs:\n    None\n\nReturns:\n    None\n\nWhy:\n    This test verifies that session operations dependent on a secret key for security correctly fail when the configuration is incomplete, helping to maintain safe application defaults and preventing insecure session management.\n\"\"\"",
                "source_code": "app.secret_key = None\n\n    def expect_exception(f, *args, **kwargs):\n        e = pytest.raises(RuntimeError, f, *args, **kwargs)\n        assert e.value.args and \"session is unavailable\" in e.value.args[0]\n\n    with app.test_request_context():\n        assert flask.session.get(\"missing_key\") is None\n        expect_exception(flask.session.__setitem__, \"foo\", 42)\n        expect_exception(flask.session.pop, \"foo\")"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_session_expiration",
                "second_doc": "\"\"\"\nTests the session expiration mechanism by verifying whether the session cookie is issued with or without an expiration date based on the session's permanence.\n\nBy simulating client requests, this method ensures that the session's configuration results in expected cookie behavior. This supports correctness in how session persistence is handled, which is critical for managing user state across requests.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "permanent = True\n\n    @app.route(\"/\")\n    def index():\n        flask.session[\"test\"] = 42\n        flask.session.permanent = permanent\n        return \"\"\n\n    @app.route(\"/test\")\n    def test():\n        return str(flask.session.permanent)\n\n    rv = client.get(\"/\")\n    assert \"set-cookie\" in rv.headers\n    match = re.search(r\"(?i)\\bexpires=([^;]+)\", rv.headers[\"set-cookie\"])\n    expires = parse_date(match.group())\n    expected = datetime.utcnow() + app.permanent_session_lifetime\n    assert expires.year == expected.year\n    assert expires.month == expected.month\n    assert expires.day == expected.day\n\n    rv = client.get(\"/test\")\n    assert rv.data == b\"True\"\n\n    permanent = False\n    rv = client.get(\"/\")\n    assert \"set-cookie\" in rv.headers\n    match = re.search(r\"\\bexpires=([^;]+)\", rv.headers[\"set-cookie\"])\n    assert match is None"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_session_stored_last",
                "second_doc": "\"\"\"\nTests that session data is correctly modified after a response is processed and is subsequently available in future requests.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "@app.after_request\n    def modify_session(response):\n        flask.session[\"foo\"] = 42\n        return response\n\n    @app.route(\"/\")\n    def dump_session_contents():\n        return repr(flask.session.get(\"foo\"))\n\n    assert client.get(\"/\").data == b\"None\"\n    assert client.get(\"/\").data == b\"42\""
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_session_special_types",
                "second_doc": "\"\"\"\nTests how various data types, including those with special serialization needs, are stored in and retrieved from the session. This ensures that session handling supports complex and binary-safe data storage for robust application state management.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "now = datetime.utcnow().replace(microsecond=0)\n    the_uuid = uuid.uuid4()\n\n    @app.route(\"/\")\n    def dump_session_contents():\n        flask.session[\"t\"] = (1, 2, 3)\n        flask.session[\"b\"] = b\"\\xff\"\n        flask.session[\"m\"] = flask.Markup(\"<html>\")\n        flask.session[\"u\"] = the_uuid\n        flask.session[\"d\"] = now\n        flask.session[\"t_tag\"] = {\" t\": \"not-a-tuple\"}\n        flask.session[\"di_t_tag\"] = {\" t__\": \"not-a-tuple\"}\n        flask.session[\"di_tag\"] = {\" di\": \"not-a-dict\"}\n        return \"\", 204\n\n    with client:\n        client.get(\"/\")\n        s = flask.session\n        assert s[\"t\"] == (1, 2, 3)\n        assert type(s[\"b\"]) == bytes\n        assert s[\"b\"] == b\"\\xff\"\n        assert type(s[\"m\"]) == flask.Markup\n        assert s[\"m\"] == flask.Markup(\"<html>\")\n        assert s[\"u\"] == the_uuid\n        assert s[\"d\"] == now\n        assert s[\"t_tag\"] == {\" t\": \"not-a-tuple\"}\n        assert s[\"di_t_tag\"] == {\" t__\": \"not-a-tuple\"}\n        assert s[\"di_tag\"] == {\" di\": \"not-a-dict\"}"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_session_cookie_setting",
                "second_doc": "\"\"\"\nTests whether the session cookie is set or omitted depending on the session's permanence and the application's session refresh configuration.\n\nArgs:\n    None directly. Relies on global variables and application configuration.\n\nReturns:\n    None. Asserts are used to validate the expected session cookie behavior in various configuration scenarios.\n    \nWhy:\n    This verifies the correct management of session cookies in response to configuration and session state, ensuring predictable and secure behavior in client-server interactions.\n\"\"\"",
                "source_code": "is_permanent = True\n\n    @app.route(\"/bump\")\n    def bump():\n        rv = flask.session[\"foo\"] = flask.session.get(\"foo\", 0) + 1\n        flask.session.permanent = is_permanent\n        return str(rv)\n\n    @app.route(\"/read\")\n    def read():\n        return str(flask.session.get(\"foo\", 0))\n\n    def run_test(expect_header):\n        with app.test_client() as c:\n            assert c.get(\"/bump\").data == b\"1\"\n            assert c.get(\"/bump\").data == b\"2\"\n            assert c.get(\"/bump\").data == b\"3\"\n\n            rv = c.get(\"/read\")\n            set_cookie = rv.headers.get(\"set-cookie\")\n            assert (set_cookie is not None) == expect_header\n            assert rv.data == b\"3\"\n\n    is_permanent = True\n    app.config[\"SESSION_REFRESH_EACH_REQUEST\"] = True\n    run_test(expect_header=True)\n\n    is_permanent = True\n    app.config[\"SESSION_REFRESH_EACH_REQUEST\"] = False\n    run_test(expect_header=False)\n\n    is_permanent = False\n    app.config[\"SESSION_REFRESH_EACH_REQUEST\"] = True\n    run_test(expect_header=False)\n\n    is_permanent = False\n    app.config[\"SESSION_REFRESH_EACH_REQUEST\"] = False\n    run_test(expect_header=False)"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_session_vary_cookie",
                "second_doc": "\"\"\"\nTests that session-setting routes correctly manage the 'Vary' header in HTTP responses, ensuring client-side caches behave as expected when session data is used. \n\nThis helps guarantee that appropriate cache control is maintained whenever session information influences the response, preventing incorrect sharing of cached responses between different users.\n\nArgs:\n    None\n\nReturns:\n    None. Asserts are used to validate expected behavior.\n\"\"\"",
                "source_code": "@app.route(\"/set\")\n    def set_session():\n        flask.session[\"test\"] = \"test\"\n        return \"\"\n\n    @app.route(\"/get\")\n    def get():\n        return flask.session.get(\"test\")\n\n    @app.route(\"/getitem\")\n    def getitem():\n        return flask.session[\"test\"]\n\n    @app.route(\"/setdefault\")\n    def setdefault():\n        return flask.session.setdefault(\"test\", \"default\")\n\n    @app.route(\"/vary-cookie-header-set\")\n    def vary_cookie_header_set():\n        response = flask.Response()\n        response.vary.add(\"Cookie\")\n        flask.session[\"test\"] = \"test\"\n        return response\n\n    @app.route(\"/vary-header-set\")\n    def vary_header_set():\n        response = flask.Response()\n        response.vary.update((\"Accept-Encoding\", \"Accept-Language\"))\n        flask.session[\"test\"] = \"test\"\n        return response\n\n    @app.route(\"/no-vary-header\")\n    def no_vary_header():\n        return \"\"\n\n    def expect(path, header_value=\"Cookie\"):\n        rv = client.get(path)\n\n        if header_value:\n            # The 'Vary' key should exist in the headers only once.\n            assert len(rv.headers.get_all(\"Vary\")) == 1\n            assert rv.headers[\"Vary\"] == header_value\n        else:\n            assert \"Vary\" not in rv.headers\n\n    expect(\"/set\")\n    expect(\"/get\")\n    expect(\"/getitem\")\n    expect(\"/setdefault\")\n    expect(\"/vary-cookie-header-set\")\n    expect(\"/vary-header-set\", \"Accept-Encoding, Accept-Language, Cookie\")\n    expect(\"/no-vary-header\", None)"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_flashes",
                "second_doc": "\"\"\"\nTests that flashing messages correctly modifies the session and that all flashed messages are retrieved in order.\n\nThis method ensures that when messages are flashed in the application's session, the session state is appropriately marked as modified and all messages can be accessed as expected.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "assert not flask.session.modified\n    flask.flash(\"Zap\")\n    flask.session.modified = False\n    flask.flash(\"Zip\")\n    assert flask.session.modified\n    assert list(flask.get_flashed_messages()) == [\"Zap\", \"Zip\"]"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_extended_flashing",
                "second_doc": "\"\"\"\nTests the functionality of message flashing in various forms, including message categories, filtering, and markup handling, to verify that the application's messaging system reliably delivers feedback to users in different scenarios.\n\nArgs:\n    None\n\nReturns:\n    None\n\nWhy:\n    To ensure the application provides accurate and flexible temporary feedback messages to users, supporting features like multiple categories, filtering, and rich formatting, thereby improving the user experience and reliability of notification systems.\n\"\"\"",
                "source_code": "@app.route(\"/\")\n    def index():\n        flask.flash(\"Hello World\")\n        flask.flash(\"Hello World\", \"error\")\n        flask.flash(flask.Markup(\"<em>Testing</em>\"), \"warning\")\n        return \"\"\n\n    @app.route(\"/test/\")\n    def test():\n        messages = flask.get_flashed_messages()\n        assert list(messages) == [\n            \"Hello World\",\n            \"Hello World\",\n            flask.Markup(\"<em>Testing</em>\"),\n        ]\n        return \"\"\n\n    @app.route(\"/test_with_categories/\")\n    def test_with_categories():\n        messages = flask.get_flashed_messages(with_categories=True)\n        assert len(messages) == 3\n        assert list(messages) == [\n            (\"message\", \"Hello World\"),\n            (\"error\", \"Hello World\"),\n            (\"warning\", flask.Markup(\"<em>Testing</em>\")),\n        ]\n        return \"\"\n\n    @app.route(\"/test_filter/\")\n    def test_filter():\n        messages = flask.get_flashed_messages(\n            category_filter=[\"message\"], with_categories=True\n        )\n        assert list(messages) == [(\"message\", \"Hello World\")]\n        return \"\"\n\n    @app.route(\"/test_filters/\")\n    def test_filters():\n        messages = flask.get_flashed_messages(\n            category_filter=[\"message\", \"warning\"], with_categories=True\n        )\n        assert list(messages) == [\n            (\"message\", \"Hello World\"),\n            (\"warning\", flask.Markup(\"<em>Testing</em>\")),\n        ]\n        return \"\"\n\n    @app.route(\"/test_filters_without_returning_categories/\")\n    def test_filters2():\n        messages = flask.get_flashed_messages(category_filter=[\"message\", \"warning\"])\n        assert len(messages) == 2\n        assert messages[0] == \"Hello World\"\n        assert messages[1] == flask.Markup(\"<em>Testing</em>\")\n        return \"\"\n\n    # Create new test client on each test to clean flashed messages.\n\n    client = app.test_client()\n    client.get(\"/\")\n    client.get(\"/test_with_categories/\")\n\n    client = app.test_client()\n    client.get(\"/\")\n    client.get(\"/test_filter/\")\n\n    client = app.test_client()\n    client.get(\"/\")\n    client.get(\"/test_filters/\")\n\n    client = app.test_client()\n    client.get(\"/\")\n    client.get(\"/test_filters_without_returning_categories/\")"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_request_processing",
                "second_doc": "\"\"\"\nTests the correct execution order and modification of HTTP request and response lifecycle hooks.\n\nThis method verifies that the 'before_request' and 'after_request' functions are invoked at the appropriate stages of processing a client request, and that changes applied in these hooks\u2014such as tracking execution and appending data to the response\u2014take effect as expected.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "evts = []\n\n    @app.before_request\n    def before_request():\n        evts.append(\"before\")\n\n    @app.after_request\n    def after_request(response):\n        response.data += b\"|after\"\n        evts.append(\"after\")\n        return response\n\n    @app.route(\"/\")\n    def index():\n        assert \"before\" in evts\n        assert \"after\" not in evts\n        return \"request\"\n\n    assert \"after\" not in evts\n    rv = client.get(\"/\").data\n    assert \"after\" in evts\n    assert rv == b\"request|after\""
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_request_preprocessing_early_return",
                "second_doc": "\"\"\"\nTests that the request preprocessing flow in the framework stops executing further before_request handlers once a non-None response is returned, ensuring early exit from the handler chain as intended.\n\nArgs:\n    None\n\nReturns:\n    None\n\nWhy:\n    This method verifies the framework's mechanism for managing short-circuiting during the request lifecycle, ensuring that once a response is generated in a pre-processing hook, subsequent hooks and the main route handler are not called.\n\"\"\"",
                "source_code": "evts = []\n\n    @app.before_request\n    def before_request1():\n        evts.append(1)\n\n    @app.before_request\n    def before_request2():\n        evts.append(2)\n        return \"hello\"\n\n    @app.before_request\n    def before_request3():\n        evts.append(3)\n        return \"bye\"\n\n    @app.route(\"/\")\n    def index():\n        evts.append(\"index\")\n        return \"damnit\"\n\n    rv = client.get(\"/\").data.strip()\n    assert rv == b\"hello\"\n    assert evts == [1, 2]"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_after_request_processing",
                "second_doc": "\"\"\"\nTests that a function registered with flask.after_this_request can modify the response headers during request processing.\n\nArgs:\n    None\n\nReturns:\n    None\n\nWhy:\n    Ensures that response post-processing hooks can effectively alter HTTP response properties before they are sent to the client, verifying the framework's support for flexible response customization.\n\"\"\"",
                "source_code": "@app.route(\"/\")\n    def index():\n        @flask.after_this_request\n        def foo(response):\n            response.headers[\"X-Foo\"] = \"a header\"\n            return response\n\n        return \"Test\"\n\n    resp = client.get(\"/\")\n    assert resp.status_code == 200\n    assert resp.headers[\"X-Foo\"] == \"a header\""
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_teardown_request_handler",
                "second_doc": "\"\"\"\nTests that the teardown request handler is executed after processing a request and can perform necessary cleanup or post-processing actions.\n\nArgs:\n    None\n\nReturns:\n    None\n\nWhy:\n    This ensures that resources tied to the request lifecycle are appropriately handled after a response is sent, allowing for cleanup or logging regardless of the request outcome.\n\"\"\"",
                "source_code": "called = []\n\n    @app.teardown_request\n    def teardown_request(exc):\n        called.append(True)\n        return \"Ignored\"\n\n    @app.route(\"/\")\n    def root():\n        return \"Response\"\n\n    rv = client.get(\"/\")\n    assert rv.status_code == 200\n    assert b\"Response\" in rv.data\n    assert len(called) == 1"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_teardown_request_handler_debug_mode",
                "second_doc": "\"\"\"\nTests that the teardown request handler is invoked after processing a request, capturing any necessary post-request cleanup or state changes, even in debug mode.\n\nArgs:\n    None\n\nReturns:\n    None\n\nWhy:\n    Ensuring the teardown process runs correctly after a request helps maintain consistency and resource management in the web application's lifecycle.\n\"\"\"",
                "source_code": "called = []\n\n    @app.teardown_request\n    def teardown_request(exc):\n        called.append(True)\n        return \"Ignored\"\n\n    @app.route(\"/\")\n    def root():\n        return \"Response\"\n\n    rv = client.get(\"/\")\n    assert rv.status_code == 200\n    assert b\"Response\" in rv.data\n    assert len(called) == 1"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_teardown_request_handler_error",
                "second_doc": "\"\"\"\nTests that multiple teardown_request handlers receive the original exception when a request fails, even if handlers themselves raise and suppress new exceptions.\n\nArgs:\n    None\n\nReturns:\n    None\n\nWhy:\n    Ensures consistent propagation of the original error object to all teardown_request handlers so that post-request cleanup logic can reliably detect the failure context, even if handler code introduces new errors.\n\"\"\"",
                "source_code": "called = []\n    app.testing = False\n\n    @app.teardown_request\n    def teardown_request1(exc):\n        assert type(exc) == ZeroDivisionError\n        called.append(True)\n        # This raises a new error and blows away sys.exc_info(), so we can\n        # test that all teardown_requests get passed the same original\n        # exception.\n        try:\n            raise TypeError()\n        except Exception:\n            pass\n\n    @app.teardown_request\n    def teardown_request2(exc):\n        assert type(exc) == ZeroDivisionError\n        called.append(True)\n        # This raises a new error and blows away sys.exc_info(), so we can\n        # test that all teardown_requests get passed the same original\n        # exception.\n        try:\n            raise TypeError()\n        except Exception:\n            pass\n\n    @app.route(\"/\")\n    def fails():\n        1 // 0\n\n    rv = client.get(\"/\")\n    assert rv.status_code == 500\n    assert b\"Internal Server Error\" in rv.data\n    assert len(called) == 2"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_before_after_request_order",
                "second_doc": "\"\"\"\nVerifies the execution order of before_request, after_request, and teardown_request handlers for a route.\n\nThis test ensures that application request lifecycle hooks are invoked in a predictable sequence, which is necessary for the correct management of resources, setup, or cleanup tasks before, during, and after handling HTTP requests.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "called = []\n\n    @app.before_request\n    def before1():\n        called.append(1)\n\n    @app.before_request\n    def before2():\n        called.append(2)\n\n    @app.after_request\n    def after1(response):\n        called.append(4)\n        return response\n\n    @app.after_request\n    def after2(response):\n        called.append(3)\n        return response\n\n    @app.teardown_request\n    def finish1(exc):\n        called.append(6)\n\n    @app.teardown_request\n    def finish2(exc):\n        called.append(5)\n\n    @app.route(\"/\")\n    def index():\n        return \"42\"\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"42\"\n    assert called == [1, 2, 3, 4, 5, 6]"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_error_handling",
                "second_doc": "\"\"\"\nTests that the application correctly manages different HTTP error scenarios by mapping specific exceptions to custom error handlers and returning appropriate status codes and messages.\n\nThis ensures that users receive meaningful responses and the application is robust against common error conditions encountered during web interactions.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "app.testing = False\n\n    @app.errorhandler(404)\n    def not_found(e):\n        return \"not found\", 404\n\n    @app.errorhandler(500)\n    def internal_server_error(e):\n        return \"internal server error\", 500\n\n    @app.errorhandler(Forbidden)\n    def forbidden(e):\n        return \"forbidden\", 403\n\n    @app.route(\"/\")\n    def index():\n        flask.abort(404)\n\n    @app.route(\"/error\")\n    def error():\n        1 // 0\n\n    @app.route(\"/forbidden\")\n    def error2():\n        flask.abort(403)\n\n    rv = client.get(\"/\")\n    assert rv.status_code == 404\n    assert rv.data == b\"not found\"\n    rv = client.get(\"/error\")\n    assert rv.status_code == 500\n    assert b\"internal server error\" == rv.data\n    rv = client.get(\"/forbidden\")\n    assert rv.status_code == 403\n    assert b\"forbidden\" == rv.data"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_error_handler_unknown_code",
                "second_doc": "\"\"\"\nTests that attempting to register an error handler with an unknown status code raises a KeyError with an appropriate message.\n\nArgs:\n    None\n\nReturns:\n    None\n\nWhy:\n    Ensures the application safeguards against registering error handlers with unrecognized status codes, thereby maintaining predictable error handling behavior.\n\"\"\"",
                "source_code": "with pytest.raises(KeyError) as exc_info:\n        app.register_error_handler(999, lambda e: (\"999\", 999))\n\n    assert \"Use a subclass\" in exc_info.value.args[0]"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_error_handling_processing",
                "second_doc": "\"\"\"\nTests that the response handling mechanism correctly manages errors and custom response processing. By deliberately triggering a server error, this method verifies that error handling and after-request modifications to the response are properly applied.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "app.testing = False\n\n    @app.errorhandler(500)\n    def internal_server_error(e):\n        return \"internal server error\", 500\n\n    @app.route(\"/\")\n    def broken_func():\n        1 // 0\n\n    @app.after_request\n    def after_request(resp):\n        resp.mimetype = \"text/x-special\"\n        return resp\n\n    resp = client.get(\"/\")\n    assert resp.mimetype == \"text/x-special\"\n    assert resp.data == b\"internal server error\""
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_baseexception_error_handling",
                "second_doc": "\"\"\"\nTests whether unhandled exceptions that inherit directly from BaseException (such as KeyboardInterrupt) are preserved correctly within the request context stack. This ensures that the framework can appropriately handle and propagate critical exceptions without interfering with their default behavior.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "app.testing = False\n\n    @app.route(\"/\")\n    def broken_func():\n        raise KeyboardInterrupt()\n\n    with pytest.raises(KeyboardInterrupt):\n        client.get(\"/\")\n\n        ctx = flask._request_ctx_stack.top\n        assert ctx.preserved\n        assert type(ctx._preserved_exc) is KeyboardInterrupt"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_before_request_and_routing_errors",
                "second_doc": "\"\"\"\nTests that data attached to the global request context in a before_request handler remains accessible during error handling, ensuring consistent access to request-specific state even when a routing error occurs.\n\nArgs:\n    None\n\nReturns:\n    None\n\nWhy:\n    This test ensures that Flask's request context properly maintains objects set during request preprocessing, even in the event of an error like a missing route. This behavior is critical for reliably using request-scoped variables throughout the request lifecycle, including within error handlers.\n\"\"\"",
                "source_code": "@app.before_request\n    def attach_something():\n        flask.g.something = \"value\"\n\n    @app.errorhandler(404)\n    def return_something(error):\n        return flask.g.something, 404\n\n    rv = client.get(\"/\")\n    assert rv.status_code == 404\n    assert rv.data == b\"value\""
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_user_error_handling",
                "second_doc": "\"\"\"\nTests that a custom exception raised in a request handler is properly caught and handled by a registered error handler, ensuring that the expected response is returned instead of a server error.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "class MyException(Exception):\n        pass\n\n    @app.errorhandler(MyException)\n    def handle_my_exception(e):\n        assert isinstance(e, MyException)\n        return \"42\"\n\n    @app.route(\"/\")\n    def index():\n        raise MyException()\n\n    assert client.get(\"/\").data == b\"42\""
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_http_error_subclass_handling",
                "second_doc": "\"\"\"\nTests that custom error handlers for exception subclasses and specific HTTP status codes are invoked appropriately, ensuring subclass handlers take precedence over generic status code handlers.\n\nArgs:\n    None\n\nReturns:\n    None\n\nWhy:\n    This method verifies that error handling in the application can distinguish between exception subclasses and base classes or status codes, allowing for precise and predictable error responses in different scenarios.\n\"\"\"",
                "source_code": "class ForbiddenSubclass(Forbidden):\n        pass\n\n    @app.errorhandler(ForbiddenSubclass)\n    def handle_forbidden_subclass(e):\n        assert isinstance(e, ForbiddenSubclass)\n        return \"banana\"\n\n    @app.errorhandler(403)\n    def handle_403(e):\n        assert not isinstance(e, ForbiddenSubclass)\n        assert isinstance(e, Forbidden)\n        return \"apple\"\n\n    @app.route(\"/1\")\n    def index1():\n        raise ForbiddenSubclass()\n\n    @app.route(\"/2\")\n    def index2():\n        flask.abort(403)\n\n    @app.route(\"/3\")\n    def index3():\n        raise Forbidden()\n\n    assert client.get(\"/1\").data == b\"banana\"\n    assert client.get(\"/2\").data == b\"apple\"\n    assert client.get(\"/3\").data == b\"apple\""
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_errorhandler_precedence",
                "second_doc": "\"\"\"\nTests the precedence of registered error handlers for exceptions sharing an inheritance hierarchy.\n\nThis method is verifying which error handler Flask chooses when multiple handlers are eligible for a raised exception due to subclassing. By raising custom exceptions and inspecting the output, it ensures that the framework selects the most specific handler according to its resolution rules.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "class E1(Exception):\n        pass\n\n    class E2(Exception):\n        pass\n\n    class E3(E1, E2):\n        pass\n\n    @app.errorhandler(E2)\n    def handle_e2(e):\n        return \"E2\"\n\n    @app.errorhandler(Exception)\n    def handle_exception(e):\n        return \"Exception\"\n\n    @app.route(\"/E1\")\n    def raise_e1():\n        raise E1\n\n    @app.route(\"/E3\")\n    def raise_e3():\n        raise E3\n\n    rv = client.get(\"/E1\")\n    assert rv.data == b\"Exception\"\n\n    rv = client.get(\"/E3\")\n    assert rv.data == b\"E2\""
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_trapping_of_bad_request_key_errors",
                "second_doc": "\"\"\"\nTests how the application handles missing request form keys and explicit aborts, ensuring consistent error trapping behavior under different configurations.\n\nArgs:\n    None\n\nReturns:\n    None\n\nWhy:\n    Verifies that missing form keys or 400 aborts properly return a Bad Request response or raise appropriate exceptions according to the application\u2019s debug and error trapping settings, contributing to robust error handling in web routes.\n\"\"\"",
                "source_code": "@app.route(\"/key\")\n    def fail():\n        flask.request.form[\"missing_key\"]\n\n    @app.route(\"/abort\")\n    def allow_abort():\n        flask.abort(400)\n\n    rv = client.get(\"/key\")\n    assert rv.status_code == 400\n    assert b\"missing_key\" not in rv.data\n    rv = client.get(\"/abort\")\n    assert rv.status_code == 400\n\n    app.debug = True\n    with pytest.raises(KeyError) as e:\n        client.get(\"/key\")\n    assert e.errisinstance(BadRequest)\n    assert \"missing_key\" in e.value.get_description()\n    rv = client.get(\"/abort\")\n    assert rv.status_code == 400\n\n    app.debug = False\n    app.config[\"TRAP_BAD_REQUEST_ERRORS\"] = True\n    with pytest.raises(KeyError):\n        client.get(\"/key\")\n    with pytest.raises(BadRequest):\n        client.get(\"/abort\")"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_trapping_of_all_http_exceptions",
                "second_doc": "\"\"\"\nTests that enabling the HTTP exception trapping configuration causes Flask to catch and properly propagate HTTP exceptions raised within a route. This ensures that exception handling behavior aligns with the specified configuration when a route intentionally aborts with an error.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "app.config[\"TRAP_HTTP_EXCEPTIONS\"] = True\n\n    @app.route(\"/fail\")\n    def fail():\n        flask.abort(404)\n\n    with pytest.raises(NotFound):\n        client.get(\"/fail\")"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_error_handler_after_processor_error",
                "second_doc": "\"\"\"\nTests that errors occurring in request pre- or post-processing are properly handled by the application's error handler for internal server errors.\n\nThis ensures the application provides consistent error responses even when exceptions arise during various stages of the request lifecycle, improving reliability and user experience.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "app.testing = False\n\n    @app.before_request\n    def before_request():\n        if _trigger == \"before\":\n            1 // 0\n\n    @app.after_request\n    def after_request(response):\n        if _trigger == \"after\":\n            1 // 0\n        return response\n\n    @app.route(\"/\")\n    def index():\n        return \"Foo\"\n\n    @app.errorhandler(500)\n    def internal_server_error(e):\n        return \"Hello Server Error\", 500\n\n    for _trigger in \"before\", \"after\":\n        rv = client.get(\"/\")\n        assert rv.status_code == 500\n        assert rv.data == b\"Hello Server Error\""
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_enctype_debug_helper",
                "second_doc": "\"\"\"\nTests that submitting a file in a POST request without the correct encoding triggers the appropriate debug exception, helping ensure developers receive clear feedback when file uploads fail due to missing or incorrect enctype. \n\nArgs:\n    None\n\nReturns:\n    None\n\nRaises:\n    DebugFilesKeyError: If file data is not transmitted properly in the request.\n\nWhy:\n    This behavior helps developers quickly identify and correct issues with form encoding, supporting smoother debugging and improving application robustness when handling file uploads.\n\"\"\"",
                "source_code": "from flask.debughelpers import DebugFilesKeyError\n\n    app.debug = True\n\n    @app.route(\"/fail\", methods=[\"POST\"])\n    def index():\n        return flask.request.files[\"foo\"].filename\n\n    # with statement is important because we leave an exception on the\n    # stack otherwise and we want to ensure that this is not the case\n    # to not negatively affect other tests.\n    with client:\n        with pytest.raises(DebugFilesKeyError) as e:\n            client.post(\"/fail\", data={\"foo\": \"index.txt\"})\n        assert \"no file contents were transmitted\" in str(e.value)\n        assert \"This was submitted: 'index.txt'\" in str(e.value)"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_response_types",
                "second_doc": "\"\"\"\nTests how different return types from view functions are processed and converted into HTTP responses, ensuring that the framework correctly interprets and handles various response forms such as strings, bytes, tuples, response objects, WSGI callables, and dictionaries.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "@app.route(\"/text\")\n    def from_text():\n        return \"H\u00e4llo W\u00f6rld\"\n\n    @app.route(\"/bytes\")\n    def from_bytes():\n        return \"H\u00e4llo W\u00f6rld\".encode()\n\n    @app.route(\"/full_tuple\")\n    def from_full_tuple():\n        return (\n            \"Meh\",\n            400,\n            {\"X-Foo\": \"Testing\", \"Content-Type\": \"text/plain; charset=utf-8\"},\n        )\n\n    @app.route(\"/text_headers\")\n    def from_text_headers():\n        return \"Hello\", {\"X-Foo\": \"Test\", \"Content-Type\": \"text/plain; charset=utf-8\"}\n\n    @app.route(\"/text_status\")\n    def from_text_status():\n        return \"Hi, status!\", 400\n\n    @app.route(\"/response_headers\")\n    def from_response_headers():\n        return (\n            flask.Response(\"Hello world\", 404, {\"X-Foo\": \"Baz\"}),\n            {\"X-Foo\": \"Bar\", \"X-Bar\": \"Foo\"},\n        )\n\n    @app.route(\"/response_status\")\n    def from_response_status():\n        return app.response_class(\"Hello world\", 400), 500\n\n    @app.route(\"/wsgi\")\n    def from_wsgi():\n        return NotFound()\n\n    @app.route(\"/dict\")\n    def from_dict():\n        return {\"foo\": \"bar\"}, 201\n\n    assert client.get(\"/text\").data == \"H\u00e4llo W\u00f6rld\".encode()\n    assert client.get(\"/bytes\").data == \"H\u00e4llo W\u00f6rld\".encode()\n\n    rv = client.get(\"/full_tuple\")\n    assert rv.data == b\"Meh\"\n    assert rv.headers[\"X-Foo\"] == \"Testing\"\n    assert rv.status_code == 400\n    assert rv.mimetype == \"text/plain\"\n\n    rv = client.get(\"/text_headers\")\n    assert rv.data == b\"Hello\"\n    assert rv.headers[\"X-Foo\"] == \"Test\"\n    assert rv.status_code == 200\n    assert rv.mimetype == \"text/plain\"\n\n    rv = client.get(\"/text_status\")\n    assert rv.data == b\"Hi, status!\"\n    assert rv.status_code == 400\n    assert rv.mimetype == \"text/html\"\n\n    rv = client.get(\"/response_headers\")\n    assert rv.data == b\"Hello world\"\n    assert rv.headers.getlist(\"X-Foo\") == [\"Baz\", \"Bar\"]\n    assert rv.headers[\"X-Bar\"] == \"Foo\"\n    assert rv.status_code == 404\n\n    rv = client.get(\"/response_status\")\n    assert rv.data == b\"Hello world\"\n    assert rv.status_code == 500\n\n    rv = client.get(\"/wsgi\")\n    assert b\"Not Found\" in rv.data\n    assert rv.status_code == 404\n\n    rv = client.get(\"/dict\")\n    assert rv.json == {\"foo\": \"bar\"}\n    assert rv.status_code == 201"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_response_type_errors",
                "second_doc": "\"\"\"\nTests that endpoints returning invalid or improperly structured response values correctly raise TypeError exceptions, ensuring the framework handles and reports unsupported or malformed response types as errors.\n\nArgs:\n    None\n\nReturns:\n    None\n\nWhy:\n    This method verifies that the framework enforces response type requirements for route handlers, providing clear errors when user code fails to return a valid response format. This is important to prevent silent failures and to promote correct web application behavior.\n\"\"\"",
                "source_code": "app = flask.Flask(__name__)\n    app.testing = True\n\n    @app.route(\"/none\")\n    def from_none():\n        pass\n\n    @app.route(\"/small_tuple\")\n    def from_small_tuple():\n        return (\"Hello\",)\n\n    @app.route(\"/large_tuple\")\n    def from_large_tuple():\n        return \"Hello\", 234, {\"X-Foo\": \"Bar\"}, \"???\"\n\n    @app.route(\"/bad_type\")\n    def from_bad_type():\n        return True\n\n    @app.route(\"/bad_wsgi\")\n    def from_bad_wsgi():\n        return lambda: None\n\n    c = app.test_client()\n\n    with pytest.raises(TypeError) as e:\n        c.get(\"/none\")\n        assert \"returned None\" in str(e.value)\n        assert \"from_none\" in str(e.value)\n\n    with pytest.raises(TypeError) as e:\n        c.get(\"/small_tuple\")\n        assert \"tuple must have the form\" in str(e.value)\n\n    pytest.raises(TypeError, c.get, \"/large_tuple\")\n\n    with pytest.raises(TypeError) as e:\n        c.get(\"/bad_type\")\n        assert \"it was a bool\" in str(e.value)\n\n    pytest.raises(TypeError, c.get, \"/bad_wsgi\")"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_make_response",
                "second_doc": "\"\"\"\nTests the behavior of the response creation utility by verifying default and explicit status codes, body data, and MIME types in returned response objects.\n\nThis method ensures that responses are constructed correctly for different inputs, which is critical for predictable communication between client and server.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "rv = flask.make_response()\n    assert rv.status_code == 200\n    assert rv.data == b\"\"\n    assert rv.mimetype == \"text/html\"\n\n    rv = flask.make_response(\"Awesome\")\n    assert rv.status_code == 200\n    assert rv.data == b\"Awesome\"\n    assert rv.mimetype == \"text/html\"\n\n    rv = flask.make_response(\"W00t\", 404)\n    assert rv.status_code == 404\n    assert rv.data == b\"W00t\"\n    assert rv.mimetype == \"text/html\""
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_make_response_with_response_instance",
                "second_doc": "\"\"\"\nTest that make_response correctly handles various response instances, status codes, and headers to ensure accurate HTTP responses are generated.\n\nThis method verifies that different types of response objects and header manipulations are handled as expected, supporting reliable web application behavior and customization.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "rv = flask.make_response(flask.jsonify({\"msg\": \"W00t\"}), 400)\n    assert rv.status_code == 400\n    assert rv.data == b'{\"msg\":\"W00t\"}\\n'\n    assert rv.mimetype == \"application/json\"\n\n    rv = flask.make_response(flask.Response(\"\"), 400)\n    assert rv.status_code == 400\n    assert rv.data == b\"\"\n    assert rv.mimetype == \"text/html\"\n\n    rv = flask.make_response(\n        flask.Response(\"\", headers={\"Content-Type\": \"text/html\"}),\n        400,\n        [(\"X-Foo\", \"bar\")],\n    )\n    assert rv.status_code == 400\n    assert rv.headers[\"Content-Type\"] == \"text/html\"\n    assert rv.headers[\"X-Foo\"] == \"bar\""
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_jsonify_no_prettyprint",
                "second_doc": "\"\"\"\nTests that disabling pretty-printing in JSON responses produces the expected compact JSON output.\n\nThis ensures that the application's configuration for JSON formatting is respected during response creation, leading to consistent data serialization across different settings.\n\nArgs:\n    None\n\nReturns:\n    None\n\nAsserts:\n    The response data is exactly equal to the expected compact JSON bytes.\n\"\"\"",
                "source_code": "app.config.update({\"JSONIFY_PRETTYPRINT_REGULAR\": False})\n    compressed_msg = b'{\"msg\":{\"submsg\":\"W00t\"},\"msg2\":\"foobar\"}\\n'\n    uncompressed_msg = {\"msg\": {\"submsg\": \"W00t\"}, \"msg2\": \"foobar\"}\n\n    rv = flask.make_response(flask.jsonify(uncompressed_msg), 200)\n    assert rv.data == compressed_msg"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_jsonify_prettyprint",
                "second_doc": "\"\"\"\nTests that JSON responses are formatted with pretty-printing when the corresponding configuration is enabled, ensuring output readability and correct configuration handling.\n\nArgs:\n    None\n\nReturns:\n    None\n\nWhy:\n    This ensures that the application formats its JSON responses as expected based on configuration, supporting consistency and ease of debugging for developers or consumers expecting human-readable output.\n\"\"\"",
                "source_code": "app.config.update({\"JSONIFY_PRETTYPRINT_REGULAR\": True})\n    compressed_msg = {\"msg\": {\"submsg\": \"W00t\"}, \"msg2\": \"foobar\"}\n    pretty_response = (\n        b'{\\n  \"msg\": {\\n    \"submsg\": \"W00t\"\\n  }, \\n  \"msg2\": \"foobar\"\\n}\\n'\n    )\n\n    rv = flask.make_response(flask.jsonify(compressed_msg), 200)\n    assert rv.data == pretty_response"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_jsonify_mimetype",
                "second_doc": "\"\"\"\nTests that modifying the application's configuration for the JSON response mimetype correctly updates the mimetype used in a JSON response. This ensures responses adhere to customized content type requirements.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "app.config.update({\"JSONIFY_MIMETYPE\": \"application/vnd.api+json\"})\n    msg = {\"msg\": {\"submsg\": \"W00t\"}}\n    rv = flask.make_response(flask.jsonify(msg), 200)\n    assert rv.mimetype == \"application/vnd.api+json\""
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_json_dump_dataclass",
                "second_doc": "\"\"\"\nTests whether dataclass instances can be correctly serialized and deserialized to and from JSON using Flask's JSON utilities. This ensures that objects created with Python's dataclass system are compatible with Flask's JSON handling.\n\nArgs:\n    None\n\nReturns:\n    None. Asserts that a dataclass instance round-trips through JSON serialization and deserialization as expected.\n\"\"\"",
                "source_code": "from dataclasses import make_dataclass\n\n    Data = make_dataclass(\"Data\", [(\"name\", str)])\n    value = flask.json.dumps(Data(\"Flask\"), app=app)\n    value = flask.json.loads(value, app=app)\n    assert value == {\"name\": \"Flask\"}"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_jsonify_args_and_kwargs_check",
                "second_doc": "\"\"\"\nTests that calling flask.jsonify with both positional and keyword arguments raises a TypeError indicating undefined behavior.\n\nArgs:\n    None\n\nReturns:\n    None\n\nThis test ensures that improper usage of the jsonify function, which could lead to ambiguous or erroneous response generation, is explicitly prevented by the framework.\n\"\"\"",
                "source_code": "with pytest.raises(TypeError) as e:\n        flask.jsonify(\"fake args\", kwargs=\"fake\")\n    assert \"behavior undefined\" in str(e.value)"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_url_generation",
                "second_doc": "\"\"\"\nTests that URLs are generated correctly for a given route, ensuring proper encoding of dynamic path parameters and correct formation of external URLs.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "@app.route(\"/hello/<name>\", methods=[\"POST\"])\n    def hello():\n        pass\n\n    assert flask.url_for(\"hello\", name=\"test x\") == \"/hello/test%20x\"\n    assert (\n        flask.url_for(\"hello\", name=\"test x\", _external=True)\n        == \"http://localhost/hello/test%20x\"\n    )"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_build_error_handler",
                "second_doc": "\"\"\"\nTests how the application handles errors during URL building, ensuring that default and custom error handlers are invoked appropriately and that exceptions are managed as expected.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "with app.test_request_context():\n        pytest.raises(BuildError, flask.url_for, \"spam\")\n\n    # Verify the error is re-raised if not the current exception.\n    try:\n        with app.test_request_context():\n            flask.url_for(\"spam\")\n    except BuildError as err:\n        error = err\n    try:\n        raise RuntimeError(\"Test case where BuildError is not current.\")\n    except RuntimeError:\n        pytest.raises(BuildError, app.handle_url_build_error, error, \"spam\", {})\n\n    # Test a custom handler.\n    def handler(error, endpoint, values):\n        # Just a test.\n        return \"/test_handler/\"\n\n    app.url_build_error_handlers.append(handler)\n    with app.test_request_context():\n        assert flask.url_for(\"spam\") == \"/test_handler/\""
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_build_error_handler_reraise",
                "second_doc": "\"\"\"\nTests that a custom URL build error handler properly propagates exceptions raised during URL generation.\n\nThis ensures the application's error handling mechanism does not inadvertently suppress or mask underlying build errors, which is important for reliable error reporting and debugging.\n\nArgs:\n    None\n\nReturns:\n    None; assertions are performed to verify that the BuildError exception is raised as expected during URL generation.\n\"\"\"",
                "source_code": "def handler_raises_build_error(error, endpoint, values):\n        raise error\n\n    app.url_build_error_handlers.append(handler_raises_build_error)\n\n    with app.test_request_context():\n        pytest.raises(BuildError, flask.url_for, \"not.existing\")"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_url_for_passes_special_values_to_build_error_handler",
                "second_doc": "\"\"\"\nTests that special reserved keyword arguments are passed to a URL build error handler when URL building fails. This ensures the error handler receives all context necessary for processing errors during URL construction.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "@app.url_build_error_handlers.append\n    def handler(error, endpoint, values):\n        assert values == {\n            \"_external\": False,\n            \"_anchor\": None,\n            \"_method\": None,\n            \"_scheme\": None,\n        }\n        return \"handled\"\n\n    with app.test_request_context():\n        flask.url_for(\"/\")"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_static_files",
                "second_doc": "\"\"\"\nTests the ability of the application to correctly serve static files and generate appropriate URLs for them.\n\nArgs:\n    None\n\nReturns:\n    None\n\nWhy:\n    Verifying static file serving and URL generation is essential to ensure users can access assets like HTML, CSS, and JavaScript correctly, which is critical for overall application functionality and user experience.\n\"\"\"",
                "source_code": "rv = client.get(\"/static/index.html\")\n    assert rv.status_code == 200\n    assert rv.data.strip() == b\"<h1>Hello World!</h1>\"\n    with app.test_request_context():\n        assert flask.url_for(\"static\", filename=\"index.html\") == \"/static/index.html\"\n    rv.close()"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_static_url_path",
                "second_doc": "\"\"\"\nTests that changing the static file URL path in the application configuration works as expected, ensuring correct routing and accessibility of static resources.\n\nArgs:\n    None\n\nReturns:\n    None\n\nWhy:\n    Verifying that the static URL path configuration operates correctly is essential to ensure that static assets are properly served and accessible at custom paths, and that URL generation reflects these changes in the application context.\n\"\"\"",
                "source_code": "app = flask.Flask(__name__, static_url_path=\"/foo\")\n    app.testing = True\n    rv = app.test_client().get(\"/foo/index.html\")\n    assert rv.status_code == 200\n    rv.close()\n\n    with app.test_request_context():\n        assert flask.url_for(\"static\", filename=\"index.html\") == \"/foo/index.html\""
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_static_url_path_with_ending_slash",
                "second_doc": "\"\"\"\nTests that the application correctly handles requests to static files when the static URL path ends with a slash, ensuring proper serving and URL generation for static content.\n\nArgs:\n    None\n\nReturns:\n    None\n\nWhy:\n    This method verifies that static file serving and URL building logic function as intended when the static file route is given a trailing slash, promoting consistency and reliability in static asset management and URL construction within the application.\n\"\"\"",
                "source_code": "app = flask.Flask(__name__, static_url_path=\"/foo/\")\n    app.testing = True\n    rv = app.test_client().get(\"/foo/index.html\")\n    assert rv.status_code == 200\n    rv.close()\n\n    with app.test_request_context():\n        assert flask.url_for(\"static\", filename=\"index.html\") == \"/foo/index.html\""
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_static_url_empty_path",
                "second_doc": "\"\"\"\nTests that the application correctly serves static files when both the static folder and static URL path are set to empty strings. This ensures that the static file delivery behavior functions as intended even with non-standard configuration, which is crucial for predictable resource access in web applications.\n\nArgs:\n    None\n\nReturns:\n    None; asserts that the HTTP response status code is 200, indicating successful file serving.\n\"\"\"",
                "source_code": "app = flask.Flask(__name__, static_folder=\"\", static_url_path=\"\")\n    rv = app.test_client().open(\"/static/index.html\", method=\"GET\")\n    assert rv.status_code == 200\n    rv.close()"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_static_url_empty_path_default",
                "second_doc": "\"\"\"\nTests whether a Flask application with an empty string as the static folder serves a file from the /static URL as expected.\n\nArgs:\n    None\n\nReturns:\n    None\n\nWhy:\n    This test verifies that the application correctly handles static file serving even when the static folder path is explicitly set to an empty string, ensuring that the framework's handling of static assets and default URL routing behaves as intended in edge cases.\n\"\"\"",
                "source_code": "app = flask.Flask(__name__, static_folder=\"\")\n    rv = app.test_client().open(\"/static/index.html\", method=\"GET\")\n    assert rv.status_code == 200\n    rv.close()"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_static_folder_with_ending_slash",
                "second_doc": "\"\"\"\nTests that the application functions correctly when the static folder is defined with a trailing slash, ensuring custom routes still handle requests as expected.\n\nArgs:\n    None\n\nReturns:\n    None\n\nWhy:\n    This method verifies that specifying a static folder path with a trailing slash does not interfere with route resolution for dynamic endpoints, which is important for maintaining consistent and predictable URL handling behavior in the application.\n\"\"\"",
                "source_code": "app = flask.Flask(__name__, static_folder=\"static/\")\n\n    @app.route(\"/<path:path>\")\n    def catch_all(path):\n        return path\n\n    rv = app.test_client().get(\"/catch/all\")\n    assert rv.data == b\"catch/all\""
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_static_route_with_host_matching",
                "second_doc": "\"\"\"\nTest the configuration and behavior of static file routing with host matching enabled in a web application.\n\nThis method verifies that static file routes are correctly generated and resolved when a specific host is set. It ensures proper error handling when required configuration options are omitted, and validates that the application's URL generation for static files respects host constraints. This is done to guarantee that routing mechanisms enforce host-awareness for file serving, thus supporting advanced deployment and routing scenarios.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "app = flask.Flask(__name__, host_matching=True, static_host=\"example.com\")\n    c = app.test_client()\n    rv = c.get(\"http://example.com/static/index.html\")\n    assert rv.status_code == 200\n    rv.close()\n    with app.test_request_context():\n        rv = flask.url_for(\"static\", filename=\"index.html\", _external=True)\n        assert rv == \"http://example.com/static/index.html\"\n    # Providing static_host without host_matching=True should error.\n    with pytest.raises(Exception):\n        flask.Flask(__name__, static_host=\"example.com\")\n    # Providing host_matching=True with static_folder\n    # but without static_host should error.\n    with pytest.raises(Exception):\n        flask.Flask(__name__, host_matching=True)\n    # Providing host_matching=True without static_host\n    # but with static_folder=None should not error.\n    flask.Flask(__name__, host_matching=True, static_folder=None)"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_request_locals",
                "second_doc": "\"\"\"\nTests the initial state of the request-specific context object within the application, verifying that it starts out unbound and evaluates to False when accessed outside of an active request context.\n\nArgs:\n    None\n\nReturns:\n    None: This method relies on assertions to validate state and does not return a value.\n\"\"\"",
                "source_code": "assert repr(flask.g) == \"<LocalProxy unbound>\"\n    assert not flask.g"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_server_name_subdomain",
                "second_doc": "\"\"\"\nTest various server name and subdomain configurations to verify route matching and request handling across different host and scheme combinations.\n\nArgs:\n    None\n\nReturns:\n    None\n\nWhy:\n    This method ensures that requests are routed correctly according to the application's server name, subdomain settings, and the HTTP/HTTPS scheme, which is essential for robust and predictable web application behavior under various deployment scenarios.\n\"\"\"",
                "source_code": "app = flask.Flask(__name__, subdomain_matching=True)\n    client = app.test_client()\n\n    @app.route(\"/\")\n    def index():\n        return \"default\"\n\n    @app.route(\"/\", subdomain=\"foo\")\n    def subdomain():\n        return \"subdomain\"\n\n    app.config[\"SERVER_NAME\"] = \"dev.local:5000\"\n    rv = client.get(\"/\")\n    assert rv.data == b\"default\"\n\n    rv = client.get(\"/\", \"http://dev.local:5000\")\n    assert rv.data == b\"default\"\n\n    rv = client.get(\"/\", \"https://dev.local:5000\")\n    assert rv.data == b\"default\"\n\n    app.config[\"SERVER_NAME\"] = \"dev.local:443\"\n    rv = client.get(\"/\", \"https://dev.local\")\n\n    # Werkzeug 1.0 fixes matching https scheme with 443 port\n    if rv.status_code != 404:\n        assert rv.data == b\"default\"\n\n    app.config[\"SERVER_NAME\"] = \"dev.local\"\n    rv = client.get(\"/\", \"https://dev.local\")\n    assert rv.data == b\"default\"\n\n    # suppress Werkzeug 1.0 warning about name mismatch\n    with pytest.warns(None):\n        rv = client.get(\"/\", \"http://foo.localhost\")\n        assert rv.status_code == 404\n\n    rv = client.get(\"/\", \"http://foo.dev.local\")\n    assert rv.data == b\"subdomain\""
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_exception_propagation",
                "second_doc": "\"\"\"\nTests that unhandled exceptions during request handling propagate according to specific configuration flags, ensuring proper error response and context management.\n\nArgs:\n    config_key (str or None): The name of a Flask configuration key to set for exception propagation behavior.\n        Valid values are 'TESTING', 'PROPAGATE_EXCEPTIONS', 'DEBUG', or None to use default settings.\n\nReturns:\n    None\n\nWhy:\n    This method verifies that the application correctly propagates or handles exceptions during request processing as dictated by its configuration, which is critical for accurate debugging, predictable error responses, and avoiding side effects across test runs.\n\"\"\"",
                "source_code": "def apprunner(config_key):\n        @app.route(\"/\")\n        def index():\n            1 // 0\n\n        if config_key is not None:\n            app.config[config_key] = True\n            with pytest.raises(Exception):\n                client.get(\"/\")\n        else:\n            assert client.get(\"/\").status_code == 500\n\n    # we have to run this test in an isolated thread because if the\n    # debug flag is set to true and an exception happens the context is\n    # not torn down.  This causes other tests that run after this fail\n    # when they expect no exception on the stack.\n    for config_key in \"TESTING\", \"PROPAGATE_EXCEPTIONS\", \"DEBUG\", None:\n        t = Thread(target=apprunner, args=(config_key,))\n        t.start()\n        t.join()"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_werkzeug_passthrough_errors",
                "second_doc": "\"\"\"\nTests the value of the passthrough_errors argument passed to the underlying server runner based on different Flask configuration and runtime options.\n\nArgs:\n    debug (bool): Whether Flask's debug mode is enabled.\n    use_debugger (bool): Whether Flask's interactive debugger is enabled.\n    use_reloader (bool): Whether the server should automatically reload on code changes.\n    propagate_exceptions (Optional[bool]): Flask configuration to control exception propagation.\n\nReturns:\n    None\n\nWhy:\n    Verifies that exception handling behavior is correctly passed to the WSGI server, ensuring consistent error propagation as determined by the application's configuration.\n\"\"\"",
                "source_code": "rv = {}\n\n    # Mocks werkzeug.serving.run_simple method\n    def run_simple_mock(*args, **kwargs):\n        rv[\"passthrough_errors\"] = kwargs.get(\"passthrough_errors\")\n\n    monkeypatch.setattr(werkzeug.serving, \"run_simple\", run_simple_mock)\n    app.config[\"PROPAGATE_EXCEPTIONS\"] = propagate_exceptions\n    app.run(debug=debug, use_debugger=use_debugger, use_reloader=use_reloader)"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_max_content_length",
                "second_doc": "\"\"\"\nTests the application's ability to handle requests that exceed the configured maximum content length by simulating a form post exceeding this limit, and verifies that the correct error response is returned.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "app.config[\"MAX_CONTENT_LENGTH\"] = 64\n\n    @app.before_request\n    def always_first():\n        flask.request.form[\"myfile\"]\n        AssertionError()\n\n    @app.route(\"/accept\", methods=[\"POST\"])\n    def accept_file():\n        flask.request.form[\"myfile\"]\n        AssertionError()\n\n    @app.errorhandler(413)\n    def catcher(error):\n        return \"42\"\n\n    rv = client.post(\"/accept\", data={\"myfile\": \"foo\" * 100})\n    assert rv.data == b\"42\""
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_url_processors",
                "second_doc": "\"\"\"\nTests URL processors related to handling language codes within URLs by ensuring that the language context is correctly extracted from and injected into URL routes and generated links. This behavior allows routes to dynamically respond to language preferences specified in URLs, supporting seamless localization of application content.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "@app.url_defaults\n    def add_language_code(endpoint, values):\n        if flask.g.lang_code is not None and app.url_map.is_endpoint_expecting(\n            endpoint, \"lang_code\"\n        ):\n            values.setdefault(\"lang_code\", flask.g.lang_code)\n\n    @app.url_value_preprocessor\n    def pull_lang_code(endpoint, values):\n        flask.g.lang_code = values.pop(\"lang_code\", None)\n\n    @app.route(\"/<lang_code>/\")\n    def index():\n        return flask.url_for(\"about\")\n\n    @app.route(\"/<lang_code>/about\")\n    def about():\n        return flask.url_for(\"something_else\")\n\n    @app.route(\"/foo\")\n    def something_else():\n        return flask.url_for(\"about\", lang_code=\"en\")\n\n    assert client.get(\"/de/\").data == b\"/de/about\"\n    assert client.get(\"/de/about\").data == b\"/foo\"\n    assert client.get(\"/foo\").data == b\"/en/about\""
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_inject_blueprint_url_defaults",
                "second_doc": "\"\"\"\nTests that default values specified for a blueprint's URL parameters are correctly injected, ensuring predictable URL generation and consistent route handling.\n\nArgs:\n    None\n\nReturns:\n    None\n\nThis test verifies that when a blueprint defines URL default values, these defaults are applied both when generating URLs and in the routing mechanism, supporting modular route management and reducing repetitive code.\n\"\"\"",
                "source_code": "bp = flask.Blueprint(\"foo.bar.baz\", __name__, template_folder=\"template\")\n\n    @bp.url_defaults\n    def bp_defaults(endpoint, values):\n        values[\"page\"] = \"login\"\n\n    @bp.route(\"/<page>\")\n    def view(page):\n        pass\n\n    app.register_blueprint(bp)\n\n    values = dict()\n    app.inject_url_defaults(\"foo.bar.baz.view\", values)\n    expected = dict(page=\"login\")\n    assert values == expected\n\n    with app.test_request_context(\"/somepage\"):\n        url = flask.url_for(\"foo.bar.baz.view\")\n    expected = \"/login\"\n    assert url == expected"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_nonascii_pathinfo",
                "second_doc": "\"\"\"\nTests whether the application correctly handles routes that contain non-ASCII characters in their path.\n\nArgs:\n    None\n\nReturns:\n    None\n\nRaises:\n    AssertionError: If the response data does not match the expected output.\n\nWhy:\n    This method ensures the web application can process and respond to requests with internationalized (non-ASCII) paths, verifying proper Unicode support and route matching for a broader set of user requests.\n\"\"\"",
                "source_code": "@app.route(\"/\u043a\u0438\u0440\u0442\u0435\u0441\u0442\")\n    def index():\n        return \"Hello World!\"\n\n    rv = client.get(\"/\u043a\u0438\u0440\u0442\u0435\u0441\u0442\")\n    assert rv.data == b\"Hello World!\""
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_debug_mode_complains_after_first_request",
                "second_doc": "\"\"\"\nTest that modifying routes after the first request in debug mode triggers an AssertionError, protecting application consistency by preventing changes to routing after request handling has begun.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "app.debug = True\n\n    @app.route(\"/\")\n    def index():\n        return \"Awesome\"\n\n    assert not app.got_first_request\n    assert client.get(\"/\").data == b\"Awesome\"\n    with pytest.raises(AssertionError) as e:\n\n        @app.route(\"/foo\")\n        def broken():\n            return \"Meh\"\n\n    assert \"A setup function was called\" in str(e.value)\n\n    app.debug = False\n\n    @app.route(\"/foo\")\n    def working():\n        return \"Meh\"\n\n    assert client.get(\"/foo\").data == b\"Meh\"\n    assert app.got_first_request"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_before_first_request_functions",
                "second_doc": "\"\"\"\nTests that functions registered with the before_first_request decorator are executed only once before the first client request is processed. This ensures initialization routines or setup code meant to run a single time per application lifecycle are triggered appropriately.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "got = []\n\n    @app.before_first_request\n    def foo():\n        got.append(42)\n\n    client.get(\"/\")\n    assert got == [42]\n    client.get(\"/\")\n    assert got == [42]\n    assert app.got_first_request"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_before_first_request_functions_concurrent",
                "second_doc": "\"\"\"\nTests that functions registered with `before_first_request` are executed only once per application, even when the first request is accessed concurrently from multiple threads.\n\nThis is important to ensure thread-safe initialization or setup procedures happen just once before handling the first incoming request, preventing race conditions or redundant setup.\n\nArgs:\n    None\n\nReturns:\n    None\n\nRaises:\n    AssertionError: If the `before_first_request` function runs more than once or Flask's internal state does not reflect that the first request has been handled.\n\"\"\"",
                "source_code": "got = []\n\n    @app.before_first_request\n    def foo():\n        time.sleep(0.2)\n        got.append(42)\n\n    def get_and_assert():\n        client.get(\"/\")\n        assert got == [42]\n\n    t = Thread(target=get_and_assert)\n    t.start()\n    get_and_assert()\n    t.join()\n    assert app.got_first_request"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_routing_redirect_debugging",
                "second_doc": "\"\"\"\nTests how the application handles routing redirects in debug versus non-debug modes, ensuring that incorrect POST requests to routes expecting trailing slashes raise appropriate debug errors and that automatic redirects work correctly.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "app.debug = True\n\n    @app.route(\"/foo/\", methods=[\"GET\", \"POST\"])\n    def foo():\n        return \"success\"\n\n    with client:\n        with pytest.raises(AssertionError) as e:\n            client.post(\"/foo\", data={})\n        assert \"http://localhost/foo/\" in str(e.value)\n        assert \"Make sure to directly send your POST-request to this URL\" in str(\n            e.value\n        )\n\n        rv = client.get(\"/foo\", data={}, follow_redirects=True)\n        assert rv.data == b\"success\"\n\n    app.debug = False\n    with client:\n        rv = client.post(\"/foo\", data={}, follow_redirects=True)\n        assert rv.data == b\"success\""
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_route_decorator_custom_endpoint",
                "second_doc": "\"\"\"\nTests that custom endpoint names specified in route decorators are correctly mapped and accessible, ensuring that the routing system associates URLs to the designated endpoints for accurate request handling and URL generation.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "app.debug = True\n\n    @app.route(\"/foo/\")\n    def foo():\n        return flask.request.endpoint\n\n    @app.route(\"/bar/\", endpoint=\"bar\")\n    def for_bar():\n        return flask.request.endpoint\n\n    @app.route(\"/bar/123\", endpoint=\"123\")\n    def for_bar_foo():\n        return flask.request.endpoint\n\n    with app.test_request_context():\n        assert flask.url_for(\"foo\") == \"/foo/\"\n        assert flask.url_for(\"bar\") == \"/bar/\"\n        assert flask.url_for(\"123\") == \"/bar/123\"\n\n    assert client.get(\"/foo/\").data == b\"foo\"\n    assert client.get(\"/bar/\").data == b\"bar\"\n    assert client.get(\"/bar/123\").data == b\"123\""
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_preserve_only_once",
                "second_doc": "\"\"\"\nTests that the Flask application and request contexts are preserved only once per request, ensuring proper cleanup and preventing context leaks during error handling.\n\nArgs:\n    None\n\nReturns:\n    None\n\nRaises:\n    AssertionError: If the application or request context is not properly initialized or cleaned up.\n\"\"\"",
                "source_code": "app.debug = True\n\n    @app.route(\"/fail\")\n    def fail_func():\n        1 // 0\n\n    for _x in range(3):\n        with pytest.raises(ZeroDivisionError):\n            client.get(\"/fail\")\n\n    assert flask._request_ctx_stack.top is not None\n    assert flask._app_ctx_stack.top is not None\n    # implicit appctx disappears too\n    flask._request_ctx_stack.top.pop()\n    assert flask._request_ctx_stack.top is None\n    assert flask._app_ctx_stack.top is None"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_preserve_remembers_exception",
                "second_doc": "\"\"\"\nTests that exceptions occurring during request processing are correctly preserved and made available to teardown handlers in subsequent requests. This ensures proper error tracking and resource management during the application's request lifecycle.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "app.debug = True\n    errors = []\n\n    @app.route(\"/fail\")\n    def fail_func():\n        1 // 0\n\n    @app.route(\"/success\")\n    def success_func():\n        return \"Okay\"\n\n    @app.teardown_request\n    def teardown_handler(exc):\n        errors.append(exc)\n\n    # After this failure we did not yet call the teardown handler\n    with pytest.raises(ZeroDivisionError):\n        client.get(\"/fail\")\n    assert errors == []\n\n    # But this request triggers it, and it's an error\n    client.get(\"/success\")\n    assert len(errors) == 2\n    assert isinstance(errors[0], ZeroDivisionError)\n\n    # At this point another request does nothing.\n    client.get(\"/success\")\n    assert len(errors) == 3\n    assert errors[1] is None"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_get_method_on_g",
                "second_doc": "\"\"\"\nTests the behavior and flexibility of the context-local storage system when accessing and setting attribute values dynamically.\n\nThis ensures that objects relying on per-request storage can safely retrieve missing values, specify defaults, and assign data as needed during an application's lifecycle.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "assert flask.g.get(\"x\") is None\n    assert flask.g.get(\"x\", 11) == 11\n    flask.g.x = 42\n    assert flask.g.get(\"x\") == 42\n    assert flask.g.x == 42"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_g_iteration_protocol",
                "second_doc": "\"\"\"\nTests how the application context global object supports attribute iteration and membership checks, ensuring only explicitly set attributes are included during these operations.\n\nArgs:\n    None\n\nReturns:\n    None\n\nRaises:\n    AssertionError: If the iteration protocol or membership checks do not behave as expected.\n\"\"\"",
                "source_code": "flask.g.foo = 23\n    flask.g.bar = 42\n    assert \"foo\" in flask.g\n    assert \"foos\" not in flask.g\n    assert sorted(flask.g) == [\"bar\", \"foo\"]"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_subdomain_basic_support",
                "second_doc": "\"\"\"\nTest that the routing system distinguishes requests based on subdomains, ensuring different routes are served depending on the subdomain in the HTTP request.\n\nArgs:\n    None\n\nReturns:\n    None\n\nThis method verifies that route handling adapts correctly to subdomain-based URL patterns, supporting applications that require different functionality or content depending on the accessed subdomain.\n\"\"\"",
                "source_code": "app = flask.Flask(__name__, subdomain_matching=True)\n    app.config[\"SERVER_NAME\"] = \"localhost.localdomain\"\n    client = app.test_client()\n\n    @app.route(\"/\")\n    def normal_index():\n        return \"normal index\"\n\n    @app.route(\"/\", subdomain=\"test\")\n    def test_index():\n        return \"test index\"\n\n    rv = client.get(\"/\", \"http://localhost.localdomain/\")\n    assert rv.data == b\"normal index\"\n\n    rv = client.get(\"/\", \"http://test.localhost.localdomain/\")\n    assert rv.data == b\"test index\""
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_subdomain_matching",
                "second_doc": "\"\"\"\nTests if route parameters can be correctly extracted from requested subdomains when subdomain matching is enabled.\n\nArgs:\n    None\n\nReturns:\n    None. Asserts that the response content matches the expected output, verifying correct subdomain route behavior.\n    \nWhy:\n    Ensures that the application correctly maps requests to subdomain-specific routes and extracts dynamic values, which is essential for supporting user- or tenant-based routing scenarios in web applications.\n\"\"\"",
                "source_code": "app = flask.Flask(__name__, subdomain_matching=True)\n    client = app.test_client()\n    app.config[\"SERVER_NAME\"] = \"localhost.localdomain\"\n\n    @app.route(\"/\", subdomain=\"<user>\")\n    def index(user):\n        return f\"index for {user}\"\n\n    rv = client.get(\"/\", \"http://mitsuhiko.localhost.localdomain/\")\n    assert rv.data == b\"index for mitsuhiko\""
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_subdomain_matching_with_ports",
                "second_doc": "\"\"\"\nTests whether the application correctly handles routing based on subdomains when port numbers are included in the server name configuration.\n\nArgs:\n    None\n\nReturns:\n    None. Asserts that the response data matches the expected output for a subdomain request with a specific port.\n    \nWhy:\n    Ensures that subdomain matching works accurately even when ports are specified, verifying robust handling of route resolution in diverse deployment scenarios.\n\"\"\"",
                "source_code": "app = flask.Flask(__name__, subdomain_matching=True)\n    app.config[\"SERVER_NAME\"] = \"localhost.localdomain:3000\"\n    client = app.test_client()\n\n    @app.route(\"/\", subdomain=\"<user>\")\n    def index(user):\n        return f\"index for {user}\"\n\n    rv = client.get(\"/\", \"http://mitsuhiko.localhost.localdomain:3000/\")\n    assert rv.data == b\"index for mitsuhiko\""
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_subdomain_matching_other_name",
                "second_doc": "\"\"\"\nTests subdomain matching behavior in route resolution depending on the subdomain_matching configuration.\n\nThis verifies the application's handling of requests to host and subdomains, ensuring correct HTTP response codes based on whether strict subdomain matching is enabled.\n\nArgs:\n    matching (bool): Specifies whether subdomain_matching is enabled in the Flask application.\n\nReturns:\n    None. Asserts the correctness of HTTP responses for different hostnames relative to the application's SERVER_NAME configuration.\n\"\"\"",
                "source_code": "app = flask.Flask(__name__, subdomain_matching=matching)\n    app.config[\"SERVER_NAME\"] = \"localhost.localdomain:3000\"\n    client = app.test_client()\n\n    @app.route(\"/\")\n    def index():\n        return \"\", 204\n\n    # suppress Werkzeug 0.15 warning about name mismatch\n    with pytest.warns(None):\n        # ip address can't match name\n        rv = client.get(\"/\", \"http://127.0.0.1:3000/\")\n        assert rv.status_code == 404 if matching else 204\n\n    # allow all subdomains if matching is disabled\n    rv = client.get(\"/\", \"http://www.localhost.localdomain:3000/\")\n    assert rv.status_code == 404 if matching else 204"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_multi_route_rules",
                "second_doc": "\"\"\"\nTests that a view function can be mapped to multiple URL routes, each correctly resolving to the intended parameter and response value.\n\nArgs:\n    None\n\nReturns:\n    None\n\nThis method ensures that route registration and parameter handling work properly, enabling consistent behavior across multiple URL patterns that point to the same endpoint.\n\"\"\"",
                "source_code": "@app.route(\"/\")\n    @app.route(\"/<test>/\")\n    def index(test=\"a\"):\n        return test\n\n    rv = client.open(\"/\")\n    assert rv.data == b\"a\"\n    rv = client.open(\"/b/\")\n    assert rv.data == b\"b\""
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_multi_route_class_views",
                "second_doc": "\"\"\"\nVerifies that class-based views can register multiple routes and handle URL parameters correctly through Flask's routing system.\n\nArgs:\n    app: The Flask application instance to which the routes are bound.\n    client: The test client used to simulate HTTP requests.\n\nReturns:\n    None. Asserts that HTTP responses for registered routes return the expected data, confirming proper route-to-method resolution.\n\"\"\"",
                "source_code": "class View:\n        def __init__(self, app):\n            app.add_url_rule(\"/\", \"index\", self.index)\n            app.add_url_rule(\"/<test>/\", \"index\", self.index)\n\n        def index(self, test=\"a\"):\n            return test\n\n    _ = View(app)\n    rv = client.open(\"/\")\n    assert rv.data == b\"a\"\n    rv = client.open(\"/b/\")\n    assert rv.data == b\"b\""
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_run_defaults",
                "second_doc": "\"\"\"\nTests the default behavior of the application's run process by mocking the underlying server startup function to ensure it is invoked correctly.\n\nArgs:\n    monkeypatch: A pytest fixture used to replace the 'run_simple' method in werkzeug.serving with a mock implementation.\n\nReturns:\n    None. Asserts that the server startup logic was triggered as expected.\n\nWhy:\n    This method verifies that the application's run procedure correctly delegates to the server startup function, ensuring the application's core execution flow is intact and can be reliably tested.\n\"\"\"",
                "source_code": "rv = {}\n\n    # Mocks werkzeug.serving.run_simple method\n    def run_simple_mock(*args, **kwargs):\n        rv[\"result\"] = \"running...\"\n\n    monkeypatch.setattr(werkzeug.serving, \"run_simple\", run_simple_mock)\n    app.run()\n    assert rv[\"result\"] == \"running...\""
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_run_server_port",
                "second_doc": "\"\"\"\nTests that the application initiates its server on the specified host and port by replacing the server start function with a mock. This ensures that the server startup parameters are correctly passed and invoked.\n\nArgs:\n    monkeypatch: A test fixture used to temporarily replace attributes for testing purposes.\n\nReturns:\n    None\n\nRaises:\n    AssertionError: If the application does not attempt to run on the expected host and port.\n    \nWhy:\n    Verifies that the application server is invoked with the correct configuration, helping to catch misconfigurations in deployment parameters early in development or CI pipelines.\n\"\"\"",
                "source_code": "rv = {}\n\n    # Mocks werkzeug.serving.run_simple method\n    def run_simple_mock(hostname, port, application, *args, **kwargs):\n        rv[\"result\"] = f\"running on {hostname}:{port} ...\"\n\n    monkeypatch.setattr(werkzeug.serving, \"run_simple\", run_simple_mock)\n    hostname, port = \"localhost\", 8000\n    app.run(hostname, port, debug=True)\n    assert rv[\"result\"] == f\"running on {hostname}:{port} ...\""
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_run_from_config",
                "second_doc": "\"\"\"\nTests whether the application's run method correctly determines the host and port settings, given various combinations of function arguments and configuration values. This ensures that routing and server binding logic behave as expected in different deployment situations.\n\nArgs:\n    host (str or None): The hostname explicitly passed to the application's run method.\n    port (int or None): The port value explicitly passed to the application's run method.\n    server_name (str): The SERVER_NAME value set in the application's config.\n    expect_host (str): The expected resolved host value.\n    expect_port (int): The expected resolved port value.\n\nReturns:\n    None\n\"\"\"",
                "source_code": "def run_simple_mock(hostname, port, *args, **kwargs):\n        assert hostname == expect_host\n        assert port == expect_port\n\n    monkeypatch.setattr(werkzeug.serving, \"run_simple\", run_simple_mock)\n    app.config[\"SERVER_NAME\"] = server_name\n    app.run(host, port)"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_max_cookie_size",
                "second_doc": "\"\"\"\nTests how cookie size limits are handled by the response object both inside and outside the application context, ensuring warnings are issued if cookies exceed the configured maximum allowed size.\n\nArgs:\n    None\n\nReturns:\n    None\n\nWhy:\n    This method verifies that the system correctly applies and enforces configurable restrictions on cookie size for HTTP responses, protecting application behavior and aiding developers in preventing oversized cookies that could cause interoperability or security issues.\n\"\"\"",
                "source_code": "app.config[\"MAX_COOKIE_SIZE\"] = 100\n\n    # outside app context, default to Werkzeug static value,\n    # which is also the default config\n    response = flask.Response()\n    default = flask.Flask.default_config[\"MAX_COOKIE_SIZE\"]\n    assert response.max_cookie_size == default\n\n    # inside app context, use app config\n    with app.app_context():\n        assert flask.Response().max_cookie_size == 100\n\n    @app.route(\"/\")\n    def index():\n        r = flask.Response(\"\", status=204)\n        r.set_cookie(\"foo\", \"bar\" * 100)\n        return r\n\n    client.get(\"/\")\n    assert len(recwarn) == 1\n    w = recwarn.pop()\n    assert \"cookie is too large\" in str(w.message)\n\n    app.config[\"MAX_COOKIE_SIZE\"] = 0\n\n    client.get(\"/\")\n    assert len(recwarn) == 0"
            },
            "type": "function"
        }
    ],
    "flask/tests/test_blueprints.py": [
        {
            "details": {
                "docstring": null,
                "method_name": "test_blueprint_specific_error_handling",
                "second_doc": "\"\"\"\nTest that error handling logic can be scoped to individual blueprints, ensuring that different parts of the application return appropriate responses to HTTP 403 errors according to where the error occurs.\n\nThis method is designed to verify the correct isolation and fallback of error handlers, which is important for maintaining distinct behavior across different application modules.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "frontend = flask.Blueprint(\"frontend\", __name__)\n    backend = flask.Blueprint(\"backend\", __name__)\n    sideend = flask.Blueprint(\"sideend\", __name__)\n\n    @frontend.errorhandler(403)\n    def frontend_forbidden(e):\n        return \"frontend says no\", 403\n\n    @frontend.route(\"/frontend-no\")\n    def frontend_no():\n        flask.abort(403)\n\n    @backend.errorhandler(403)\n    def backend_forbidden(e):\n        return \"backend says no\", 403\n\n    @backend.route(\"/backend-no\")\n    def backend_no():\n        flask.abort(403)\n\n    @sideend.route(\"/what-is-a-sideend\")\n    def sideend_no():\n        flask.abort(403)\n\n    app.register_blueprint(frontend)\n    app.register_blueprint(backend)\n    app.register_blueprint(sideend)\n\n    @app.errorhandler(403)\n    def app_forbidden(e):\n        return \"application itself says no\", 403\n\n    assert client.get(\"/frontend-no\").data == b\"frontend says no\"\n    assert client.get(\"/backend-no\").data == b\"backend says no\"\n    assert client.get(\"/what-is-a-sideend\").data == b\"application itself says no\""
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_blueprint_specific_user_error_handling",
                "second_doc": "\"\"\"\nTests that error handlers specific to a Flask blueprint correctly intercept and handle exceptions raised within that blueprint's routes, ensuring appropriate custom responses are returned for different exception types.\n\nArgs:\n    None\n\nReturns:\n    None\n\nWhy:\n    This method verifies the blueprint's ability to distinguish between and correctly process different custom exceptions, allowing for modular and localized error handling behaviors within an application.\n\"\"\"",
                "source_code": "class MyDecoratorException(Exception):\n        pass\n\n    class MyFunctionException(Exception):\n        pass\n\n    blue = flask.Blueprint(\"blue\", __name__)\n\n    @blue.errorhandler(MyDecoratorException)\n    def my_decorator_exception_handler(e):\n        assert isinstance(e, MyDecoratorException)\n        return \"boom\"\n\n    def my_function_exception_handler(e):\n        assert isinstance(e, MyFunctionException)\n        return \"bam\"\n\n    blue.register_error_handler(MyFunctionException, my_function_exception_handler)\n\n    @blue.route(\"/decorator\")\n    def blue_deco_test():\n        raise MyDecoratorException()\n\n    @blue.route(\"/function\")\n    def blue_func_test():\n        raise MyFunctionException()\n\n    app.register_blueprint(blue)\n\n    assert client.get(\"/decorator\").data == b\"boom\"\n    assert client.get(\"/function\").data == b\"bam\""
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_blueprint_app_error_handling",
                "second_doc": "\"\"\"\nTests that registering an application-level error handler for 403 errors using a blueprint results in consistent error responses for both application and blueprint routes that trigger such errors.\n\nArgs:\n    app: The Flask application instance being tested.\n    client: The Flask test client used to simulate HTTP requests.\n\nReturns:\n    None\n\nWhy:\n    Ensuring unified error handling behavior across both the main application and its blueprints helps maintain consistent user experiences and simplifies debugging and maintenance.\n\"\"\"",
                "source_code": "errors = flask.Blueprint(\"errors\", __name__)\n\n    @errors.app_errorhandler(403)\n    def forbidden_handler(e):\n        return \"you shall not pass\", 403\n\n    @app.route(\"/forbidden\")\n    def app_forbidden():\n        flask.abort(403)\n\n    forbidden_bp = flask.Blueprint(\"forbidden_bp\", __name__)\n\n    @forbidden_bp.route(\"/nope\")\n    def bp_forbidden():\n        flask.abort(403)\n\n    app.register_blueprint(errors)\n    app.register_blueprint(forbidden_bp)\n\n    assert client.get(\"/forbidden\").data == b\"you shall not pass\"\n    assert client.get(\"/nope\").data == b\"you shall not pass\""
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_blueprint_prefix_slash",
                "second_doc": "\"\"\"\nTests various combinations of blueprint prefixes and route rules to ensure that URLs are joined and resolved as expected when registering routes. This helps guarantee that the application's URL routing is robust to different forms of path inputs, contributing to reliable endpoint behavior.\n\nArgs:\n    prefix (str): The URL prefix assigned to the blueprint.\n    rule (str): The route rule used when defining the endpoint within the blueprint.\n    url (str): The expected combined URL after registering the blueprint and route.\n\nReturns:\n    None. Asserts that the endpoint is accessible at the specified URL and returns a 204 status code.\n\"\"\"",
                "source_code": "bp = flask.Blueprint(\"test\", __name__, url_prefix=prefix)\n\n    @bp.route(rule)\n    def index():\n        return \"\", 204\n\n    app.register_blueprint(bp)\n    assert client.get(url).status_code == 204"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_blueprint_url_defaults",
                "second_doc": "\"\"\"\nTests that registering a blueprint with different URL defaults allows route handlers to receive varying default parameter values based on the blueprint's configuration.\n\nArgs:\n    app: The Flask application instance to register blueprints.\n    client: The test client used to make HTTP requests against the app.\n\nReturns:\n    None. Asserts correct default values are used in responses according to blueprint registration.\n    \nWhy:\n    This method verifies that default parameters supplied via blueprint registration are correctly injected into view functions, ensuring modularity and reusability of routes across different URL prefixes.\n\"\"\"",
                "source_code": "bp = flask.Blueprint(\"test\", __name__)\n\n    @bp.route(\"/foo\", defaults={\"baz\": 42})\n    def foo(bar, baz):\n        return f\"{bar}/{baz:d}\"\n\n    @bp.route(\"/bar\")\n    def bar(bar):\n        return str(bar)\n\n    app.register_blueprint(bp, url_prefix=\"/1\", url_defaults={\"bar\": 23})\n    app.register_blueprint(bp, url_prefix=\"/2\", url_defaults={\"bar\": 19})\n\n    assert client.get(\"/1/foo\").data == b\"23/42\"\n    assert client.get(\"/2/foo\").data == b\"19/42\"\n    assert client.get(\"/1/bar\").data == b\"23\"\n    assert client.get(\"/2/bar\").data == b\"19\""
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_blueprint_url_processors",
                "second_doc": "\"\"\"\nTests the integration of URL processors within a Blueprint, ensuring language code is correctly passed between routes via URL parameters and global context.\n\nArgs:\n    client: A test client for simulating HTTP requests.\n    app: The Flask application used for registering the blueprint.\n\nReturns:\n    None\n\nWhy:\n    This method verifies that custom logic for handling dynamic URL segments (like language codes) works as intended, allowing the application to consistently extract, propagate, and utilize language information across related routes.\n\"\"\"",
                "source_code": "bp = flask.Blueprint(\"frontend\", __name__, url_prefix=\"/<lang_code>\")\n\n    @bp.url_defaults\n    def add_language_code(endpoint, values):\n        values.setdefault(\"lang_code\", flask.g.lang_code)\n\n    @bp.url_value_preprocessor\n    def pull_lang_code(endpoint, values):\n        flask.g.lang_code = values.pop(\"lang_code\")\n\n    @bp.route(\"/\")\n    def index():\n        return flask.url_for(\".about\")\n\n    @bp.route(\"/about\")\n    def about():\n        return flask.url_for(\".index\")\n\n    app.register_blueprint(bp)\n\n    assert client.get(\"/de/\").data == b\"/de/about\"\n    assert client.get(\"/de/about\").data == b\"/de/\""
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_templates_and_static",
                "second_doc": "\"\"\"\nTests that routes, static files, and templates within the application behave as expected, including correct content delivery, static file cache configuration, and error handling for missing templates.\n\nThis method ensures that endpoints return the right responses, static assets are served with the proper cache-control headers, and template resolution or error scenarios work as intended to validate the app's reliability and resource management.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "from blueprintapp import app\n\n    client = app.test_client()\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"Hello from the Frontend\"\n    rv = client.get(\"/admin/\")\n    assert rv.data == b\"Hello from the Admin\"\n    rv = client.get(\"/admin/index2\")\n    assert rv.data == b\"Hello from the Admin\"\n    rv = client.get(\"/admin/static/test.txt\")\n    assert rv.data.strip() == b\"Admin File\"\n    rv.close()\n    rv = client.get(\"/admin/static/css/test.css\")\n    assert rv.data.strip() == b\"/* nested file */\"\n    rv.close()\n\n    # try/finally, in case other tests use this app for Blueprint tests.\n    max_age_default = app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"]\n    try:\n        expected_max_age = 3600\n        if app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] == expected_max_age:\n            expected_max_age = 7200\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = expected_max_age\n        rv = client.get(\"/admin/static/css/test.css\")\n        cc = parse_cache_control_header(rv.headers[\"Cache-Control\"])\n        assert cc.max_age == expected_max_age\n        rv.close()\n    finally:\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = max_age_default\n\n    with app.test_request_context():\n        assert (\n            flask.url_for(\"admin.static\", filename=\"test.txt\")\n            == \"/admin/static/test.txt\"\n        )\n\n    with app.test_request_context():\n        with pytest.raises(TemplateNotFound) as e:\n            flask.render_template(\"missing.html\")\n        assert e.value.name == \"missing.html\"\n\n    with flask.Flask(__name__).test_request_context():\n        assert flask.render_template(\"nested/nested.txt\") == \"I'm nested\""
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_default_static_cache_timeout",
                "second_doc": "\"\"\"\nTests that a custom cache timeout value defined in a blueprint for serving static files is correctly applied instead of the application's global default. This ensures that per-blueprint configurations for static resources are respected, allowing for precise control over caching behavior in different parts of the application.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "class MyBlueprint(flask.Blueprint):\n        def get_send_file_max_age(self, filename):\n            return 100\n\n    blueprint = MyBlueprint(\"blueprint\", __name__, static_folder=\"static\")\n    app.register_blueprint(blueprint)\n\n    # try/finally, in case other tests use this app for Blueprint tests.\n    max_age_default = app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"]\n    try:\n        with app.test_request_context():\n            unexpected_max_age = 3600\n            if app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] == unexpected_max_age:\n                unexpected_max_age = 7200\n            app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = unexpected_max_age\n            rv = blueprint.send_static_file(\"index.html\")\n            cc = parse_cache_control_header(rv.headers[\"Cache-Control\"])\n            assert cc.max_age == 100\n            rv.close()\n    finally:\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = max_age_default"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_templates_list",
                "second_doc": "\"\"\"\nTests that the application correctly discovers and lists all template files available within its environment.\n\nThis ensures that template management and configuration are working as intended, which is crucial for rendering web pages and maintaining a predictable user interface.\n\nReturns:\n    None. Raises an AssertionError if the list of templates does not match the expected template files.\n\"\"\"",
                "source_code": "from blueprintapp import app\n\n    templates = sorted(app.jinja_env.list_templates())\n    assert templates == [\"admin/index.html\", \"frontend/index.html\"]"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_dotted_names",
                "second_doc": "\"\"\"\nTests URL building and routing behavior for blueprints with dotted names to ensure Flask correctly resolves route references between and within blueprints using explicit and relative naming.\n\nArgs:\n    app (flask.Flask): The Flask application instance to register blueprints with.\n    client (flask.testing.FlaskClient): A test client used to simulate HTTP requests.\n\nReturns:\n    None\n\nWhy:\n    Correctly resolving dotted blueprint names is essential for code modularity, maintainability, and correctness when organizing routes across complex or component-based Flask web applications.\n\"\"\"",
                "source_code": "frontend = flask.Blueprint(\"myapp.frontend\", __name__)\n    backend = flask.Blueprint(\"myapp.backend\", __name__)\n\n    @frontend.route(\"/fe\")\n    def frontend_index():\n        return flask.url_for(\"myapp.backend.backend_index\")\n\n    @frontend.route(\"/fe2\")\n    def frontend_page2():\n        return flask.url_for(\".frontend_index\")\n\n    @backend.route(\"/be\")\n    def backend_index():\n        return flask.url_for(\"myapp.frontend.frontend_index\")\n\n    app.register_blueprint(frontend)\n    app.register_blueprint(backend)\n\n    assert client.get(\"/fe\").data.strip() == b\"/be\"\n    assert client.get(\"/fe2\").data.strip() == b\"/fe\"\n    assert client.get(\"/be\").data.strip() == b\"/fe\""
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_dotted_names_from_app",
                "second_doc": "\"\"\"\nTests whether URL generation using dotted names between the main application and a blueprint works correctly, ensuring that cross-referencing routes is handled as expected.\n\nArgs:\n    app: The Flask application instance.\n    client: The test client for sending HTTP requests to the application.\n\nReturns:\n    None. Asserts that the generated URLs match the expected values, validating the URL routing and naming system.\n\"\"\"",
                "source_code": "test = flask.Blueprint(\"test\", __name__)\n\n    @app.route(\"/\")\n    def app_index():\n        return flask.url_for(\"test.index\")\n\n    @test.route(\"/test/\")\n    def index():\n        return flask.url_for(\"app_index\")\n\n    app.register_blueprint(test)\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"/test/\""
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_empty_url_defaults",
                "second_doc": "\"\"\"\nTests that the routing system correctly applies default parameter values for endpoints when the corresponding URL segment is omitted.\n\nArgs:\n    client: A test client for sending requests to the Flask application.\n\nReturns:\n    None\n\"\"\"",
                "source_code": "bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.route(\"/\", defaults={\"page\": 1})\n    @bp.route(\"/page/<int:page>\")\n    def something(page):\n        return str(page)\n\n    app.register_blueprint(bp)\n\n    assert client.get(\"/\").data == b\"1\"\n    assert client.get(\"/page/2\").data == b\"2\""
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_route_decorator_custom_endpoint",
                "second_doc": "\"\"\"\nTests that route decorators correctly assign custom endpoint names and verifies that HTTP requests resolve to these endpoints as expected.\n\nThis ensures that registering routes with explicit or default endpoint names properly sets up internal routing, supporting modular and customizable URL organization.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.route(\"/foo\")\n    def foo():\n        return flask.request.endpoint\n\n    @bp.route(\"/bar\", endpoint=\"bar\")\n    def foo_bar():\n        return flask.request.endpoint\n\n    @bp.route(\"/bar/123\", endpoint=\"123\")\n    def foo_bar_foo():\n        return flask.request.endpoint\n\n    @bp.route(\"/bar/foo\")\n    def bar_foo():\n        return flask.request.endpoint\n\n    app.register_blueprint(bp, url_prefix=\"/py\")\n\n    @app.route(\"/\")\n    def index():\n        return flask.request.endpoint\n\n    assert client.get(\"/\").data == b\"index\"\n    assert client.get(\"/py/foo\").data == b\"bp.foo\"\n    assert client.get(\"/py/bar\").data == b\"bp.bar\"\n    assert client.get(\"/py/bar/123\").data == b\"bp.123\"\n    assert client.get(\"/py/bar/foo\").data == b\"bp.bar_foo\""
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_route_decorator_custom_endpoint_with_dots",
                "second_doc": "\"\"\"\nTests that attempting to register routes with custom endpoint names containing dots correctly raises AssertionError, ensuring route endpoint naming restrictions are enforced. This helps maintain consistent internal behavior and prevents invalid endpoint usage.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.route(\"/foo\")\n    def foo():\n        return flask.request.endpoint\n\n    try:\n\n        @bp.route(\"/bar\", endpoint=\"bar.bar\")\n        def foo_bar():\n            return flask.request.endpoint\n\n    except AssertionError:\n        pass\n    else:\n        raise AssertionError(\"expected AssertionError not raised\")\n\n    try:\n\n        @bp.route(\"/bar/123\", endpoint=\"bar.123\")\n        def foo_bar_foo():\n            return flask.request.endpoint\n\n    except AssertionError:\n        pass\n    else:\n        raise AssertionError(\"expected AssertionError not raised\")\n\n    def foo_foo_foo():\n        pass\n\n    pytest.raises(\n        AssertionError,\n        lambda: bp.add_url_rule(\"/bar/123\", endpoint=\"bar.123\", view_func=foo_foo_foo),\n    )\n\n    pytest.raises(\n        AssertionError, bp.route(\"/bar/123\", endpoint=\"bar.123\"), lambda: None\n    )\n\n    foo_foo_foo.__name__ = \"bar.123\"\n\n    pytest.raises(\n        AssertionError, lambda: bp.add_url_rule(\"/bar/123\", view_func=foo_foo_foo)\n    )\n\n    bp.add_url_rule(\n        \"/bar/456\", endpoint=\"foofoofoo\", view_func=functools.partial(foo_foo_foo)\n    )\n\n    app.register_blueprint(bp, url_prefix=\"/py\")\n\n    assert client.get(\"/py/foo\").data == b\"bp.foo\"\n    # The rule's didn't actually made it through\n    rv = client.get(\"/py/bar\")\n    assert rv.status_code == 404\n    rv = client.get(\"/py/bar/123\")\n    assert rv.status_code == 404"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_endpoint_decorator",
                "second_doc": "\"\"\"\nTests how custom endpoint naming and blueprint registration affect route resolution and URL mapping in the application.\n\nArgs:\n    None\n\nReturns:\n    None\n\nThis method verifies that routes registered directly to the app and those defined within a blueprint are correctly distinguished, ensuring that endpoint lookups and HTTP responses behave as expected in complex routing scenarios.\n\"\"\"",
                "source_code": "from werkzeug.routing import Rule\n\n    app.url_map.add(Rule(\"/foo\", endpoint=\"bar\"))\n\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.endpoint(\"bar\")\n    def foobar():\n        return flask.request.endpoint\n\n    app.register_blueprint(bp, url_prefix=\"/bp_prefix\")\n\n    assert client.get(\"/foo\").data == b\"bar\"\n    assert client.get(\"/bp_prefix/bar\").status_code == 404"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_template_filter",
                "second_doc": "\"\"\"\nTests that a custom template filter can be registered to a Flask application using a blueprint, and verifies that the filter works as expected by reversing a given string.\n\nArgs:\n    None\n\nReturns:\n    None\n\nWhy:\n    This ensures that template filters can be modularly defined within blueprints and are correctly accessible in the application's template environment, supporting flexible template customization.\n\"\"\"",
                "source_code": "bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.app_template_filter()\n    def my_reverse(s):\n        return s[::-1]\n\n    app.register_blueprint(bp, url_prefix=\"/py\")\n    assert \"my_reverse\" in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters[\"my_reverse\"] == my_reverse\n    assert app.jinja_env.filters[\"my_reverse\"](\"abcd\") == \"dcba\""
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_add_template_filter",
                "second_doc": "\"\"\"\nTests whether a custom template filter can be successfully registered and used with a Flask blueprint. By confirming the presence and correct operation of the filter, this test ensures that the templating system supports extension with user-defined filters, enabling dynamic template rendering customization.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "bp = flask.Blueprint(\"bp\", __name__)\n\n    def my_reverse(s):\n        return s[::-1]\n\n    bp.add_app_template_filter(my_reverse)\n    app.register_blueprint(bp, url_prefix=\"/py\")\n    assert \"my_reverse\" in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters[\"my_reverse\"] == my_reverse\n    assert app.jinja_env.filters[\"my_reverse\"](\"abcd\") == \"dcba\""
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_template_filter_with_name",
                "second_doc": "\"\"\"\nTests registration and correct behavior of a custom Jinja template filter with a specific name in a Flask blueprint. This ensures that custom filters can be added to the template engine, allowing developers to extend template rendering capabilities for their web applications.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.app_template_filter(\"strrev\")\n    def my_reverse(s):\n        return s[::-1]\n\n    app.register_blueprint(bp, url_prefix=\"/py\")\n    assert \"strrev\" in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters[\"strrev\"] == my_reverse\n    assert app.jinja_env.filters[\"strrev\"](\"abcd\") == \"dcba\""
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_add_template_filter_with_name",
                "second_doc": "\"\"\"\nTests whether a custom template filter with a specific name can be added to a blueprint and correctly integrated into the application's Jinja template environment. This ensures that template filters can be modularized and reused within different components of the application by registering them under a chosen identifier.\n\nArgs:\n    None\n\nReturns:\n    None\n\nWhy:\n    The method verifies the mechanism for associating named template filters with blueprints so that custom rendering logic can be incorporated and accessed consistently within the templating system, facilitating cleaner and more modular template management.\n\"\"\"",
                "source_code": "bp = flask.Blueprint(\"bp\", __name__)\n\n    def my_reverse(s):\n        return s[::-1]\n\n    bp.add_app_template_filter(my_reverse, \"strrev\")\n    app.register_blueprint(bp, url_prefix=\"/py\")\n    assert \"strrev\" in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters[\"strrev\"] == my_reverse\n    assert app.jinja_env.filters[\"strrev\"](\"abcd\") == \"dcba\""
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_template_filter_with_template",
                "second_doc": "\"\"\"\nTests the registration and correct operation of a template filter within a Flask blueprint by ensuring the filter transforms template data as intended.\n\nArgs:\n    None\n\nReturns:\n    None\n\nWhy:\n    Demonstrates that custom template filters added via blueprints are correctly applied to template rendering, verifying the blueprint and template integration within the application.\n\"\"\"",
                "source_code": "bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.app_template_filter()\n    def super_reverse(s):\n        return s[::-1]\n\n    app.register_blueprint(bp, url_prefix=\"/py\")\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_filter.html\", value=\"abcd\")\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"dcba\""
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_template_filter_after_route_with_template",
                "second_doc": "\"\"\"\nTests that a template filter introduced via a blueprint is correctly applied when rendering a template, ensuring that custom filters registered after route definition are available during template rendering.\n\nArgs:\n    client: The Flask test client used to simulate HTTP requests.\n\nReturns:\n    None\n\nRaises:\n    AssertionError: If the rendered template does not apply the custom filter as expected.\n\"\"\"",
                "source_code": "@app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_filter.html\", value=\"abcd\")\n\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.app_template_filter()\n    def super_reverse(s):\n        return s[::-1]\n\n    app.register_blueprint(bp, url_prefix=\"/py\")\n    rv = client.get(\"/\")\n    assert rv.data == b\"dcba\""
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_add_template_filter_with_template",
                "second_doc": "\"\"\"\nTests that a custom template filter registered via a blueprint is correctly applied when rendering a template. \n\nArgs:\n    app: The Flask application instance.\n    client: Flask test client to issue HTTP requests.\n\nReturns:\n    None. Asserts the expected response data for verification.\n    \nThis verification ensures that templates can correctly utilize custom filters added by blueprints, maintaining extensibility and modularity of template rendering in the application.\n\"\"\"",
                "source_code": "bp = flask.Blueprint(\"bp\", __name__)\n\n    def super_reverse(s):\n        return s[::-1]\n\n    bp.add_app_template_filter(super_reverse)\n    app.register_blueprint(bp, url_prefix=\"/py\")\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_filter.html\", value=\"abcd\")\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"dcba\""
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_template_filter_with_name_and_template",
                "second_doc": "\"\"\"\nTests whether a custom template filter registered via a blueprint is correctly applied by rendering a template using the filter and verifying the output.\n\nArgs:\n    None\n\nReturns:\n    None. Asserts that the response data from the rendered template matches the expected output.\n\"\"\"",
                "source_code": "bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.app_template_filter(\"super_reverse\")\n    def my_reverse(s):\n        return s[::-1]\n\n    app.register_blueprint(bp, url_prefix=\"/py\")\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_filter.html\", value=\"abcd\")\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"dcba\""
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_add_template_filter_with_name_and_template",
                "second_doc": "\"\"\"\nTests that a custom template filter can be registered with a specific name within a blueprint, and ensures it is correctly applied when rendering a template. This allows applications to modify or extend the behavior of template rendering by injecting reusable logic.\n\nArgs:\n    None\n\nReturns:\n    None. Asserts that the rendered template output matches the expected value, indicating proper filter registration and usage.\n\"\"\"",
                "source_code": "bp = flask.Blueprint(\"bp\", __name__)\n\n    def my_reverse(s):\n        return s[::-1]\n\n    bp.add_app_template_filter(my_reverse, \"super_reverse\")\n    app.register_blueprint(bp, url_prefix=\"/py\")\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_filter.html\", value=\"abcd\")\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"dcba\""
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_template_test",
                "second_doc": "\"\"\"\nTests and demonstrates the registration of a custom Jinja template test within a Flask blueprint.\n\nThis method ensures that a custom function for evaluating whether a value is a boolean is correctly added to the template environment, enabling template logic to recognize and utilize this test.\n\nArgs:\n    None\n\nReturns:\n    None\n\nWhy:\n    Registering and verifying the availability of custom template tests allows the application to leverage advanced, reusable logic directly in templates, enhancing flexibility and maintainability in dynamic content rendering.\n\"\"\"",
                "source_code": "bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.app_template_test()\n    def is_boolean(value):\n        return isinstance(value, bool)\n\n    app.register_blueprint(bp, url_prefix=\"/py\")\n    assert \"is_boolean\" in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests[\"is_boolean\"] == is_boolean\n    assert app.jinja_env.tests[\"is_boolean\"](False)"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_add_template_test",
                "second_doc": "\"\"\"\nTests that a custom template test function can be registered with the application's Jinja environment through a blueprint, making new logic available for use within templates.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "bp = flask.Blueprint(\"bp\", __name__)\n\n    def is_boolean(value):\n        return isinstance(value, bool)\n\n    bp.add_app_template_test(is_boolean)\n    app.register_blueprint(bp, url_prefix=\"/py\")\n    assert \"is_boolean\" in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests[\"is_boolean\"] == is_boolean\n    assert app.jinja_env.tests[\"is_boolean\"](False)"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_template_test_with_name",
                "second_doc": "\"\"\"\nTests the registration and functionality of a custom Jinja template test within a Flask application by verifying that the test is added to the environment and behaves as expected.\n\nArgs:\n    None\n\nReturns:\n    None\n\nWhy:\n    This method ensures that custom template tests can be correctly registered and recognized by the Flask application's Jinja environment, confirming that template extensibility works as intended for dynamic web template logic.\n\"\"\"",
                "source_code": "bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.app_template_test(\"boolean\")\n    def is_boolean(value):\n        return isinstance(value, bool)\n\n    app.register_blueprint(bp, url_prefix=\"/py\")\n    assert \"boolean\" in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests[\"boolean\"] == is_boolean\n    assert app.jinja_env.tests[\"boolean\"](False)"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_add_template_test_with_name",
                "second_doc": "\"\"\"\nTests that a custom Jinja2 template test identified by the provided name can be added through a blueprint. This ensures templates can leverage custom logic for evaluating values, supporting flexible and reusable template design.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "bp = flask.Blueprint(\"bp\", __name__)\n\n    def is_boolean(value):\n        return isinstance(value, bool)\n\n    bp.add_app_template_test(is_boolean, \"boolean\")\n    app.register_blueprint(bp, url_prefix=\"/py\")\n    assert \"boolean\" in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests[\"boolean\"] == is_boolean\n    assert app.jinja_env.tests[\"boolean\"](False)"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_template_test_with_template",
                "second_doc": "\"\"\"\nTests whether a custom template test registered via a blueprint correctly identifies Boolean values within templates and renders the expected output.\n\nArgs:\n    None\n\nReturns:\n    None\n\nThis method ensures that custom template tests can be added and function as intended within the application's template rendering system, supporting reliable conditional logic in dynamically generated web pages.\n\"\"\"",
                "source_code": "bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.app_template_test()\n    def boolean(value):\n        return isinstance(value, bool)\n\n    app.register_blueprint(bp, url_prefix=\"/py\")\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_test.html\", value=False)\n\n    rv = client.get(\"/\")\n    assert b\"Success!\" in rv.data"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_template_test_after_route_with_template",
                "second_doc": "\"\"\"\nTests that a template test function registered via a blueprint is properly available during template rendering and correctly identifies boolean values passed to templates.\n\nArgs:\n    client: The test client used to send HTTP requests to the application.\n\nReturns:\n    None. Asserts that the rendered template includes expected output, confirming template test integration.\n\"\"\"",
                "source_code": "@app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_test.html\", value=False)\n\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.app_template_test()\n    def boolean(value):\n        return isinstance(value, bool)\n\n    app.register_blueprint(bp, url_prefix=\"/py\")\n    rv = client.get(\"/\")\n    assert b\"Success!\" in rv.data"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_add_template_test_with_template",
                "second_doc": "\"\"\"\nTests the registration and usage of a custom template test within a Flask blueprint to ensure templates can correctly utilize additional logic for value evaluation.\n\nArgs:\n    None\n\nReturns:\n    None\n\nThis method verifies that after adding a custom template test, it can successfully be used in a rendered template, confirming the application's capability to extend template functionality dynamically.\n\"\"\"",
                "source_code": "bp = flask.Blueprint(\"bp\", __name__)\n\n    def boolean(value):\n        return isinstance(value, bool)\n\n    bp.add_app_template_test(boolean)\n    app.register_blueprint(bp, url_prefix=\"/py\")\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_test.html\", value=False)\n\n    rv = client.get(\"/\")\n    assert b\"Success!\" in rv.data"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_template_test_with_name_and_template",
                "second_doc": "\"\"\"\nTests the registration and use of a custom template test within a blueprint to ensure that template logic functions as expected during request handling.\n\nArgs:\n    None\n\nReturns:\n    None\n\nWhy:\n    This method verifies that a custom template test can be added and utilized within the application's rendering process, ensuring that templates can perform specific type-checking logic and produce the intended output.\n\"\"\"",
                "source_code": "bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.app_template_test(\"boolean\")\n    def is_boolean(value):\n        return isinstance(value, bool)\n\n    app.register_blueprint(bp, url_prefix=\"/py\")\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_test.html\", value=False)\n\n    rv = client.get(\"/\")\n    assert b\"Success!\" in rv.data"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_add_template_test_with_name_and_template",
                "second_doc": "\"\"\"\nTests the registration and usage of a custom template test within a Flask blueprint to ensure template logic can utilize custom functions.\n\nArgs:\n    None\n\nReturns:\n    None\n\nThis test verifies that a custom boolean-checking function can be registered as a template test and is correctly recognized within the rendering logic, supporting more expressive and reusable template conditions.\n\"\"\"",
                "source_code": "bp = flask.Blueprint(\"bp\", __name__)\n\n    def is_boolean(value):\n        return isinstance(value, bool)\n\n    bp.add_app_template_test(is_boolean, \"boolean\")\n    app.register_blueprint(bp, url_prefix=\"/py\")\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_test.html\", value=False)\n\n    rv = client.get(\"/\")\n    assert b\"Success!\" in rv.data"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_context_processing",
                "second_doc": "\"\"\"\nTests that both global and blueprint-specific context processors successfully inject variables into Flask templates, ensuring the correct data is available in rendered views depending on the request context.\n\nArgs:\n    None\n\nReturns:\n    None\n\nWhy:\n    This test verifies that context processors at different scopes (application and blueprint) work as intended, ensuring consistent and predictable access to context variables during template rendering.\n\"\"\"",
                "source_code": "answer_bp = flask.Blueprint(\"answer_bp\", __name__)\n\n    template_string = lambda: flask.render_template_string(  # noqa: E731\n        \"{% if notanswer %}{{ notanswer }} is not the answer. {% endif %}\"\n        \"{% if answer %}{{ answer }} is the answer.{% endif %}\"\n    )\n\n    # App global context processor\n    @answer_bp.app_context_processor\n    def not_answer_context_processor():\n        return {\"notanswer\": 43}\n\n    # Blueprint local context processor\n    @answer_bp.context_processor\n    def answer_context_processor():\n        return {\"answer\": 42}\n\n    # Setup endpoints for testing\n    @answer_bp.route(\"/bp\")\n    def bp_page():\n        return template_string()\n\n    @app.route(\"/\")\n    def app_page():\n        return template_string()\n\n    # Register the blueprint\n    app.register_blueprint(answer_bp)\n\n    app_page_bytes = client.get(\"/\").data\n    answer_page_bytes = client.get(\"/bp\").data\n\n    assert b\"43\" in app_page_bytes\n    assert b\"42\" not in app_page_bytes\n\n    assert b\"42\" in answer_page_bytes\n    assert b\"43\" in answer_page_bytes"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_template_global",
                "second_doc": "\"\"\"\nTests that registering a blueprint containing a template global function successfully adds that function to the Jinja environment, making it accessible during template rendering. \n\nThis ensures that custom utility functions defined in blueprints can be made available for template logic through the app's template engine.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.app_template_global()\n    def get_answer():\n        return 42\n\n    # Make sure the function is not in the jinja_env already\n    assert \"get_answer\" not in app.jinja_env.globals.keys()\n    app.register_blueprint(bp)\n\n    # Tests\n    assert \"get_answer\" in app.jinja_env.globals.keys()\n    assert app.jinja_env.globals[\"get_answer\"] is get_answer\n    assert app.jinja_env.globals[\"get_answer\"]() == 42\n\n    with app.app_context():\n        rv = flask.render_template_string(\"{{ get_answer() }}\")\n        assert rv == \"42\""
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_request_processing",
                "second_doc": "\"\"\"\nTests the proper execution order of request lifecycle hooks\u2014before_request, after_request, and teardown_request\u2014in a blueprint, and verifies that both request processing and response modification behave as intended.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "bp = flask.Blueprint(\"bp\", __name__)\n    evts = []\n\n    @bp.before_request\n    def before_bp():\n        evts.append(\"before\")\n\n    @bp.after_request\n    def after_bp(response):\n        response.data += b\"|after\"\n        evts.append(\"after\")\n        return response\n\n    @bp.teardown_request\n    def teardown_bp(exc):\n        evts.append(\"teardown\")\n\n    # Setup routes for testing\n    @bp.route(\"/bp\")\n    def bp_endpoint():\n        return \"request\"\n\n    app.register_blueprint(bp)\n\n    assert evts == []\n    rv = client.get(\"/bp\")\n    assert rv.data == b\"request|after\"\n    assert evts == [\"before\", \"after\", \"teardown\"]"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_app_request_processing",
                "second_doc": "\"\"\"\nTests that lifecycle hooks for handling the first request, all requests, responses, and teardown events are executed in the correct order for a registered blueprint and affect the request/response cycle as intended.\n\nArgs:\n    app: The Flask application instance to which the blueprint is registered.\n    client: Flask test client used to simulate HTTP requests.\n\nReturns:\n    None\n\nWhy:\n    Ensures that the application's blueprint-level hooks properly manage resource allocation, cleanup, and response modification throughout the request lifecycle, which is essential for reliable web application behavior.\n\"\"\"",
                "source_code": "bp = flask.Blueprint(\"bp\", __name__)\n    evts = []\n\n    @bp.before_app_first_request\n    def before_first_request():\n        evts.append(\"first\")\n\n    @bp.before_app_request\n    def before_app():\n        evts.append(\"before\")\n\n    @bp.after_app_request\n    def after_app(response):\n        response.data += b\"|after\"\n        evts.append(\"after\")\n        return response\n\n    @bp.teardown_app_request\n    def teardown_app(exc):\n        evts.append(\"teardown\")\n\n    app.register_blueprint(bp)\n\n    # Setup routes for testing\n    @app.route(\"/\")\n    def bp_endpoint():\n        return \"request\"\n\n    # before first request\n    assert evts == []\n\n    # first request\n    resp = client.get(\"/\").data\n    assert resp == b\"request|after\"\n    assert evts == [\"first\", \"before\", \"after\", \"teardown\"]\n\n    # second request\n    resp = client.get(\"/\").data\n    assert resp == b\"request|after\"\n    assert evts == [\"first\"] + [\"before\", \"after\", \"teardown\"] * 2"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_app_url_processors",
                "second_doc": "\"\"\"\nTests the integration and effectiveness of application-wide URL value processors in managing language code parameters within route handling.\n\nArgs:\n    None\n\nReturns:\n    None\n\nWhy:\n    Ensures that language codes are consistently included in URLs and correctly propagated throughout route handlers, verifying that URL defaults and preprocessors work together to maintain context-specific request information.\n\"\"\"",
                "source_code": "bp = flask.Blueprint(\"bp\", __name__)\n\n    # Register app-wide url defaults and preprocessor on blueprint\n    @bp.app_url_defaults\n    def add_language_code(endpoint, values):\n        values.setdefault(\"lang_code\", flask.g.lang_code)\n\n    @bp.app_url_value_preprocessor\n    def pull_lang_code(endpoint, values):\n        flask.g.lang_code = values.pop(\"lang_code\")\n\n    # Register route rules at the app level\n    @app.route(\"/<lang_code>/\")\n    def index():\n        return flask.url_for(\"about\")\n\n    @app.route(\"/<lang_code>/about\")\n    def about():\n        return flask.url_for(\"index\")\n\n    app.register_blueprint(bp)\n\n    assert client.get(\"/de/\").data == b\"/de/about\"\n    assert client.get(\"/de/about\").data == b\"/de/\""
            },
            "type": "function"
        }
    ],
    "flask/tests/test_cli.py": [
        {
            "details": {
                "docstring": null,
                "method_name": "runner",
                "second_doc": "\"\"\"\nCreates and returns an instance of the command-line interface runner used for testing CLI applications.\n\nThis method allows developers to simulate command-line invocations and capture their outcomes in a controlled environment, facilitating robust testing of application command interfaces.\n\nReturns:\n    CliRunner: An instance of the test runner for command-line interface commands.\n\"\"\"",
                "source_code": "return CliRunner()"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": "\"\"\"Make sure the CLI object's name is the app's name and not the app itself\"\"\"",
                "first_doc": "\"\"\"\nVerifies that the CLI application's name matches the expected test application name.\n\nArgs:\n    test_apps: The collection of test applications to use for validation.\n\nReturns:\n    None. This method performs an assertion and does not return a value.\n\"\"\"",
                "method_name": "test_cli_name",
                "second_doc": "\"\"\"\nChecks that the name assigned to the CLI representation of the application is consistent with the core application name, ensuring correct identification within the application's interface system.\n\nArgs:\n    test_apps: The collection of test applications to use for validation.\n\nReturns:\n    None: This method performs an assertion to enforce naming consistency and does not return a value.\n\"\"\"",
                "source_code": "from cliapp.app import testapp\n\n    assert testapp.cli.name == testapp.name"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": "\"\"\"Test if `find_best_app` behaves as expected with different combinations of input.\"\"\"",
                "first_doc": "\"\"\"\nTests the logic for correctly discovering the best Flask application instance or factory in a variety of Module classes.\n\nArgs:\n    test_apps: Fixture or helper used to manage or provide application modules for testing.\n\nReturns:\n    None. This method performs assertions to validate the correct behavior of the app discovery utility.\n\"\"\"",
                "method_name": "test_find_best_app",
                "second_doc": "\"\"\"\nVerifies that the mechanism for locating the most appropriate Flask application instance or factory within various module class patterns is robust and reliable. By covering common scenarios for how applications may be structured, this test ensures consistency and usability across diverse code organizations.\n\nArgs:\n    test_apps: Fixture or helper used to manage or provide application modules for testing.\n\nReturns:\n    None. This method executes assertions to check that the app discovery utility identifies or raises exceptions correctly, contributing to dependable application startup and management.\n\"\"\"",
                "source_code": "script_info = ScriptInfo()\n\n    class Module:\n        app = Flask(\"appname\")\n\n    assert find_best_app(script_info, Module) == Module.app\n\n    class Module:\n        application = Flask(\"appname\")\n\n    assert find_best_app(script_info, Module) == Module.application\n\n    class Module:\n        myapp = Flask(\"appname\")\n\n    assert find_best_app(script_info, Module) == Module.myapp\n\n    class Module:\n        @staticmethod\n        def create_app():\n            return Flask(\"appname\")\n\n    app = find_best_app(script_info, Module)\n    assert isinstance(app, Flask)\n    assert app.name == \"appname\"\n\n    class Module:\n        @staticmethod\n        def create_app(foo):\n            return Flask(\"appname\")\n\n    with pytest.deprecated_call(match=\"Script info\"):\n        app = find_best_app(script_info, Module)\n\n    assert isinstance(app, Flask)\n    assert app.name == \"appname\"\n\n    class Module:\n        @staticmethod\n        def create_app(foo=None, script_info=None):\n            return Flask(\"appname\")\n\n    with pytest.deprecated_call(match=\"script_info\"):\n        app = find_best_app(script_info, Module)\n\n    assert isinstance(app, Flask)\n    assert app.name == \"appname\"\n\n    class Module:\n        @staticmethod\n        def make_app():\n            return Flask(\"appname\")\n\n    app = find_best_app(script_info, Module)\n    assert isinstance(app, Flask)\n    assert app.name == \"appname\"\n\n    class Module:\n        myapp = Flask(\"appname1\")\n\n        @staticmethod\n        def create_app():\n            return Flask(\"appname2\")\n\n    assert find_best_app(script_info, Module) == Module.myapp\n\n    class Module:\n        myapp = Flask(\"appname1\")\n\n        @staticmethod\n        def create_app():\n            return Flask(\"appname2\")\n\n    assert find_best_app(script_info, Module) == Module.myapp\n\n    class Module:\n        pass\n\n    pytest.raises(NoAppException, find_best_app, script_info, Module)\n\n    class Module:\n        myapp1 = Flask(\"appname1\")\n        myapp2 = Flask(\"appname2\")\n\n    pytest.raises(NoAppException, find_best_app, script_info, Module)\n\n    class Module:\n        @staticmethod\n        def create_app(foo, bar):\n            return Flask(\"appname2\")\n\n    pytest.raises(NoAppException, find_best_app, script_info, Module)\n\n    class Module:\n        @staticmethod\n        def create_app():\n            raise TypeError(\"bad bad factory!\")\n\n    pytest.raises(TypeError, find_best_app, script_info, Module)"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": "\"\"\"Expect the correct path to be set and the correct import and app names\n    to be returned.\n\n    :func:`prepare_exec_for_file` has a side effect where the parent directory\n    of the given import is added to :data:`sys.path`. This is reset after the\n    test runs.\n    \"\"\"",
                "first_doc": "\"\"\"\nTests the prepare_import function with various file path and module name scenarios.\n\nArgs:\n    request: A pytest fixture object used to add a finalizer that restores the sys.path after the test.\n    value: The source value representing a file path or a dotted module name to be processed.\n    path: The expected sys.path[0] value after prepare_import is called, representing the calculated root path for importing.\n    result: The expected return value from prepare_import, representing the module or package name.\n\nReturns:\n    None: This test method does not return a value but asserts correctness of prepare_import and sys.path modifications.\n\"\"\"",
                "method_name": "test_prepare_import",
                "second_doc": "\"\"\"\nVerifies that prepare_import correctly interprets various file paths and module names, ensuring they are resolved for Python import and that sys.path is set appropriately for dynamic loading. By systematically testing different import value scenarios, it helps to guarantee robust handling of module discovery and loading mechanisms.\n\nArgs:\n    request: A pytest fixture object that registers a cleanup function to restore sys.path after the test completes.\n    value: The input string representing a file path or dotted module name to be processed for import.\n    path: The expected sys.path[0] value after execution, indicating the calculated root directory for importing.\n    result: The expected return value from prepare_import, representing the resolved module or package name.\n\nReturns:\n    None: This is a test function that asserts the behavior of prepare_import and sys.path manipulation rather than returning a value.\n\"\"\"",
                "source_code": "original_path = sys.path[:]\n\n    def reset_path():\n        sys.path[:] = original_path\n\n    request.addfinalizer(reset_path)\n\n    assert prepare_import(value) == result\n    assert sys.path[0] == path"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_locate_app",
                "second_doc": "\"\"\"\nTests various input scenarios for the locate_app function to ensure that applications can be correctly identified and loaded regardless of different module and function name formats.\n\nArgs:\n    iname (str): The import path or factory location where the application is defined.\n    aname (str or None): The explicit application name or callable signature provided.\n    result (str): The expected name of the loaded application instance.\n\nReturns:\n    None. Asserts that the application's loaded name matches the expected result for each parameterization.\n\nWhy:\n    Verifying correct detection and instantiation of application objects is crucial to automate and streamline the application's discovery and loading process, which affects usability and developer experience during development and testing.\n\"\"\"",
                "source_code": "info = ScriptInfo()\n    assert locate_app(info, iname, aname).name == result"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_locate_app_raises",
                "second_doc": "\"\"\"\nTests that the application location utility correctly raises a NoAppException when provided with invalid or malformed import and app names.\n\nThis ensures robust error handling for common misconfigurations or user mistakes, preventing ambiguous failures during application discovery.\n\nArgs:\n    iname (str): The import path or file name to locate as a potential application.\n    aname (str or None): The attribute or factory function name within the module to use as the app instance.\n\nReturns:\n    None: This test verifies exception raising; it does not return a value.\n\"\"\"",
                "source_code": "info = ScriptInfo()\n\n    with pytest.raises(NoAppException):\n        locate_app(info, iname, aname)"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_locate_app_suppress_raise",
                "second_doc": "\"\"\"\nTests that the application locator function returns None instead of raising an exception when an app cannot be found and raise_if_not_found is set to False, but still raises exceptions for underlying import errors. This ensures the locator can distinguish between an app genuinely not existing and errors caused by faulty app code, supporting resilient app discovery.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "info = ScriptInfo()\n    app = locate_app(info, \"notanapp.py\", None, raise_if_not_found=False)\n    assert app is None\n\n    # only direct import error is suppressed\n    with pytest.raises(NoAppException):\n        locate_app(info, \"cliapp.importerrorapp\", None, raise_if_not_found=False)"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_get_version",
                "second_doc": "\"\"\"\nTests whether the version information for Python, Flask, and Werkzeug is correctly displayed when requested during command-line interactions.\n\nArgs:\n    capsys: Pytest fixture to capture output streams during the test.\n\nReturns:\n    None. Asserts that the output includes the expected version strings for Python, Flask, and Werkzeug.\n\nWhy:\n    Ensures that users and developers can reliably check environment and framework versions, which is essential for debugging, compatibility checks, and support.\n\"\"\"",
                "source_code": "from flask import __version__ as flask_version\n    from werkzeug import __version__ as werkzeug_version\n    from platform import python_version\n\n    class MockCtx:\n        resilient_parsing = False\n        color = None\n\n        def exit(self):\n            return\n\n    ctx = MockCtx()\n    get_version(ctx, None, \"test\")\n    out, err = capsys.readouterr()\n    assert f\"Python {python_version()}\" in out\n    assert f\"Flask {flask_version}\" in out\n    assert f\"Werkzeug {werkzeug_version}\" in out"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": "\"\"\"Test of ScriptInfo.\"\"\"",
                "first_doc": "\"\"\"\nTest the ScriptInfo utility for loading applications in various ways.\n\nThis method verifies the behavior of the ScriptInfo class when importing applications with different app import paths, using a factory function, and when no import path is provided. It also tests application loading from different working directories.\n\nArgs:\n    test_apps: Directory path containing test application files.\n    monkeypatch: Pytest fixture used to safely change the current working directory during testing.\n\nReturns:\n    None: This method only asserts conditions and does not return a value.\n\"\"\"",
                "method_name": "test_scriptinfo",
                "second_doc": "\"\"\"\nComprehensively tests the ScriptInfo utility's ability to locate and load WSGI application instances from a variety of import paths and configurations.\n\nBy exercising different means of specifying application locations\u2014including explicit module paths, factory functions, and presence of app files in the current working directory\u2014this method confirms that ScriptInfo correctly discovers and initializes the target application, behaving consistently under different scenarios. This ensures reliable management of application objects in projects that may have diverse project layouts or initialization methods.\n\nArgs:\n    test_apps (str): Directory path containing various test application files.\n    monkeypatch (pytest.MonkeyPatch): Pytest fixture used to temporarily modify the current working directory during execution.\n\nReturns:\n    None: Performs assertions to validate behavior but does not return any value.\n\"\"\"",
                "source_code": "obj = ScriptInfo(app_import_path=\"cliapp.app:testapp\")\n    app = obj.load_app()\n    assert app.name == \"testapp\"\n    assert obj.load_app() is app\n\n    # import app with module's absolute path\n    cli_app_path = os.path.abspath(\n        os.path.join(os.path.dirname(__file__), \"test_apps\", \"cliapp\", \"app.py\")\n    )\n    obj = ScriptInfo(app_import_path=cli_app_path)\n    app = obj.load_app()\n    assert app.name == \"testapp\"\n    assert obj.load_app() is app\n    obj = ScriptInfo(app_import_path=f\"{cli_app_path}:testapp\")\n    app = obj.load_app()\n    assert app.name == \"testapp\"\n    assert obj.load_app() is app\n\n    def create_app():\n        return Flask(\"createapp\")\n\n    obj = ScriptInfo(create_app=create_app)\n    app = obj.load_app()\n    assert app.name == \"createapp\"\n    assert obj.load_app() is app\n\n    obj = ScriptInfo()\n    pytest.raises(NoAppException, obj.load_app)\n\n    # import app from wsgi.py in current directory\n    monkeypatch.chdir(\n        os.path.abspath(\n            os.path.join(os.path.dirname(__file__), \"test_apps\", \"helloworld\")\n        )\n    )\n    obj = ScriptInfo()\n    app = obj.load_app()\n    assert app.name == \"hello\"\n\n    # import app from app.py in current directory\n    monkeypatch.chdir(\n        os.path.abspath(os.path.join(os.path.dirname(__file__), \"test_apps\", \"cliapp\"))\n    )\n    obj = ScriptInfo()\n    app = obj.load_app()\n    assert app.name == \"testapp\""
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": "\"\"\"Test of with_appcontext.\"\"\"",
                "first_doc": "\"\"\"\nTests invoking a Click command with Flask's application context using a test runner.\n\nArgs:\n    runner: The Click test runner used to invoke the command.\n\nReturns:\n    None: This method performs assertions and does not return a value.\n\"\"\"",
                "method_name": "test_with_appcontext",
                "second_doc": "\"\"\"\nVerifies that a Click command utilizing Flask's application context operates correctly when invoked through the test runner. This ensures that application-specific context resources are properly initialized and accessible within custom CLI commands, supporting reliable command-line tool development and testing.\n\nArgs:\n    runner: The Click test runner used to invoke the command, providing an interface for simulating CLI invocations in a controlled test environment.\n\nReturns:\n    None: Performs assertions to validate command execution and output; does not return a value.\n\"\"\"",
                "source_code": "@click.command()\n    @with_appcontext\n    def testcmd():\n        click.echo(current_app.name)\n\n    obj = ScriptInfo(create_app=lambda: Flask(\"testapp\"))\n\n    result = runner.invoke(testcmd, obj=obj)\n    assert result.exit_code == 0\n    assert result.output == \"testapp\\n\""
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": "\"\"\"Test of with_appcontext.\"\"\"",
                "first_doc": "\"\"\"\nTests the functionality of command groups and subgroups in a Click CLI application using Flask.\n\nArgs:\n    runner: The test runner used to invoke CLI commands.\n\nReturns:\n    None: This method performs assertions to validate CLI command output and does not return a value.\n\"\"\"",
                "method_name": "test_appgroup",
                "second_doc": "\"\"\"\nValidates that CLI command groups and subcommands correctly access and respond with the current application's context.\n\nArgs:\n    runner: The CLI test runner used to invoke commands within an application context.\n\nReturns:\n    None: Executes assertions on command output; does not return a value.\n\nWhy:\n    Ensures that command grouping and application context propagation function as expected, allowing commands and subcommands to reliably interact with the application's state during CLI operations.\n\"\"\"",
                "source_code": "@click.group(cls=AppGroup)\n    def cli():\n        pass\n\n    @cli.command(with_appcontext=True)\n    def test():\n        click.echo(current_app.name)\n\n    @cli.group()\n    def subgroup():\n        pass\n\n    @subgroup.command(with_appcontext=True)\n    def test2():\n        click.echo(current_app.name)\n\n    obj = ScriptInfo(create_app=lambda: Flask(\"testappgroup\"))\n\n    result = runner.invoke(cli, [\"test\"], obj=obj)\n    assert result.exit_code == 0\n    assert result.output == \"testappgroup\\n\"\n\n    result = runner.invoke(cli, [\"subgroup\", \"test2\"], obj=obj)\n    assert result.exit_code == 0\n    assert result.output == \"testappgroup\\n\""
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": "\"\"\"Test FlaskGroup.\"\"\"",
                "first_doc": "\"\"\"\nTests the 'test' command in a Flask application CLI group.\n\nArgs:\n    runner: A Click test runner object used to invoke CLI commands.\n\nReturns:\n    None: This method does not return any value. It asserts that the 'test' command outputs the expected app name and exits with code 0.\n\"\"\"",
                "method_name": "test_flaskgroup",
                "second_doc": "\"\"\"\nVerifies that the custom CLI command correctly accesses and outputs the current application context name when invoked, ensuring CLI integration and application context management are functioning as expected.\n\nArgs:\n    runner: A Click test runner object used to invoke CLI commands in a testing environment.\n\nReturns:\n    None: This function performs assertions to confirm the command's output and exit code, and does not return a value.\n\"\"\"",
                "source_code": "def create_app():\n        return Flask(\"flaskgroup\")\n\n    @click.group(cls=FlaskGroup, create_app=create_app)\n    def cli(**params):\n        pass\n\n    @cli.command()\n    def test():\n        click.echo(current_app.name)\n\n    result = runner.invoke(cli, [\"test\"])\n    assert result.exit_code == 0\n    assert result.output == \"flaskgroup\\n\""
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": "\"\"\"Test FlaskGroup debug flag behavior.\"\"\"",
                "first_doc": "\"\"\"\nTests the debug flag behavior of a Flask app created with FlaskGroup and click integration.\n\nArgs:\n    runner: The Click test runner used for invoking the CLI commands.\n    set_debug_flag: Indicates whether the debug flag should be set to True or False when initializing the FlaskGroup.\n\nReturns:\n    None. The function performs assertions to verify the expected debug mode output and raises an error if the test fails.\n\"\"\"",
                "method_name": "test_flaskgroup_debug",
                "second_doc": "\"\"\"\nVerifies that the Flask application correctly toggles its debug mode based on the set_debug_flag parameter when utilizing command-line execution through FlaskGroup and Click. This ensures the application\u2019s behavior aligns with configuration expectations during development and testing, fostering predictable outcomes for command-line driven workflows.\n\nArgs:\n    runner: A Click testing runner responsible for executing CLI commands within the test context.\n    set_debug_flag: A boolean value indicating whether the debug flag should be enforced during FlaskGroup initialization.\n\nReturns:\n    None. The function asserts the expected debug mode output and fails the test if the application's debug state does not match the intended state based on set_debug_flag.\n\"\"\"",
                "source_code": "def create_app():\n        app = Flask(\"flaskgroup\")\n        app.debug = True\n        return app\n\n    @click.group(cls=FlaskGroup, create_app=create_app, set_debug_flag=set_debug_flag)\n    def cli(**params):\n        pass\n\n    @cli.command()\n    def test():\n        click.echo(str(current_app.debug))\n\n    result = runner.invoke(cli, [\"test\"])\n    assert result.exit_code == 0\n    assert result.output == f\"{not set_debug_flag}\\n\""
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": "\"\"\"Print the stacktrace if the CLI.\"\"\"",
                "first_doc": "\"\"\"\nTests that exceptions raised within a Flask app creation function are properly printed in the CLI output.\n\nArgs:\n    runner: A test runner instance used to invoke the CLI command and capture its output.\n\nReturns:\n    None: This method does not return a value.\n\"\"\"",
                "method_name": "test_print_exceptions",
                "second_doc": "\"\"\"\nVerifies that when an exception occurs during the initialization of an application through the CLI, the resulting error and traceback are clearly displayed in the command-line output. This ensures that errors encountered during setup are both visible and informative for users running the CLI.\n\nArgs:\n    runner: A test runner instance used to execute the CLI command and capture the console output.\n\nReturns:\n    None: This method performs assertions to validate CLI output but does not return a value.\n\"\"\"",
                "source_code": "def create_app():\n        raise Exception(\"oh no\")\n        return Flask(\"flaskgroup\")\n\n    @click.group(cls=FlaskGroup, create_app=create_app)\n    def cli(**params):\n        pass\n\n    result = runner.invoke(cli, [\"--help\"])\n    assert result.exit_code == 0\n    assert \"Exception: oh no\" in result.output\n    assert \"Traceback\" in result.output"
            },
            "type": "function"
        },
        {
            "methods": [
                {
                    "docstring": null,
                    "method_name": "invoke",
                    "second_doc": "\"\"\"\nProvides a partial function for invoking CLI commands with a Flask application preconfigured for testing, enabling the simulation and automation of command-line interactions in a controlled test environment.\n\nArgs:\n    None\n\nReturns:\n    function: A partial function that, when called, invokes commands against the Flask application's CLI group, facilitating automated testing of CLI behavior.\n\"\"\"",
                    "source_code": "def create_app():\n            app = Flask(__name__)\n            app.testing = True\n\n            @app.route(\"/get_post/<int:x>/<int:y>\", methods=[\"GET\", \"POST\"])\n            def yyy_get_post(x, y):\n                pass\n\n            @app.route(\"/zzz_post\", methods=[\"POST\"])\n            def aaa_post():\n                pass\n\n            return app\n\n        cli = FlaskGroup(create_app=create_app)\n        return partial(runner.invoke, cli)"
                },
                {
                    "docstring": null,
                    "method_name": "invoke_no_routes",
                    "second_doc": "\"\"\"\nSets up a minimal Flask application without registering any routes and returns a callable for command-line interface interactions.\n\nArgs:\n    None\n\nReturns:\n    functools.partial: A partial function that can be used to invoke the Flask CLI with the custom application context for testing or automation purposes.\n\nWhy:\n    This method establishes a controlled test environment by creating a bare Flask app and associating it with CLI functionality, enabling automated command-line testing and script integration without any defined web routes.\n\"\"\"",
                    "source_code": "def create_app():\n            app = Flask(__name__, static_folder=None)\n            app.testing = True\n\n            return app\n\n        cli = FlaskGroup(create_app=create_app)\n        return partial(runner.invoke, cli)"
                },
                {
                    "docstring": null,
                    "method_name": "expect_order",
                    "second_doc": "\"\"\"\nAsserts that the lines of output match the expected order, comparing each line according to the specified expectations for test validation.\n\nArgs:\n    order (list of str): The expected sequence of prefixes or patterns for the output lines.\n    output (str): The complete multi-line output string to be validated, where the first two lines are ignored.\n\nReturns:\n    None. The function raises an AssertionError if any line in the output does not match the expected pattern, thereby ensuring test accuracy.\n    \nWhy:\n    This method ensures that program outputs adhere strictly to an anticipated structure, which is critical for reliable automated tests and consistent behavior.\n\"\"\"",
                    "source_code": "for expect, line in zip(order, output.splitlines()[2:]):\n            # do this instead of startswith for nicer pytest output\n            assert line[: len(expect)] == expect"
                },
                {
                    "docstring": null,
                    "method_name": "test_simple",
                    "second_doc": "\"\"\"\nTests that the 'routes' command produces output listing routes in the expected order and completes successfully.\n\nThis ensures that route definitions are detected and presented correctly, which helps maintain the reliability of route management during development and testing.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                    "source_code": "result = invoke([\"routes\"])\n        assert result.exit_code == 0\n        self.expect_order([\"aaa_post\", \"static\", \"yyy_get_post\"], result.output)"
                },
                {
                    "docstring": null,
                    "method_name": "test_sort",
                    "second_doc": "\"\"\"\nTests that route listings can be sorted using different criteria, ensuring the output order matches expectations for method, rule, and match sorting options.\n\nArgs:\n    None\n\nReturns:\n    None\n\nWhy:\n    Ensuring proper route sorting verifies the correctness and reliability of route management and introspection features, which are important for developers to efficiently understand and maintain application behavior.\n\"\"\"",
                    "source_code": "default_output = invoke([\"routes\"]).output\n        endpoint_output = invoke([\"routes\", \"-s\", \"endpoint\"]).output\n        assert default_output == endpoint_output\n        self.expect_order(\n            [\"static\", \"yyy_get_post\", \"aaa_post\"],\n            invoke([\"routes\", \"-s\", \"methods\"]).output,\n        )\n        self.expect_order(\n            [\"yyy_get_post\", \"static\", \"aaa_post\"],\n            invoke([\"routes\", \"-s\", \"rule\"]).output,\n        )\n        self.expect_order(\n            [\"aaa_post\", \"yyy_get_post\", \"static\"],\n            invoke([\"routes\", \"-s\", \"match\"]).output,\n        )"
                },
                {
                    "docstring": null,
                    "method_name": "test_all_methods",
                    "second_doc": "\"\"\"\nTests the command-line argument that controls the display of all supported HTTP methods for application routes.\n\nThis method verifies that, by default, not all HTTP methods are shown in the output when listing routes via the CLI, but that including the '--all-methods' flag displays every supported method. This ensures that route inspection tools provide concise information unless a comprehensive view is specifically requested.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                    "source_code": "output = invoke([\"routes\"]).output\n        assert \"GET, HEAD, OPTIONS, POST\" not in output\n        output = invoke([\"routes\", \"--all-methods\"]).output\n        assert \"GET, HEAD, OPTIONS, POST\" in output"
                },
                {
                    "docstring": null,
                    "method_name": "test_no_routes",
                    "second_doc": "\"\"\"\nTests that the application correctly reports when no routes have been registered. This ensures that the routing mechanism provides accurate feedback to the user in situations where the route table is empty.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                    "source_code": "result = invoke_no_routes([\"routes\"])\n        assert result.exit_code == 0\n        assert \"No routes were registered.\" in result.output"
                }
            ],
            "name": "TestRoutes",
            "type": "class"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_load_dotenv",
                "second_doc": "\"\"\"\nTests that environment variables from configuration files are correctly loaded into the application context, according to a defined precedence, and ensures manual environment variable settings take priority over those from the files. This helps verify that the application's environment management behaves as expected when dealing with default values, overrides, and missing files.\n\nArgs:\n    monkeypatch: pytest's monkeypatch fixture used to manipulate environment variables and working directory.\n    test_path: The path to the test directory used for simulating different environment setups.\n\nReturns:\n    None\n\"\"\"",
                "source_code": "for item in (\"FOO\", \"BAR\", \"SPAM\"):\n        monkeypatch._setitem.append((os.environ, item, notset))\n\n    monkeypatch.setenv(\"EGGS\", \"3\")\n    monkeypatch.chdir(os.path.join(test_path, \"cliapp\", \"inner1\"))\n    assert load_dotenv()\n    assert os.getcwd() == test_path\n    # .flaskenv doesn't overwrite .env\n    assert os.environ[\"FOO\"] == \"env\"\n    # set only in .flaskenv\n    assert os.environ[\"BAR\"] == \"bar\"\n    # set only in .env\n    assert os.environ[\"SPAM\"] == \"1\"\n    # set manually, files don't overwrite\n    assert os.environ[\"EGGS\"] == \"3\"\n\n    # Non existent file should not load\n    assert not load_dotenv(\"non-existent-file\")"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_dotenv_path",
                "second_doc": "\"\"\"\nTests that environment variables from a dotenv file are correctly loaded into the environment without altering the current working directory. \n\nThis ensures that configuration values can be seamlessly injected from external files while maintaining application stability across different runtime contexts.\n\nArgs:\n    monkeypatch: pytest fixture for safely modifying or restoring environment variables during the test.\n    test_path: Path to the directory containing the dotenv file to be loaded.\n    notset: Sentinel value for unsetting or resetting environment variables.\n\nReturns:\n    None\n\nRaises:\n    AssertionError: If the working directory changes unexpectedly or if expected environment variables are missing after loading the dotenv file.\n\"\"\"",
                "source_code": "for item in (\"FOO\", \"BAR\", \"EGGS\"):\n        monkeypatch._setitem.append((os.environ, item, notset))\n\n    cwd = os.getcwd()\n    load_dotenv(os.path.join(test_path, \".flaskenv\"))\n    assert os.getcwd() == cwd\n    assert \"FOO\" in os.environ"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_dotenv_optional",
                "second_doc": "\"\"\"\nTests that loading environment variables from a .env file is optional by disabling dotenv support and verifying that the environment remains unchanged. This ensures Flask's configuration handling is robust even when .env support is not available.\n\nArgs:\n    monkeypatch: pytest fixture used to modify environment and working directory for the test context.\n\nReturns:\n    None. Asserts that a specific environment variable is not set when dotenv support is disabled.\n\"\"\"",
                "source_code": "monkeypatch.setattr(\"flask.cli.dotenv\", None)\n    monkeypatch.chdir(test_path)\n    load_dotenv()\n    assert \"FOO\" not in os.environ"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_disable_dotenv_from_env",
                "second_doc": "\"\"\"\nTests that setting the \"FLASK_SKIP_DOTENV\" environment variable disables automatic loading of environment variables from a .env file via Flask. This ensures that the application's configuration can be controlled explicitly by preventing unintended variable overrides when needed.\n\nArgs:\n    monkeypatch: pytest's monkeypatch fixture used to modify the environment and working directory.\n    test_path: Path to the test directory containing the .env file.\n\nReturns:\n    None. Asserts that the \"FOO\" variable is not present in the process environment, confirming .env file was skipped.\n\"\"\"",
                "source_code": "monkeypatch.chdir(test_path)\n    monkeypatch.setitem(os.environ, \"FLASK_SKIP_DOTENV\", \"1\")\n    runner.invoke(FlaskGroup())\n    assert \"FOO\" not in os.environ"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_run_cert_path",
                "second_doc": "\"\"\"\nTest that the CLI command correctly validates certificate and key file arguments, ensuring that both are required together and properly stored in parameters.\n\nArgs:\n    None\n\nReturns:\n    None\n\nWhy:\n    Verifies robust input validation for secure server command-line options, preventing misconfiguration by requiring both certificate and key files when launching the server with SSL/TLS security.\n\"\"\"",
                "source_code": "with pytest.raises(click.BadParameter):\n        run_command.make_context(\"run\", [\"--cert\", __file__])\n\n    # no cert\n    with pytest.raises(click.BadParameter):\n        run_command.make_context(\"run\", [\"--key\", __file__])\n\n    ctx = run_command.make_context(\"run\", [\"--cert\", __file__, \"--key\", __file__])\n    assert ctx.params[\"cert\"] == (__file__, __file__)"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_run_cert_adhoc",
                "second_doc": "\"\"\"\nTests the behavior of the run command when using the \"--cert adhoc\" option under different conditions, such as whether the 'cryptography' module is installed and when additional certificate parameters are provided.\n\nThis method simulates environments where SSL certificate generation relies on optional dependencies and checks the system\u2019s response to missing modules or conflicting arguments to ensure robust error handling and proper parameter assignment.\n\nArgs:\n    monkeypatch: pytest fixture that allows dynamic modification of modules and environments during the test.\n\nReturns:\n    None\n\"\"\"",
                "source_code": "monkeypatch.setitem(sys.modules, \"cryptography\", None)\n\n    # cryptography not installed\n    with pytest.raises(click.BadParameter):\n        run_command.make_context(\"run\", [\"--cert\", \"adhoc\"])\n\n    # cryptography installed\n    monkeypatch.setitem(sys.modules, \"cryptography\", types.ModuleType(\"cryptography\"))\n    ctx = run_command.make_context(\"run\", [\"--cert\", \"adhoc\"])\n    assert ctx.params[\"cert\"] == \"adhoc\"\n\n    # no key with adhoc\n    with pytest.raises(click.BadParameter):\n        run_command.make_context(\"run\", [\"--cert\", \"adhoc\", \"--key\", __file__])"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_run_cert_import",
                "second_doc": "\"\"\"\nTests the behavior of the certificate import logic in the command-line runner by verifying correct handling of import failures, valid/invalid SSLContext usage, and conflicting options. This ensures that certificate arguments are processed robustly for secure server operation.\n\nArgs:\n    monkeypatch: Pytest fixture used to modify sys.modules for simulating different import scenarios.\n\nReturns:\n    None. The function asserts correct exception raising or parameter assignment to validate command-line argument parsing and error handling logic.\n\"\"\"",
                "source_code": "monkeypatch.setitem(sys.modules, \"not_here\", None)\n\n    # ImportError\n    with pytest.raises(click.BadParameter):\n        run_command.make_context(\"run\", [\"--cert\", \"not_here\"])\n\n    with pytest.raises(click.BadParameter):\n        run_command.make_context(\"run\", [\"--cert\", \"flask\"])\n\n    # SSLContext\n    ssl_context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)\n\n    monkeypatch.setitem(sys.modules, \"ssl_context\", ssl_context)\n    ctx = run_command.make_context(\"run\", [\"--cert\", \"ssl_context\"])\n    assert ctx.params[\"cert\"] is ssl_context\n\n    # no --key with SSLContext\n    with pytest.raises(click.BadParameter):\n        run_command.make_context(\"run\", [\"--cert\", \"ssl_context\", \"--key\", __file__])"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_run_cert_no_ssl",
                "second_doc": "\"\"\"\nTests that providing a certificate file without SSL support in the CLI raises the appropriate error.\n\nThis method ensures robust CLI error handling when attempting to use SSL certificate options without the necessary SSL feature, maintaining clarity and preventing misconfiguration.\n\nArgs:\n    monkeypatch: pytest's fixture used to modify or replace attributes for the duration of the test.\n\nReturns:\n    None. The function asserts that a click.BadParameter exception is raised.\n\"\"\"",
                "source_code": "monkeypatch.setattr(\"flask.cli.ssl\", None)\n    with pytest.raises(click.BadParameter):\n        run_command.make_context(\"run\", [\"--cert\", \"not_here\"])"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": "\"\"\"Test blueprint commands register correctly to the application\"\"\"",
                "first_doc": "\"\"\"\nTests the registration and CLI command execution for multiple Flask blueprints with various CLI group configurations.\n\nArgs:\n    app: The Flask application instance used to register blueprints and execute CLI commands.\n\nReturns:\n    None: This method returns nothing. It performs assertions to verify correct CLI command registration and execution for each blueprint.\n\"\"\"",
                "method_name": "test_cli_blueprints",
                "second_doc": "\"\"\"\nValidates that registering multiple Flask blueprints with different CLI group configurations allows their CLI commands to be correctly recognized and executed through the application's command-line interface.\n\nArgs:\n    app: The Flask application instance on which the blueprints are registered and CLI commands are executed.\n\nReturns:\n    None: Performs assertions to ensure that command-line commands associated with each blueprint execute and output the expected results, confirming correct CLI group behavior.\n\"\"\"",
                "source_code": "custom = Blueprint(\"custom\", __name__, cli_group=\"customized\")\n    nested = Blueprint(\"nested\", __name__)\n    merged = Blueprint(\"merged\", __name__, cli_group=None)\n    late = Blueprint(\"late\", __name__)\n\n    @custom.cli.command(\"custom\")\n    def custom_command():\n        click.echo(\"custom_result\")\n\n    @nested.cli.command(\"nested\")\n    def nested_command():\n        click.echo(\"nested_result\")\n\n    @merged.cli.command(\"merged\")\n    def merged_command():\n        click.echo(\"merged_result\")\n\n    @late.cli.command(\"late\")\n    def late_command():\n        click.echo(\"late_result\")\n\n    app.register_blueprint(custom)\n    app.register_blueprint(nested)\n    app.register_blueprint(merged)\n    app.register_blueprint(late, cli_group=\"late_registration\")\n\n    app_runner = app.test_cli_runner()\n\n    result = app_runner.invoke(args=[\"customized\", \"custom\"])\n    assert \"custom_result\" in result.output\n\n    result = app_runner.invoke(args=[\"nested\", \"nested\"])\n    assert \"nested_result\" in result.output\n\n    result = app_runner.invoke(args=[\"merged\"])\n    assert \"merged_result\" in result.output\n\n    result = app_runner.invoke(args=[\"late_registration\", \"late\"])\n    assert \"late_result\" in result.output"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": "\"\"\"If a Blueprint's CLI group is empty, do not register it.\"\"\"",
                "first_doc": "\"\"\"\nTests that invoking the CLI group 'blue' without a subcommand returns the expected error code.\n\nArgs:\n    app: The Flask application instance to register the blueprint to and run the CLI command against.\n\nReturns:\n    None: This method does not return a value but asserts that the CLI returns the expected error code when invoked without a subcommand.\n\"\"\"",
                "method_name": "test_cli_empty",
                "second_doc": "\"\"\"\nEnsures that running the CLI command group associated with a blueprint, without specifying a subcommand, triggers the correct error response. This test helps validate command-line interface usability and error handling mechanisms.\n\nArgs:\n    app: The Flask application instance used to register the blueprint and run the CLI command.\n\nReturns:\n    None: The function performs assertions to confirm correct error behavior, without returning a value.\n\"\"\"",
                "source_code": "bp = Blueprint(\"blue\", __name__, cli_group=\"blue\")\n    app.register_blueprint(bp)\n\n    result = app.test_cli_runner().invoke(args=[\"blue\", \"--help\"])\n    assert result.exit_code == 2, f\"Unexpected success:\\n\\n{result.output}\""
            },
            "type": "function"
        }
    ],
    "flask/tests/test_config.py": [
        {
            "details": {
                "docstring": null,
                "method_name": "common_object_test",
                "second_doc": "\"\"\"\nVerifies critical Flask application configuration properties to ensure proper setup and separation of configuration from class-based config references.\n\nArgs:\n    app (flask.Flask): The Flask application instance to be tested.\n\nReturns:\n    None: This function uses assertions to validate application state and does not return a value.\n\nWhy:\n    This method ensures that essential application secrets and configuration values are set as expected, contributing to secure and predictable application behavior and preventing accidental exposure of configuration objects.\n\"\"\"",
                "source_code": "assert app.secret_key == \"config\"\n    assert app.config[\"TEST_KEY\"] == \"foo\"\n    assert \"TestConfig\" not in app.config"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_config_from_pyfile",
                "second_doc": "\"\"\"\nTests loading a Flask application's configuration from an external Python file and verifies the application's behavior with the loaded configuration.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "app = flask.Flask(__name__)\n    app.config.from_pyfile(f\"{__file__.rsplit('.', 1)[0]}.py\")\n    common_object_test(app)"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_config_from_object",
                "second_doc": "\"\"\"\nTests loading application configuration from a Python object and verifies the resulting app configuration behaves as expected.\n\nThis method assesses the ability to initialize application settings from an object source, ensuring consistency and correctness when managing web application configuration through object inheritance and modularity.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "app = flask.Flask(__name__)\n    app.config.from_object(__name__)\n    common_object_test(app)"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_config_from_file",
                "second_doc": "\"\"\"\nLoads application configuration from a JSON file and verifies the configuration is correctly applied to the Flask app.\n\nArgs:\n    None\n\nReturns:\n    None\n\nThis function helps ensure that external configuration can be properly read and integrated at app startup, supporting flexible and maintainable settings management.\n\"\"\"",
                "source_code": "app = flask.Flask(__name__)\n    current_dir = os.path.dirname(os.path.abspath(__file__))\n    app.config.from_file(os.path.join(current_dir, \"static\", \"config.json\"), json.load)\n    common_object_test(app)"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_config_from_mapping",
                "second_doc": "\"\"\"\nTests the ability of the application configuration to be updated from different mapping types or keyword arguments, and ensures errors are raised for invalid input.\n\nArgs:\n    None\n\nReturns:\n    None\n\nWhy:\n    This method verifies that the configuration loader accepts various input formats and properly handles incorrect arguments, ensuring robust and flexible configuration management for applications.\n\"\"\"",
                "source_code": "app = flask.Flask(__name__)\n    app.config.from_mapping({\"SECRET_KEY\": \"config\", \"TEST_KEY\": \"foo\"})\n    common_object_test(app)\n\n    app = flask.Flask(__name__)\n    app.config.from_mapping([(\"SECRET_KEY\", \"config\"), (\"TEST_KEY\", \"foo\")])\n    common_object_test(app)\n\n    app = flask.Flask(__name__)\n    app.config.from_mapping(SECRET_KEY=\"config\", TEST_KEY=\"foo\")\n    common_object_test(app)\n\n    app = flask.Flask(__name__)\n    with pytest.raises(TypeError):\n        app.config.from_mapping({}, {})"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_config_from_class",
                "second_doc": "\"\"\"\nTests loading configuration values into the application from a class object, ensuring that both base and subclass attribute values are imported into the app's config. This verifies that class-based configurations can be effectively used to manage app settings.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "class Base:\n        TEST_KEY = \"foo\"\n\n    class Test(Base):\n        SECRET_KEY = \"config\"\n\n    app = flask.Flask(__name__)\n    app.config.from_object(Test)\n    common_object_test(app)"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_config_from_envvar",
                "second_doc": "\"\"\"\nTests the behavior of loading application configuration from an environment variable. Ensures that missing or invalid environment variable scenarios are handled appropriately and that configurations can be loaded successfully when the environment is correctly set.\n\nWhy:\nThis method validates the reliability and robustness of configuration loading, which is critical for ensuring correct application behavior when deploying or running in various environments.\n\nArgs:\n    monkeypatch: A pytest fixture used to safely modify or set environment variables for testing purposes.\n\nReturns:\n    None. Assertions are used to validate the outcome of each configuration loading scenario.\n\"\"\"",
                "source_code": "monkeypatch.setattr(\"os.environ\", {})\n    app = flask.Flask(__name__)\n    with pytest.raises(RuntimeError) as e:\n        app.config.from_envvar(\"FOO_SETTINGS\")\n        assert \"'FOO_SETTINGS' is not set\" in str(e.value)\n    assert not app.config.from_envvar(\"FOO_SETTINGS\", silent=True)\n\n    monkeypatch.setattr(\n        \"os.environ\", {\"FOO_SETTINGS\": f\"{__file__.rsplit('.', 1)[0]}.py\"}\n    )\n    assert app.config.from_envvar(\"FOO_SETTINGS\")\n    common_object_test(app)"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_config_from_envvar_missing",
                "second_doc": "\"\"\"\nTests application behavior when attempting to load a configuration file specified by an environment variable that points to a non-existent file.\n\nThis test ensures that the configuration loader raises an appropriate error when a required file is missing, and verifies that silent mode prevents the error but indicates failure, thereby helping to guarantee robust error handling in configuration loading.\n\nArgs:\n    monkeypatch: Pytest fixture to modify environment variables for the test.\n\nReturns:\n    None\n\"\"\"",
                "source_code": "monkeypatch.setattr(\"os.environ\", {\"FOO_SETTINGS\": \"missing.cfg\"})\n    with pytest.raises(IOError) as e:\n        app = flask.Flask(__name__)\n        app.config.from_envvar(\"FOO_SETTINGS\")\n    msg = str(e.value)\n    assert msg.startswith(\n        \"[Errno 2] Unable to load configuration file (No such file or directory):\"\n    )\n    assert msg.endswith(\"missing.cfg'\")\n    assert not app.config.from_envvar(\"FOO_SETTINGS\", silent=True)"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_config_missing",
                "second_doc": "\"\"\"\nTests how the application behaves when loading a missing configuration file, ensuring appropriate error handling and response when essential configuration is unavailable.\n\nArgs:\n    None\n\nReturns:\n    None\n\nWhy:\n    This method verifies that the application properly raises an error and does not silently fail or misbehave when a required configuration file is missing, which is crucial for reliable application setup and debugging.\n\"\"\"",
                "source_code": "app = flask.Flask(__name__)\n    with pytest.raises(IOError) as e:\n        app.config.from_pyfile(\"missing.cfg\")\n    msg = str(e.value)\n    assert msg.startswith(\n        \"[Errno 2] Unable to load configuration file (No such file or directory):\"\n    )\n    assert msg.endswith(\"missing.cfg'\")\n    assert not app.config.from_pyfile(\"missing.cfg\", silent=True)"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_config_missing_file",
                "second_doc": "\"\"\"\nTest that attempting to load a missing configuration file raises an IOError and returns False when silent mode is enabled.\n\nThis method ensures the application's configuration loading handles missing files gracefully by verifying that the correct exception is raised and appropriate return values are provided.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "app = flask.Flask(__name__)\n    with pytest.raises(IOError) as e:\n        app.config.from_file(\"missing.json\", load=json.load)\n    msg = str(e.value)\n    assert msg.startswith(\n        \"[Errno 2] Unable to load configuration file (No such file or directory):\"\n    )\n    assert msg.endswith(\"missing.json'\")\n    assert not app.config.from_file(\"missing.json\", load=json.load, silent=True)"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_custom_config_class",
                "second_doc": "\"\"\"\nTests whether a Flask application can be configured to use a custom configuration class and that configuration data can be loaded and accessed as expected.\n\nArgs:\n    None\n\nReturns:\n    None\n\nWhy:\n    This method verifies that the application's configuration system can be extended and customized, ensuring that developers retain control and flexibility over how application settings are managed.\n\"\"\"",
                "source_code": "class Config(flask.Config):\n        pass\n\n    class Flask(flask.Flask):\n        config_class = Config\n\n    app = Flask(__name__)\n    assert isinstance(app.config, Config)\n    app.config.from_object(__name__)\n    common_object_test(app)"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_session_lifetime",
                "second_doc": "\"\"\"\nVerify that setting the application's session lifetime configuration correctly determines the duration for which session data is retained.\n\nArgs:\n    None\n\nReturns:\n    None\n\nThis test checks that the session expiration interval is properly applied, ensuring that user session data will persist for the expected amount of time as configured by the application developer.\n\"\"\"",
                "source_code": "app = flask.Flask(__name__)\n    app.config[\"PERMANENT_SESSION_LIFETIME\"] = 42\n    assert app.permanent_session_lifetime.seconds == 42"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_send_file_max_age",
                "second_doc": "\"\"\"\nTests that the configuration value controlling the default maximum age for sending files can be accurately set using both integer seconds and timedelta objects. This ensures consistent behavior for file caching and resource expiration.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "app = flask.Flask(__name__)\n    app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = 3600\n    assert app.send_file_max_age_default.seconds == 3600\n    app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = timedelta(hours=2)\n    assert app.send_file_max_age_default.seconds == 7200"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_get_namespace",
                "second_doc": "\"\"\"\nTests that configuration namespaces are correctly extracted and processed from the application configuration, ensuring different options for trimming namespace prefixes and controlling key casing are handled as expected.\n\nArgs:\n    None\n\nReturns:\n    None\n\nWhy:\n    This validates that the application's configuration management supports flexible grouping and retrieval of related configuration parameters, which is essential for organizing settings efficiently and enabling modularity or extension in application behavior.\n\"\"\"",
                "source_code": "app = flask.Flask(__name__)\n    app.config[\"FOO_OPTION_1\"] = \"foo option 1\"\n    app.config[\"FOO_OPTION_2\"] = \"foo option 2\"\n    app.config[\"BAR_STUFF_1\"] = \"bar stuff 1\"\n    app.config[\"BAR_STUFF_2\"] = \"bar stuff 2\"\n    foo_options = app.config.get_namespace(\"FOO_\")\n    assert 2 == len(foo_options)\n    assert \"foo option 1\" == foo_options[\"option_1\"]\n    assert \"foo option 2\" == foo_options[\"option_2\"]\n    bar_options = app.config.get_namespace(\"BAR_\", lowercase=False)\n    assert 2 == len(bar_options)\n    assert \"bar stuff 1\" == bar_options[\"STUFF_1\"]\n    assert \"bar stuff 2\" == bar_options[\"STUFF_2\"]\n    foo_options = app.config.get_namespace(\"FOO_\", trim_namespace=False)\n    assert 2 == len(foo_options)\n    assert \"foo option 1\" == foo_options[\"foo_option_1\"]\n    assert \"foo option 2\" == foo_options[\"foo_option_2\"]\n    bar_options = app.config.get_namespace(\n        \"BAR_\", lowercase=False, trim_namespace=False\n    )\n    assert 2 == len(bar_options)\n    assert \"bar stuff 1\" == bar_options[\"BAR_STUFF_1\"]\n    assert \"bar stuff 2\" == bar_options[\"BAR_STUFF_2\"]"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_from_pyfile_weird_encoding",
                "second_doc": "\"\"\"\nTests that configuration files with various text encodings can be read and parsed correctly, ensuring that non-ASCII characters are handled as expected when loading application settings.\n\nArgs:\n    encoding (str): The encoding to use for writing the configuration file. This can be \"utf-8\", \"iso-8859-15\", or \"latin-1\".\n\nReturns:\n    None: This test function asserts that the configuration value is loaded correctly for each specified encoding.\n    \nWhy:\n    The method verifies robust handling of configuration files with different encodings, ensuring that applications remain stable and settings are accurately parsed regardless of the encoding used in the configuration file.\n\"\"\"",
                "source_code": "f = tmpdir.join(\"my_config.py\")\n    f.write_binary(\n        textwrap.dedent(\n            f\"\"\"\n            # -*- coding: {encoding} -*-\n            TEST_VALUE = \"f\u00f6\u00f6\"\n            \"\"\"\n        ).encode(encoding)\n    )\n    app = flask.Flask(__name__)\n    app.config.from_pyfile(str(f))\n    value = app.config[\"TEST_VALUE\"]\n    assert value == \"f\u00f6\u00f6\""
            },
            "type": "function"
        }
    ],
    "flask/tests/test_converters.py": [
        {
            "details": {
                "docstring": null,
                "method_name": "test_custom_converters",
                "second_doc": "\"\"\"\nTests the integration and functionality of a custom URL converter that handles lists, verifying that URL path components are properly converted to Python lists and vice versa. This ensures that complex data structures can be seamlessly passed through URL routing and back again, enhancing route flexibility.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "class ListConverter(BaseConverter):\n        def to_python(self, value):\n            return value.split(\",\")\n\n        def to_url(self, value):\n            base_to_url = super().to_url\n            return \",\".join(base_to_url(x) for x in value)\n\n    app.url_map.converters[\"list\"] = ListConverter\n\n    @app.route(\"/<list:args>\")\n    def index(args):\n        return \"|\".join(args)\n\n    assert client.get(\"/1,2,3\").data == b\"1|2|3\"\n\n    with app.test_request_context():\n        assert url_for(\"index\", args=[4, 5, 6]) == \"/4,5,6\""
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_context_available",
                "second_doc": "\"\"\"\nTests that the custom URL converter in the application is able to access the request context when converting a URL parameter. This ensures that certain Flask-specific values or functions that depend on the request context are accessible during URL value processing.\n\nArgs:\n    None\n\nReturns:\n    None. The test will raise an assertion error if the request context is not available or the route does not return the expected value.\n\"\"\"",
                "source_code": "class ContextConverter(BaseConverter):\n        def to_python(self, value):\n            assert has_request_context()\n            return value\n\n    app.url_map.converters[\"ctx\"] = ContextConverter\n\n    @app.route(\"/<ctx:name>\")\n    def index(name):\n        return name\n\n    assert client.get(\"/admin\").data == b\"admin\""
            },
            "type": "function"
        }
    ],
    "flask/tests/test_helpers.py": [
        {
            "details": {
                "docstring": null,
                "method_name": "has_encoding",
                "second_doc": "\"\"\"\nCheck if the given encoding name is recognized and supported by the system.\n\nThis check helps ensure that text and data can be processed correctly without encountering unexpected encoding errors.\n\nArgs:\n    name (str): The name of the encoding to check.\n\nReturns:\n    bool: True if the encoding is supported, False otherwise.\n\"\"\"",
                "source_code": "try:\n        import codecs\n\n        codecs.lookup(name)\n        return True\n    except LookupError:\n        return False"
            },
            "type": "function"
        },
        {
            "methods": [
                {
                    "docstring": null,
                    "method_name": "__init__",
                    "second_doc": "\"\"\"\nInitializes a FakePath instance by storing the provided file path.\n\nArgs:\n    path (str): The file path to be associated with this instance.\n\nReturns:\n    None\n\nWhy:\n    Storing the file path upon initialization allows the instance to represent or manipulate that specific path within the application's context, supporting tasks such as file handling, routing, or simulating filesystem operations.\n\"\"\"",
                    "source_code": "self.path = path"
                },
                {
                    "docstring": null,
                    "method_name": "__fspath__",
                    "second_doc": "\"\"\"\nProvides the file system path representation for this object to integrate with file-related operations and Python's path protocol.\n\nReturns:\n    str: The file system path associated with this object, typically used for path manipulations and compatibility with standard library interfaces.\n\"\"\"",
                    "source_code": "return self.path"
                }
            ],
            "name": "FakePath",
            "type": "class"
        },
        {
            "methods": [
                {
                    "docstring": null,
                    "method_name": "__init__",
                    "second_doc": "\"\"\"\nInitializes a fixed time offset and an associated name for use in date and time calculations.\n\nThis method enables consistent timezone manipulations and formatted representations within the application.\n\nArgs:\n    hours (int): The number of hours representing the fixed offset from UTC.\n    name (str): A descriptive label for the offset.\n\nReturns:\n    None\n\"\"\"",
                    "source_code": "self.__offset = datetime.timedelta(hours=hours)\n        self.__name = name"
                },
                {
                    "docstring": null,
                    "method_name": "utcoffset",
                    "second_doc": "\"\"\"\nReturn the fixed UTC offset as a timedelta object.\n\nThis method provides the constant offset for a timezone-aware object, allowing consistent timezone calculations when managing datetimes in the context of web applications.\n\nReturns:\n    timedelta: The fixed offset from UTC represented by this timezone.\n\"\"\"",
                    "source_code": "return self.__offset"
                },
                {
                    "docstring": null,
                    "method_name": "tzname",
                    "second_doc": "\"\"\"\nReturns the name associated with the timezone offset for this instance.\n\nThis method provides a human-readable label for a fixed timezone, which can be used for clear and consistent representation of datetimes across different components of web applications.\n\nReturns:\n    str: The name assigned to the fixed timezone offset.\n\"\"\"",
                    "source_code": "return self.__name"
                },
                {
                    "docstring": null,
                    "method_name": "dst",
                    "second_doc": "\"\"\"\nReturns the daylight saving time (DST) adjustment for this fixed offset timezone. \n\nSince fixed offset time zones do not observe daylight saving time, this method always returns a zero timedelta. \n\nReturns:\n    datetime.timedelta: The DST adjustment (always zero for fixed offset time zones).\n\"\"\"",
                    "source_code": "return datetime.timedelta()"
                }
            ],
            "name": "FixedOffset",
            "type": "class"
        },
        {
            "methods": [
                {
                    "docstring": null,
                    "method_name": "test_bad_request_debug_message",
                    "second_doc": "\"\"\"\nTests whether the server's debug configuration affects the inclusion of detailed error messages in responses to bad JSON requests.\n\nArgs:\n    debug (bool): Indicates if the application's DEBUG mode is enabled.\n\nReturns:\n    None. Uses assertions to validate behavior.\n    \nWhy:\n    Ensures that error handling for invalid JSON requests reflects the application's debug setting, which impacts both development troubleshooting and user-facing error transparency.\n\"\"\"",
                    "source_code": "app.config[\"DEBUG\"] = debug\n        app.config[\"TRAP_BAD_REQUEST_ERRORS\"] = False\n\n        @app.route(\"/json\", methods=[\"POST\"])\n        def post_json():\n            flask.request.get_json()\n            return None\n\n        rv = client.post(\"/json\", data=None, content_type=\"application/json\")\n        assert rv.status_code == 400\n        contains = b\"Failed to decode JSON object\" in rv.data\n        assert contains == debug"
                },
                {
                    "docstring": null,
                    "method_name": "test_json_bad_requests",
                    "second_doc": "\"\"\"\nTests that the server correctly handles malformed JSON in incoming requests by returning a 400 status code. This ensures robust error responses when clients submit invalid JSON payloads.\n\nArgs:\n    self: The test case instance.\n\nReturns:\n    None. Asserts that the HTTP response status code is 400 (Bad Request).\n\"\"\"",
                    "source_code": "@app.route(\"/json\", methods=[\"POST\"])\n        def return_json():\n            return flask.jsonify(foo=str(flask.request.get_json()))\n\n        rv = client.post(\"/json\", data=\"malformed\", content_type=\"application/json\")\n        assert rv.status_code == 400"
                },
                {
                    "docstring": null,
                    "method_name": "test_json_custom_mimetypes",
                    "second_doc": "\"\"\"\nTests that the application correctly parses JSON data from a request with a non-standard custom content type, ensuring flexibility in accepting various JSON MIME types.\n\nArgs:\n    self: The test case instance.\n\nReturns:\n    None\n\"\"\"",
                    "source_code": "@app.route(\"/json\", methods=[\"POST\"])\n        def return_json():\n            return flask.request.get_json()\n\n        rv = client.post(\"/json\", data='\"foo\"', content_type=\"application/x+json\")\n        assert rv.data == b\"foo\""
                },
                {
                    "docstring": null,
                    "method_name": "test_json_as_unicode",
                    "second_doc": "\"\"\"\nTests whether the JSON encoding of Unicode strings in Flask respects the 'JSON_AS_ASCII' configuration option, ensuring correct representation of non-ASCII characters in serialized output.\n\nArgs:\n    test_value (bool): Determines if ASCII encoding should be used for JSON output.\n    expected (str): The expected JSON string result after dumping a Unicode value.\n\nReturns:\n    None. Asserts that the JSON output matches the expected result.\n\nWhy:\n    Verifying this behavior ensures that JSON responses are encoded correctly according to configuration, which is important for supporting different client requirements and preserving data integrity when handling Unicode content.\n\"\"\"",
                    "source_code": "app.config[\"JSON_AS_ASCII\"] = test_value\n        rv = flask.json.dumps(\"\\N{SNOWMAN}\")\n        assert rv == expected"
                },
                {
                    "docstring": null,
                    "method_name": "test_json_dump_to_file",
                    "second_doc": "\"\"\"\nTests that a Python object can be serialized to JSON, written to a file-like object, and then accurately deserialized back to its original form.\n\nArgs:\n    self: The test case instance.\n\nReturns:\n    None\n\nThis ensures that JSON serialization and deserialization work correctly with file-like objects, supporting reliable data interchange and persistence.\n\"\"\"",
                    "source_code": "test_data = {\"name\": \"Flask\"}\n        out = io.StringIO()\n\n        flask.json.dump(test_data, out)\n        out.seek(0)\n        rv = flask.json.load(out)\n        assert rv == test_data"
                },
                {
                    "docstring": "\"\"\"Test jsonify with basic types.\"\"\"",
                    "first_doc": "\"\"\"\nTests JSON serialization of basic data types using Flask's jsonify.\n\nThis method registers a Flask route that returns the provided test value as a JSON response, sends a GET request to that route using the test client, and verifies that the response is correctly formatted as JSON and matches the expected value.\n\nArgs:\n    self: The test case instance.\n    test_value: The value to serialize and test for correct JSON response (basic types, such as int, float, string, bool, or None).\n    app: The Flask application test instance used to set up routes and configuration.\n    client: The Flask test client used to make HTTP requests to the application.\n\nReturns:\n    None. The test asserts correct behavior but does not return a value.\n\"\"\"",
                    "method_name": "test_jsonify_basic_types",
                    "second_doc": "\"\"\"\nVerifies that basic Python data types are correctly serialized to JSON format when returned from a Flask route.\n\nThis method dynamically registers a route in the Flask application to respond with the specified test value serialized as JSON. It then uses the Flask test client to request this route and asserts both the correct JSON MIME type and value in the response. This ensures accurate and reliable communication of simple data types through JSON in web APIs.\n\nArgs:\n    self: The test case instance for managing and asserting test conditions.\n    test_value: The simple Python value (int, float, string, bool, or None) to serialize as JSON and validate.\n    app: The Flask application test fixture, used for setting up and registering test routes.\n    client: The Flask test client for simulating HTTP requests to the application.\n\nReturns:\n    None. All validations are performed via assertions.\n\"\"\"",
                    "source_code": "url = \"/jsonify_basic_types\"\n        app.add_url_rule(url, url, lambda x=test_value: flask.jsonify(x))\n        rv = client.get(url)\n        assert rv.mimetype == \"application/json\"\n        assert flask.json.loads(rv.data) == test_value"
                },
                {
                    "docstring": "\"\"\"Test jsonify with dicts and kwargs unpacking.\"\"\"",
                    "first_doc": "\"\"\"\nTests the Flask jsonify function with both dictionary input and keyword argument unpacking.\n\nArgs:\n    app: The Flask application instance used to set up routes for testing.\n    client: The test client used to make requests to the application's endpoints.\n\nReturns:\n    None: This method performs assertions to verify jsonify's behavior and does not return a value.\n\"\"\"",
                    "method_name": "test_jsonify_dicts",
                    "second_doc": "\"\"\"\nVerifies that the jsonify utility consistently outputs correct JSON responses when provided with both a dictionary directly and a dictionary unpacked as keyword arguments in route handlers.\n\nArgs:\n    app: The Flask application instance, used for configuring test routes.\n    client: The test client used to issue HTTP requests to Flask endpoints and inspect responses.\n\nReturns:\n    None: The method uses assertions to confirm jsonify's consistent behavior and does not return a value.\n\"\"\"",
                    "source_code": "d = {\n            \"a\": 0,\n            \"b\": 23,\n            \"c\": 3.14,\n            \"d\": \"t\",\n            \"e\": \"Hi\",\n            \"f\": True,\n            \"g\": False,\n            \"h\": [\"test list\", 10, False],\n            \"i\": {\"test\": \"dict\"},\n        }\n\n        @app.route(\"/kw\")\n        def return_kwargs():\n            return flask.jsonify(**d)\n\n        @app.route(\"/dict\")\n        def return_dict():\n            return flask.jsonify(d)\n\n        for url in \"/kw\", \"/dict\":\n            rv = client.get(url)\n            assert rv.mimetype == \"application/json\"\n            assert flask.json.loads(rv.data) == d"
                },
                {
                    "docstring": "\"\"\"Test jsonify of lists and args unpacking.\"\"\"",
                    "first_doc": "\"\"\"\nTests the JSON serialization of lists and verifies correct unpacking of arguments in Flask routes.\n\nArgs:\n    self: The test case instance.\n    app: The Flask application used for routing and response generation.\n    client: The Flask test client used to make HTTP requests to the application.\n\nReturns:\n    None. Assertion errors are raised if the JSON responses do not match the expected output.\n\"\"\"",
                    "method_name": "test_jsonify_arrays",
                    "second_doc": "\"\"\"\nVerifies that lists can be accurately serialized to JSON and correctly returned from different Flask route response patterns, ensuring consistent handling of array data structures in HTTP responses.\n\nArgs:\n    self: The test case instance.\n    app: The Flask application instance providing route definitions for testing JSON responses.\n    client: The Flask test client used to perform HTTP requests against the application routes.\n\nReturns:\n    None. Raises assertion errors if the mimetype or JSON content of the HTTP responses do not match the expectations.\n\"\"\"",
                    "source_code": "a_list = [\n            0,\n            42,\n            3.14,\n            \"t\",\n            \"hello\",\n            True,\n            False,\n            [\"test list\", 2, False],\n            {\"test\": \"dict\"},\n        ]\n\n        @app.route(\"/args_unpack\")\n        def return_args_unpack():\n            return flask.jsonify(*a_list)\n\n        @app.route(\"/array\")\n        def return_array():\n            return flask.jsonify(a_list)\n\n        for url in \"/args_unpack\", \"/array\":\n            rv = client.get(url)\n            assert rv.mimetype == \"application/json\"\n            assert flask.json.loads(rv.data) == a_list"
                },
                {
                    "docstring": "\"\"\"Test jsonify with datetime.date and datetime.datetime types.\"\"\"",
                    "first_doc": "\"\"\"\nTests the Flask application's ability to jsonify datetime.date and datetime.datetime types.\n\nArgs:\n    app: The Flask application instance to which test routes will be added.\n    client: The test client used to send HTTP requests to the application.\n\nReturns:\n    None: This method performs assertions to validate correct behavior and does not return a value.\n\"\"\"",
                    "method_name": "test_jsonify_date_types",
                    "second_doc": "\"\"\"\nVerifies that the Flask application's JSON response correctly represents values of datetime.date and datetime.datetime types, ensuring they are properly serialized for HTTP communication.\n\nArgs:\n    app: The Flask application instance where temporary test routes are registered.\n    client: The test client used to simulate HTTP GET requests to the registered routes.\n\nReturns:\n    None: This method uses assertions to check expected behavior and does not produce a return value.\n\"\"\"",
                    "source_code": "test_dates = (\n            datetime.datetime(1973, 3, 11, 6, 30, 45),\n            datetime.date(1975, 1, 5),\n        )\n\n        for i, d in enumerate(test_dates):\n            url = f\"/datetest{i}\"\n            app.add_url_rule(url, str(i), lambda val=d: flask.jsonify(x=val))\n            rv = client.get(url)\n            assert rv.mimetype == \"application/json\"\n            assert flask.json.loads(rv.data)[\"x\"] == http_date(d.timetuple())"
                },
                {
                    "docstring": "\"\"\"Test if aware datetime.datetime objects are converted into GMT.\"\"\"",
                    "first_doc": "\"\"\"\nTests whether aware datetime.datetime objects are correctly converted to GMT in JSON encoding.\n\nArgs:\n    tz: A tuple containing the timezone name and its offset in hours from GMT.\n\nReturns:\n    None: This method is used for testing and does not return a value. It asserts that JSON encoding of aware datetime objects results in the expected GMT-formatted string.\n\"\"\"",
                    "method_name": "test_jsonify_aware_datetimes",
                    "second_doc": "\"\"\"\nVerifies that datetime.datetime objects with timezone information are correctly transformed to their equivalent GMT representation during JSON serialization.\n\nThis ensures consistency and predictability in handling and transmitting date-time data with timezones, which is critical for communication between systems that may operate across different regions.\n\nArgs:\n    tz (tuple): A tuple containing the timezone name and its offset in hours relative to GMT.\n\nReturns:\n    None: The method makes assertions to validate functionality but does not return a value.\n\"\"\"",
                    "source_code": "tzinfo = FixedOffset(hours=tz[1], name=tz[0])\n        dt = datetime.datetime(2017, 1, 1, 12, 34, 56, tzinfo=tzinfo)\n        gmt = FixedOffset(hours=0, name=\"GMT\")\n        expected = dt.astimezone(gmt).strftime('\"%a, %d %b %Y %H:%M:%S %Z\"')\n        assert flask.json.JSONEncoder().encode(dt) == expected"
                },
                {
                    "docstring": "\"\"\"Test jsonify with uuid.UUID types\"\"\"",
                    "first_doc": "\"\"\"\nTests that Flask's jsonify properly serializes and deserializes uuid.UUID objects.\n\nArgs:\n    self: The test case instance.\n    app: The Flask application instance to which the test URL is added.\n    client: A test client used to issue HTTP requests to the application.\n\nReturns:\n    None. This method performs assertions to validate that uuid.UUID objects are JSON-serializable and deserializable via Flask's jsonify.\n\"\"\"",
                    "method_name": "test_jsonify_uuid_types",
                    "second_doc": "\"\"\"\nVerifies that uuid.UUID objects can be accurately serialized to JSON and reconstructed when returned in HTTP responses, ensuring transparent data interchange through Flask's JSON utilities.\n\nArgs:\n    self: Instance of the test case.\n    app: Flask application to which the test route is registered.\n    client: HTTP client used for simulating requests to the Flask application.\n\nReturns:\n    None. Performs assertions to guarantee proper JSON encoding and decoding of uuid.UUID objects in HTTP communication.\n\"\"\"",
                    "source_code": "test_uuid = uuid.UUID(bytes=b\"\\xDE\\xAD\\xBE\\xEF\" * 4)\n        url = \"/uuid_test\"\n        app.add_url_rule(url, url, lambda: flask.jsonify(x=test_uuid))\n\n        rv = client.get(url)\n\n        rv_x = flask.json.loads(rv.data)[\"x\"]\n        assert rv_x == str(test_uuid)\n        rv_uuid = uuid.UUID(rv_x)\n        assert rv_uuid == test_uuid"
                },
                {
                    "docstring": null,
                    "method_name": "test_json_attr",
                    "second_doc": "\"\"\"\nTests the handling of JSON payloads in a POST request by simulating a client request to an endpoint that adds two numbers and returns the result as a string.\n\nArgs:\n    self: The test case instance.\n\nReturns:\n    None\n\nWhy:\n    Ensures that the application correctly parses JSON input, processes the values, and returns the expected output. This validates the application's ability to interact with client data and confirms JSON request handling within route logic.\n\"\"\"",
                    "source_code": "@app.route(\"/add\", methods=[\"POST\"])\n        def add():\n            json = flask.request.get_json()\n            return str(json[\"a\"] + json[\"b\"])\n\n        rv = client.post(\n            \"/add\",\n            data=flask.json.dumps({\"a\": 1, \"b\": 2}),\n            content_type=\"application/json\",\n        )\n        assert rv.data == b\"3\""
                },
                {
                    "docstring": null,
                    "method_name": "test_template_escaping",
                    "second_doc": "\"\"\"\nTests that strings containing potentially unsafe characters are properly escaped when serialized to JSON and rendered in templates, preventing content injection and ensuring that output is safe to include in HTML pages.\n\nArgs:\n    self: The instance of the test case.\n\nReturns:\n    None\n\nWhy:\n    This is important to verify that the application's rendering and JSON serialization mechanisms do not inadvertently introduce security vulnerabilities, such as cross-site scripting (XSS), by failing to escape special characters in user-supplied or generated content.\n\"\"\"",
                    "source_code": "render = flask.render_template_string\n        rv = flask.json.htmlsafe_dumps(\"</script>\")\n        assert rv == '\"\\\\u003c/script\\\\u003e\"'\n        rv = render('{{ \"</script>\"|tojson }}')\n        assert rv == '\"\\\\u003c/script\\\\u003e\"'\n        rv = render('{{ \"<\\0/script>\"|tojson }}')\n        assert rv == '\"\\\\u003c\\\\u0000/script\\\\u003e\"'\n        rv = render('{{ \"<!--<script>\"|tojson }}')\n        assert rv == '\"\\\\u003c!--\\\\u003cscript\\\\u003e\"'\n        rv = render('{{ \"&\"|tojson }}')\n        assert rv == '\"\\\\u0026\"'\n        rv = render('{{ \"\\'\"|tojson }}')\n        assert rv == '\"\\\\u0027\"'\n        rv = render(\n            \"<a ng-data='{{ data|tojson }}'></a>\", data={\"x\": [\"foo\", \"bar\", \"baz'\"]}\n        )\n        assert rv == '<a ng-data=\\'{\"x\": [\"foo\", \"bar\", \"baz\\\\u0027\"]}\\'></a>'"
                },
                {
                    "docstring": null,
                    "method_name": "test_json_customization",
                    "second_doc": "\"\"\"\nTests that custom JSON encoder and decoder classes can be set for the application, verifying custom object serialization and deserialization logic in HTTP request and response cycles.\n\nArgs:\n    self: The test case instance.\n\nReturns:\n    None\n\"\"\"",
                    "source_code": "class X:  # noqa: B903, for Python2 compatibility\n            def __init__(self, val):\n                self.val = val\n\n        class MyEncoder(flask.json.JSONEncoder):\n            def default(self, o):\n                if isinstance(o, X):\n                    return f\"<{o.val}>\"\n                return flask.json.JSONEncoder.default(self, o)\n\n        class MyDecoder(flask.json.JSONDecoder):\n            def __init__(self, *args, **kwargs):\n                kwargs.setdefault(\"object_hook\", self.object_hook)\n                flask.json.JSONDecoder.__init__(self, *args, **kwargs)\n\n            def object_hook(self, obj):\n                if len(obj) == 1 and \"_foo\" in obj:\n                    return X(obj[\"_foo\"])\n                return obj\n\n        app.json_encoder = MyEncoder\n        app.json_decoder = MyDecoder\n\n        @app.route(\"/\", methods=[\"POST\"])\n        def index():\n            return flask.json.dumps(flask.request.get_json()[\"x\"])\n\n        rv = client.post(\n            \"/\",\n            data=flask.json.dumps({\"x\": {\"_foo\": 42}}),\n            content_type=\"application/json\",\n        )\n        assert rv.data == b'\"<42>\"'"
                },
                {
                    "docstring": null,
                    "method_name": "test_blueprint_json_customization",
                    "second_doc": "\"\"\"\nTest that a Flask blueprint can use custom JSON encoder and decoder classes, ensuring route serialization and deserialization are fully configurable for advanced data types.\n\nArgs:\n    self: Instance of the test class.\n\nReturns:\n    None. Asserts that the response data from the POST request reflects the effect of the custom JSON customization.\n\nWhy:\n    This validates that Flask's blueprint system allows fine-grained control over JSON handling, enabling tailored request and response behaviors for specialized application needs.\n\"\"\"",
                    "source_code": "class X:\n            __slots__ = (\"val\",)\n\n            def __init__(self, val):\n                self.val = val\n\n        class MyEncoder(flask.json.JSONEncoder):\n            def default(self, o):\n                if isinstance(o, X):\n                    return f\"<{o.val}>\"\n\n                return flask.json.JSONEncoder.default(self, o)\n\n        class MyDecoder(flask.json.JSONDecoder):\n            def __init__(self, *args, **kwargs):\n                kwargs.setdefault(\"object_hook\", self.object_hook)\n                flask.json.JSONDecoder.__init__(self, *args, **kwargs)\n\n            def object_hook(self, obj):\n                if len(obj) == 1 and \"_foo\" in obj:\n                    return X(obj[\"_foo\"])\n\n                return obj\n\n        bp = flask.Blueprint(\"bp\", __name__)\n        bp.json_encoder = MyEncoder\n        bp.json_decoder = MyDecoder\n\n        @bp.route(\"/bp\", methods=[\"POST\"])\n        def index():\n            return flask.json.dumps(flask.request.get_json()[\"x\"])\n\n        app.register_blueprint(bp)\n\n        rv = client.post(\n            \"/bp\",\n            data=flask.json.dumps({\"x\": {\"_foo\": 42}}),\n            content_type=\"application/json\",\n        )\n        assert rv.data == b'\"<42>\"'"
                },
                {
                    "docstring": null,
                    "method_name": "test_modified_url_encoding",
                    "second_doc": "\"\"\"\nTests that the application can correctly decode query parameters using a custom URL character encoding by verifying request argument handling with 'euc-kr' encoded data.\n\nArgs:\n    self: Instance of the test case class.\n\nReturns:\n    None\n\nWhy:\n    Ensures that the application remains robust when handling request data in different encodings, which is vital for supporting international users and locales.\n\"\"\"",
                    "source_code": "class ModifiedRequest(flask.Request):\n            url_charset = \"euc-kr\"\n\n        app.request_class = ModifiedRequest\n        app.url_map.charset = \"euc-kr\"\n\n        @app.route(\"/\")\n        def index():\n            return flask.request.args[\"foo\"]\n\n        rv = client.get(\"/?foo=\uc815\uc0c1\ucc98\ub9ac\".encode(\"euc-kr\"))\n        assert rv.status_code == 200\n        assert rv.data == \"\uc815\uc0c1\ucc98\ub9ac\".encode()"
                },
                {
                    "docstring": null,
                    "method_name": "test_json_key_sorting",
                    "second_doc": "\"\"\"\nTests whether JSON responses have their dictionary keys sorted in the output, according to the application's JSON sorting configuration.\n\nArgs:\n    self: The test case instance. Uses Flask app and test client configured in the class.\n\nReturns:\n    None. Asserts internally that the sorted keys order in the JSON response matches either string or integer sorting conventions.\n\nWhy:\n    Ensures that JSON serialization maintains predictable and consistent key ordering, which is useful for debugging, testing, and client-side processing of API responses.\n\"\"\"",
                    "source_code": "app.debug = True\n\n        assert app.config[\"JSON_SORT_KEYS\"]\n        d = dict.fromkeys(range(20), \"foo\")\n\n        @app.route(\"/\")\n        def index():\n            return flask.jsonify(values=d)\n\n        rv = client.get(\"/\")\n        lines = [x.strip() for x in rv.data.strip().decode(\"utf-8\").splitlines()]\n        sorted_by_str = [\n            \"{\",\n            '\"values\": {',\n            '\"0\": \"foo\",',\n            '\"1\": \"foo\",',\n            '\"10\": \"foo\",',\n            '\"11\": \"foo\",',\n            '\"12\": \"foo\",',\n            '\"13\": \"foo\",',\n            '\"14\": \"foo\",',\n            '\"15\": \"foo\",',\n            '\"16\": \"foo\",',\n            '\"17\": \"foo\",',\n            '\"18\": \"foo\",',\n            '\"19\": \"foo\",',\n            '\"2\": \"foo\",',\n            '\"3\": \"foo\",',\n            '\"4\": \"foo\",',\n            '\"5\": \"foo\",',\n            '\"6\": \"foo\",',\n            '\"7\": \"foo\",',\n            '\"8\": \"foo\",',\n            '\"9\": \"foo\"',\n            \"}\",\n            \"}\",\n        ]\n        sorted_by_int = [\n            \"{\",\n            '\"values\": {',\n            '\"0\": \"foo\",',\n            '\"1\": \"foo\",',\n            '\"2\": \"foo\",',\n            '\"3\": \"foo\",',\n            '\"4\": \"foo\",',\n            '\"5\": \"foo\",',\n            '\"6\": \"foo\",',\n            '\"7\": \"foo\",',\n            '\"8\": \"foo\",',\n            '\"9\": \"foo\",',\n            '\"10\": \"foo\",',\n            '\"11\": \"foo\",',\n            '\"12\": \"foo\",',\n            '\"13\": \"foo\",',\n            '\"14\": \"foo\",',\n            '\"15\": \"foo\",',\n            '\"16\": \"foo\",',\n            '\"17\": \"foo\",',\n            '\"18\": \"foo\",',\n            '\"19\": \"foo\"',\n            \"}\",\n            \"}\",\n        ]\n\n        try:\n            assert lines == sorted_by_int\n        except AssertionError:\n            assert lines == sorted_by_str"
                }
            ],
            "name": "TestJSON",
            "type": "class"
        },
        {
            "methods": [
                {
                    "docstring": null,
                    "method_name": "__init__",
                    "second_doc": "\"\"\"\nInitializes an in-memory byte stream to facilitate binary data manipulation within the class.\n\nArgs:\n    *args: Variable length argument list forwarded to io.BytesIO.\n    **kwargs: Arbitrary keyword arguments forwarded to io.BytesIO.\n\nReturns:\n    None\n\nWhy:\n    This method creates a bytes buffer, allowing the class to efficiently read from and write to binary data. Such functionality is essential for processing and transferring file-like binary content in applications.\n\"\"\"",
                    "source_code": "self._io = io.BytesIO(*args, **kwargs)"
                },
                {
                    "docstring": null,
                    "method_name": "__getattr__",
                    "second_doc": "\"\"\"\nDelegate attribute access to the underlying I/O buffer.\n\nArgs:\n    name (str): The name of the attribute to retrieve from the internal I/O object.\n\nReturns:\n    Any: The value of the requested attribute from the internal I/O buffer.\n\nThis method ensures that the wrapper object transparently exposes the functionality of the underlying I/O stream, allowing seamless integration with code that expects standard file-like behavior.\n\"\"\"",
                    "source_code": "return getattr(self._io, name)"
                }
            ],
            "name": "PyBytesIO",
            "type": "class"
        },
        {
            "methods": [
                {
                    "docstring": null,
                    "method_name": "test_send_file_regular",
                    "second_doc": "\"\"\"\nTests that sending a static file using the framework correctly delivers the expected content and mimetype while preserving direct data streaming behavior.\n\nArgs:\n    None\n\nReturns:\n    None\n\nWhy:\n    This method verifies that file-serving functionality works as intended, ensuring the response inherits the appropriate properties and delivers the correct content. This validation is crucial for reliable static file handling in web applications.\n\"\"\"",
                    "source_code": "rv = flask.send_file(\"static/index.html\")\n        assert rv.direct_passthrough\n        assert rv.mimetype == \"text/html\"\n        with app.open_resource(\"static/index.html\") as f:\n            rv.direct_passthrough = False\n            assert rv.data == f.read()\n        rv.close()"
                },
                {
                    "docstring": null,
                    "method_name": "test_send_file_xsendfile",
                    "second_doc": "\"\"\"\nTests that sending a file with X-Sendfile enabled sets the correct response headers, passes the file path securely, and assigns the appropriate MIME type.\n\nArgs:\n    self: The test case instance.\n\nReturns:\n    None\n\nWhy:\n    This method verifies that file transmission leverages X-Sendfile, ensuring efficient file serving and delegate file delivery to the web server for improved performance and security.\n\"\"\"",
                    "source_code": "app.use_x_sendfile = True\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.direct_passthrough\n        assert \"x-sendfile\" in rv.headers\n        assert rv.headers[\"x-sendfile\"] == os.path.join(\n            app.root_path, \"static/index.html\"\n        )\n        assert rv.mimetype == \"text/html\"\n        rv.close()"
                },
                {
                    "docstring": null,
                    "method_name": "test_send_file_last_modified",
                    "second_doc": "\"\"\"\nTest that the 'last_modified' parameter in file responses is correctly processed and returned by the application.\n\nArgs:\n    None\n\nReturns:\n    None\n\nThis method verifies that file downloads from the server include the proper 'Last-Modified' header, ensuring clients receive accurate metadata for cache validation and browser behavior.\n\"\"\"",
                    "source_code": "last_modified = datetime.datetime(1999, 1, 1)\n\n        @app.route(\"/\")\n        def index():\n            return flask.send_file(\n                io.BytesIO(b\"party like it's\"),\n                last_modified=last_modified,\n                mimetype=\"text/plain\",\n            )\n\n        rv = client.get(\"/\")\n        assert rv.last_modified == last_modified"
                },
                {
                    "docstring": null,
                    "method_name": "test_send_file_object_without_mimetype",
                    "second_doc": "\"\"\"\nTests that attempting to send a file-like object without specifying a MIME type or filename raises a ValueError, while providing a filename allows the operation to succeed.\n\nThis verifies robust error handling when the MIME type cannot be determined for downloadable responses.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                    "source_code": "with pytest.raises(ValueError) as excinfo:\n            flask.send_file(io.BytesIO(b\"LOL\"))\n        assert \"Unable to infer MIME-type\" in str(excinfo.value)\n        assert \"no filename is available\" in str(excinfo.value)\n\n        flask.send_file(io.BytesIO(b\"LOL\"), attachment_filename=\"filename\")"
                },
                {
                    "docstring": null,
                    "method_name": "test_send_file_object",
                    "second_doc": "\"\"\"\nTests that sending file-like objects as HTTP responses works correctly, ensuring files are delivered with the specified MIME type, that response data is accessible, and that internal optimizations such as X-Sendfile do not interfere. This validation helps guarantee the reliability and flexibility of file delivery regardless of the file object implementation, supporting robust resource serving within applications.\n\nArgs:\n    opener (callable): A function returning a file-like object, such as an open binary file or an in-memory bytes buffer.\n\nReturns:\n    None. Assertions raise exceptions if expected behavior is not met.\n\"\"\"",
                    "source_code": "file = opener(app)\n        app.use_x_sendfile = True\n        rv = flask.send_file(file, mimetype=\"text/plain\")\n        rv.direct_passthrough = False\n        assert rv.data\n        assert rv.mimetype == \"text/plain\"\n        assert \"x-sendfile\" not in rv.headers\n        rv.close()"
                },
                {
                    "docstring": null,
                    "method_name": "test_send_file_text_fails",
                    "second_doc": "\"\"\"\nTests that attempting to send a text file-like object with Flask's send_file function raises a ValueError, ensuring proper handling of unsupported file types.\n\nArgs:\n    opener (callable): A function that returns a file-like object (either an in-memory text object or a file opened in text mode).\n\nReturns:\n    None\n\nRaises:\n    ValueError: If send_file is given a text-mode file object instead of a binary-mode file object.\n\"\"\"",
                    "source_code": "file = opener(app)\n\n        with pytest.raises(ValueError):\n            flask.send_file(file, mimetype=\"text/plain\")\n\n        file.close()"
                },
                {
                    "docstring": null,
                    "method_name": "test_send_file_pathlike",
                    "second_doc": "\"\"\"\nTests that send_file correctly handles a path-like object as its argument, ensuring the response has the proper direct passthrough behavior and the expected file content and MIME type. This ensures compatibility with different types of file inputs and verifies reliable file serving in HTTP responses.\n\nArgs:\n    self: The test case instance.\n\nReturns:\n    None\n\"\"\"",
                    "source_code": "rv = flask.send_file(FakePath(\"static/index.html\"))\n        assert rv.direct_passthrough\n        assert rv.mimetype == \"text/html\"\n        with app.open_resource(\"static/index.html\") as f:\n            rv.direct_passthrough = False\n            assert rv.data == f.read()\n        rv.close()"
                },
                {
                    "docstring": null,
                    "method_name": "test_send_file_range_request",
                    "second_doc": "\"\"\"\nTests the server's ability to correctly handle HTTP Range requests when serving files. This ensures that partial content delivery follows HTTP standards and clients can efficiently request file segments, supporting use cases like resuming downloads or streaming.\n\nArgs:\n    self: The test class instance providing access to the Flask app and client fixtures.\n\nReturns:\n    None. Assertions are used to verify correctness of server responses for various valid and invalid Range header scenarios.\n\"\"\"",
                    "source_code": "@app.route(\"/\")\n        def index():\n            return flask.send_file(\"static/index.html\", conditional=True)\n\n        rv = client.get(\"/\", headers={\"Range\": \"bytes=4-15\"})\n        assert rv.status_code == 206\n        with app.open_resource(\"static/index.html\") as f:\n            assert rv.data == f.read()[4:16]\n        rv.close()\n\n        rv = client.get(\"/\", headers={\"Range\": \"bytes=4-\"})\n        assert rv.status_code == 206\n        with app.open_resource(\"static/index.html\") as f:\n            assert rv.data == f.read()[4:]\n        rv.close()\n\n        rv = client.get(\"/\", headers={\"Range\": \"bytes=4-1000\"})\n        assert rv.status_code == 206\n        with app.open_resource(\"static/index.html\") as f:\n            assert rv.data == f.read()[4:]\n        rv.close()\n\n        rv = client.get(\"/\", headers={\"Range\": \"bytes=-10\"})\n        assert rv.status_code == 206\n        with app.open_resource(\"static/index.html\") as f:\n            assert rv.data == f.read()[-10:]\n        rv.close()\n\n        rv = client.get(\"/\", headers={\"Range\": \"bytes=1000-\"})\n        assert rv.status_code == 416\n        rv.close()\n\n        rv = client.get(\"/\", headers={\"Range\": \"bytes=-\"})\n        assert rv.status_code == 416\n        rv.close()\n\n        rv = client.get(\"/\", headers={\"Range\": \"somethingsomething\"})\n        assert rv.status_code == 416\n        rv.close()\n\n        last_modified = datetime.datetime.utcfromtimestamp(\n            os.path.getmtime(os.path.join(app.root_path, \"static/index.html\"))\n        ).replace(microsecond=0)\n\n        rv = client.get(\n            \"/\", headers={\"Range\": \"bytes=4-15\", \"If-Range\": http_date(last_modified)}\n        )\n        assert rv.status_code == 206\n        rv.close()\n\n        rv = client.get(\n            \"/\",\n            headers={\n                \"Range\": \"bytes=4-15\",\n                \"If-Range\": http_date(datetime.datetime(1999, 1, 1)),\n            },\n        )\n        assert rv.status_code == 200\n        rv.close()"
                },
                {
                    "docstring": null,
                    "method_name": "test_send_file_range_request_bytesio",
                    "second_doc": "\"\"\"\nTests that sending a HTTP Range request to a route serving a BytesIO file returns the correct partial content response. This ensures the server correctly handles range requests for file-like objects, providing only the requested byte subset, which helps with efficient file transfers and resuming downloads.\n\nArgs:\n    self: The test instance.\n\nReturns:\n    None. Performs assertions to validate correct HTTP status code and content in the response.\n\"\"\"",
                    "source_code": "@app.route(\"/\")\n        def index():\n            file = io.BytesIO(b\"somethingsomething\")\n            return flask.send_file(\n                file, attachment_filename=\"filename\", conditional=True\n            )\n\n        rv = client.get(\"/\", headers={\"Range\": \"bytes=4-15\"})\n        assert rv.status_code == 206\n        assert rv.data == b\"somethingsomething\"[4:16]\n        rv.close()"
                },
                {
                    "docstring": null,
                    "method_name": "test_send_file_range_request_xsendfile_invalid",
                    "second_doc": "\"\"\"\nTests that when using X-Sendfile and a client requests a range of bytes beyond the available content, the server correctly responds with a '416 Range Not Satisfiable' status. This ensures the application properly handles invalid range requests, which helps maintain robustness and proper HTTP compliance in file serving.\n\nArgs:\n    self: The test case instance.\n\nReturns:\n    None\n\"\"\"",
                    "source_code": "app.use_x_sendfile = True\n\n        @app.route(\"/\")\n        def index():\n            return flask.send_file(\"static/index.html\", conditional=True)\n\n        rv = client.get(\"/\", headers={\"Range\": \"bytes=1000-\"})\n        assert rv.status_code == 416\n        rv.close()"
                },
                {
                    "docstring": null,
                    "method_name": "test_attachment",
                    "second_doc": "\"\"\"\nTests that files and streams are correctly sent as downloadable attachments in HTTP responses by verifying the appropriate headers and behaviors. This ensures that file downloads in the application behave as expected for different file sources and configurations.\n\nArgs:\n    self: The test class instance (implicit, as this is a method).\n\nReturns:\n    None\n\"\"\"",
                    "source_code": "app = flask.Flask(__name__)\n        with app.test_request_context():\n            with open(os.path.join(app.root_path, \"static/index.html\"), \"rb\") as f:\n                rv = flask.send_file(\n                    f, as_attachment=True, attachment_filename=\"index.html\"\n                )\n                value, options = parse_options_header(rv.headers[\"Content-Disposition\"])\n                assert value == \"attachment\"\n                rv.close()\n\n        with open(os.path.join(app.root_path, \"static/index.html\"), \"rb\") as f:\n            rv = flask.send_file(\n                f, as_attachment=True, attachment_filename=\"index.html\"\n            )\n            value, options = parse_options_header(rv.headers[\"Content-Disposition\"])\n            assert value == \"attachment\"\n            assert options[\"filename\"] == \"index.html\"\n            assert \"filename*\" not in rv.headers[\"Content-Disposition\"]\n            rv.close()\n\n        rv = flask.send_file(\"static/index.html\", as_attachment=True)\n        value, options = parse_options_header(rv.headers[\"Content-Disposition\"])\n        assert value == \"attachment\"\n        assert options[\"filename\"] == \"index.html\"\n        rv.close()\n\n        rv = flask.send_file(\n            io.BytesIO(b\"Test\"),\n            as_attachment=True,\n            attachment_filename=\"index.txt\",\n            add_etags=False,\n        )\n        assert rv.mimetype == \"text/plain\"\n        value, options = parse_options_header(rv.headers[\"Content-Disposition\"])\n        assert value == \"attachment\"\n        assert options[\"filename\"] == \"index.txt\"\n        rv.close()"
                },
                {
                    "docstring": null,
                    "method_name": "test_attachment_filename_encoding",
                    "second_doc": "\"\"\"\nTests that the Content-Disposition header sets the correct encoding of attachment filenames sent with files, ensuring that non-ASCII characters are properly handled for file downloads.\n\nArgs:\n    filename (str): The original filename to be sent as an attachment, which may include non-ASCII characters.\n    ascii (str): The expected ASCII-safe representation of the filename in the Content-Disposition header.\n    utf8 (str or bool): The expected percent-encoded UTF-8 representation for non-ASCII filenames, or False when not applicable.\n\nReturns:\n    None. Asserts correct Content-Disposition header values to validate filename handling for different character encodings.\n\nWhy:\n    This method verifies that file attachments are delivered with appropriately encoded filenames in HTTP responses, ensuring compatibility across different clients and proper handling of internationalized filenames during downloads.\n\"\"\"",
                    "source_code": "rv = flask.send_file(\n            \"static/index.html\", as_attachment=True, attachment_filename=filename\n        )\n        rv.close()\n        content_disposition = rv.headers[\"Content-Disposition\"]\n        assert f\"filename={ascii}\" in content_disposition\n        if utf8:\n            assert f\"filename*=UTF-8''{utf8}\" in content_disposition\n        else:\n            assert \"filename*=UTF-8''\" not in content_disposition"
                },
                {
                    "docstring": null,
                    "method_name": "test_static_file",
                    "second_doc": "\"\"\"\nTests that static files are served with the correct cache-control headers based on various configuration settings and methods of file delivery. This ensures efficient client-side caching and proper handling of static content according to application settings.\n\nArgs:\n    self: The test case instance.\n\nReturns:\n    None\n\"\"\"",
                    "source_code": "rv = app.send_static_file(\"index.html\")\n        cc = parse_cache_control_header(rv.headers[\"Cache-Control\"])\n        assert cc.max_age == 12 * 60 * 60\n        rv.close()\n        # Test again with direct use of send_file utility.\n        rv = flask.send_file(\"static/index.html\")\n        cc = parse_cache_control_header(rv.headers[\"Cache-Control\"])\n        assert cc.max_age == 12 * 60 * 60\n        rv.close()\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = 3600\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        cc = parse_cache_control_header(rv.headers[\"Cache-Control\"])\n        assert cc.max_age == 3600\n        rv.close()\n        # Test again with direct use of send_file utility.\n        rv = flask.send_file(\"static/index.html\")\n        cc = parse_cache_control_header(rv.headers[\"Cache-Control\"])\n        assert cc.max_age == 3600\n        rv.close()\n\n        # Test with static file handler.\n        rv = app.send_static_file(FakePath(\"index.html\"))\n        cc = parse_cache_control_header(rv.headers[\"Cache-Control\"])\n        assert cc.max_age == 3600\n        rv.close()\n\n        class StaticFileApp(flask.Flask):\n            def get_send_file_max_age(self, filename):\n                return 10\n\n        app = StaticFileApp(__name__)\n        with app.test_request_context():\n            # Test with static file handler.\n            rv = app.send_static_file(\"index.html\")\n            cc = parse_cache_control_header(rv.headers[\"Cache-Control\"])\n            assert cc.max_age == 10\n            rv.close()\n            # Test again with direct use of send_file utility.\n            rv = flask.send_file(\"static/index.html\")\n            cc = parse_cache_control_header(rv.headers[\"Cache-Control\"])\n            assert cc.max_age == 10\n            rv.close()"
                },
                {
                    "docstring": null,
                    "method_name": "test_send_from_directory",
                    "second_doc": "\"\"\"\nTests that files can be served correctly from a given directory configured within the application's file system, ensuring that content delivery matches the expected result.\n\nArgs:\n    self: An instance of the test case class.\n\nReturns:\n    None. Asserts internally that the response data matches the expected file content.\n\nWhy:\n    To validate that the mechanism responsible for serving static files from specified directories works as intended, providing confidence in file access routines within the application's environment.\n\"\"\"",
                    "source_code": "app.root_path = os.path.join(\n            os.path.dirname(__file__), \"test_apps\", \"subdomaintestmodule\"\n        )\n        rv = flask.send_from_directory(\"static\", \"hello.txt\")\n        rv.direct_passthrough = False\n        assert rv.data.strip() == b\"Hello Subdomain\"\n        rv.close()"
                },
                {
                    "docstring": null,
                    "method_name": "test_send_from_directory_pathlike",
                    "second_doc": "\"\"\"\nTests that files can be sent from a directory when both the directory and filename are provided as path-like objects, ensuring compatibility with filesystems and Python's path abstraction.\n\nArgs:\n    self: The test case instance.\n\nReturns:\n    None. Asserts that the file content returned matches the expected value to confirm correct behavior.\n\"\"\"",
                    "source_code": "app.root_path = os.path.join(\n            os.path.dirname(__file__), \"test_apps\", \"subdomaintestmodule\"\n        )\n        rv = flask.send_from_directory(FakePath(\"static\"), FakePath(\"hello.txt\"))\n        rv.direct_passthrough = False\n        assert rv.data.strip() == b\"Hello Subdomain\"\n        rv.close()"
                },
                {
                    "docstring": null,
                    "method_name": "test_send_from_directory_null_character",
                    "second_doc": "\"\"\"\nTests that attempting to send a file with a null character in the filename raises an appropriate exception, ensuring the framework effectively prevents malformed or potentially unsafe file paths.\n\nArgs:\n    self: The test case instance.\n\nReturns:\n    None. Raises an exception if the test fails.\n\"\"\"",
                    "source_code": "app.root_path = os.path.join(\n            os.path.dirname(__file__), \"test_apps\", \"subdomaintestmodule\"\n        )\n\n        if sys.version_info >= (3, 8):\n            exception = NotFound\n        else:\n            exception = BadRequest\n\n        with pytest.raises(exception):\n            flask.send_from_directory(\"static\", \"bad\\x00\")"
                }
            ],
            "name": "TestSendfile",
            "type": "class"
        },
        {
            "methods": [
                {
                    "docstring": null,
                    "method_name": "test_url_for_with_anchor",
                    "second_doc": "\"\"\"\nTests that the url_for function correctly generates URLs with anchors, ensuring that special characters in the anchor component are properly URL-encoded for browser compatibility.\n\nArgs:\n    self: The test case instance.\n\nReturns:\n    None\n\"\"\"",
                    "source_code": "@app.route(\"/\")\n        def index():\n            return \"42\"\n\n        assert flask.url_for(\"index\", _anchor=\"x y\") == \"/#x%20y\""
                },
                {
                    "docstring": null,
                    "method_name": "test_url_for_with_scheme",
                    "second_doc": "\"\"\"\nTests that the function for generating URLs can correctly construct an external URL using a specific URL scheme.\n\nArgs:\n    None\n\nReturns:\n    None\n\nWhy:\n    This method ensures that URLs generated within the application respect explicit scheme and externality parameters, which is important for creating links that function correctly in different deployment or security contexts.\n\"\"\"",
                    "source_code": "@app.route(\"/\")\n        def index():\n            return \"42\"\n\n        assert (\n            flask.url_for(\"index\", _external=True, _scheme=\"https\")\n            == \"https://localhost/\"\n        )"
                },
                {
                    "docstring": null,
                    "method_name": "test_url_for_with_scheme_not_external",
                    "second_doc": "\"\"\"\nTests that using the _scheme parameter with url_for on a non-external endpoint raises a ValueError, ensuring proper validation of URL generation arguments within the routing system.\n\nArgs:\n    None\n\nReturns:\n    None\n\nRaises:\n    ValueError: If url_for is called with _scheme specified for a non-external route.\n\"\"\"",
                    "source_code": "@app.route(\"/\")\n        def index():\n            return \"42\"\n\n        pytest.raises(ValueError, flask.url_for, \"index\", _scheme=\"https\")"
                },
                {
                    "docstring": null,
                    "method_name": "test_url_for_with_alternating_schemes",
                    "second_doc": "\"\"\"\nTests that URL generation properly handles explicit external schemes, ensuring correct domain and protocol are produced when building URLs. This verifies the consistency and correctness of link generation in different deployment scenarios.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                    "source_code": "@app.route(\"/\")\n        def index():\n            return \"42\"\n\n        assert flask.url_for(\"index\", _external=True) == \"http://localhost/\"\n        assert (\n            flask.url_for(\"index\", _external=True, _scheme=\"https\")\n            == \"https://localhost/\"\n        )\n        assert flask.url_for(\"index\", _external=True) == \"http://localhost/\""
                },
                {
                    "docstring": null,
                    "method_name": "test_url_with_method",
                    "second_doc": "\"\"\"\nTests that URL generation with different HTTP methods and arguments produces the correct endpoint URLs when using method-based views.\n\nArgs:\n    self: The test case instance.\n\nReturns:\n    None\n\nWhy:\n    This ensures that route resolution and URL generation in the framework correctly interpret HTTP methods and parameters for method-based views, which is vital for routing requests and building navigational links.\n\"\"\"",
                    "source_code": "from flask.views import MethodView\n\n        class MyView(MethodView):\n            def get(self, id=None):\n                if id is None:\n                    return \"List\"\n                return f\"Get {id:d}\"\n\n            def post(self):\n                return \"Create\"\n\n        myview = MyView.as_view(\"myview\")\n        app.add_url_rule(\"/myview/\", methods=[\"GET\"], view_func=myview)\n        app.add_url_rule(\"/myview/<int:id>\", methods=[\"GET\"], view_func=myview)\n        app.add_url_rule(\"/myview/create\", methods=[\"POST\"], view_func=myview)\n\n        assert flask.url_for(\"myview\", _method=\"GET\") == \"/myview/\"\n        assert flask.url_for(\"myview\", id=42, _method=\"GET\") == \"/myview/42\"\n        assert flask.url_for(\"myview\", _method=\"POST\") == \"/myview/create\""
                }
            ],
            "name": "TestUrlFor",
            "type": "class"
        },
        {
            "methods": [
                {
                    "docstring": null,
                    "method_name": "test_name_with_import_error",
                    "second_doc": "\"\"\"\nTests that initializing a Flask application does not automatically import the module named after the application, which would raise an import error if the module contains problematic code.\n\nArgs:\n    modules_tmpdir: A pytest fixture providing a temporary directory for module files.\n\nReturns:\n    None. The test passes silently if Flask does not import the named module; otherwise, an assertion error is raised.\n\"\"\"",
                    "source_code": "modules_tmpdir.join(\"importerror.py\").write(\"raise NotImplementedError()\")\n        try:\n            flask.Flask(\"importerror\")\n        except NotImplementedError:\n            AssertionError(\"Flask(import_name) is importing import_name.\")"
                }
            ],
            "name": "TestNoImports",
            "type": "class"
        },
        {
            "methods": [
                {
                    "docstring": null,
                    "method_name": "test_streaming_with_context",
                    "second_doc": "\"\"\"\nTests that streaming a response with context correctly yields dynamic content based on the request arguments.\n\nArgs:\n    self: The test case instance.\n\nReturns:\n    None\n\nWhy:\n    Ensures that when generating a streamed response, Flask properly manages the request context, allowing access to request variables and dynamic composition of the response data.\n\"\"\"",
                    "source_code": "@app.route(\"/\")\n        def index():\n            def generate():\n                yield \"Hello \"\n                yield flask.request.args[\"name\"]\n                yield \"!\"\n\n            return flask.Response(flask.stream_with_context(generate()))\n\n        rv = client.get(\"/?name=World\")\n        assert rv.data == b\"Hello World!\""
                },
                {
                    "docstring": null,
                    "method_name": "test_streaming_with_context_as_decorator",
                    "second_doc": "\"\"\"\nTests that a streamed response can correctly access request context variables when using the streaming helper as a decorator.\n\nArgs:\n    self: The test case instance.\n\nReturns:\n    None. Asserts that the streamed response contains the expected concatenated string by validating the response data.\n\nWhy:\n    This method validates that streaming a response using a context preservation decorator allows access to the current request state, ensuring dynamic content can be yielded based on query parameters during streaming.\n\"\"\"",
                    "source_code": "@app.route(\"/\")\n        def index():\n            @flask.stream_with_context\n            def generate(hello):\n                yield hello\n                yield flask.request.args[\"name\"]\n                yield \"!\"\n\n            return flask.Response(generate(\"Hello \"))\n\n        rv = client.get(\"/?name=World\")\n        assert rv.data == b\"Hello World!\""
                },
                {
                    "docstring": null,
                    "method_name": "test_streaming_with_context_and_custom_close",
                    "second_doc": "\"\"\"\nTests whether a custom generator wrapper with a specific close method is properly invoked when streaming content in a Flask response with context management.\n\nArgs:\n    self: The test case instance.\n\nReturns:\n    None\n\nWhy:\n    This method ensures that when streaming a response using a custom iterable, resource cleanup or finalization logic (such as the close method) is executed, verifying Flask's correct handling of generator teardown in a streaming context.\n\"\"\"",
                    "source_code": "called = []\n\n        class Wrapper:\n            def __init__(self, gen):\n                self._gen = gen\n\n            def __iter__(self):\n                return self\n\n            def close(self):\n                called.append(42)\n\n            def __next__(self):\n                return next(self._gen)\n\n            next = __next__\n\n        @app.route(\"/\")\n        def index():\n            def generate():\n                yield \"Hello \"\n                yield flask.request.args[\"name\"]\n                yield \"!\"\n\n            return flask.Response(flask.stream_with_context(Wrapper(generate())))\n\n        rv = client.get(\"/?name=World\")\n        assert rv.data == b\"Hello World!\"\n        assert called == [42]"
                },
                {
                    "docstring": null,
                    "method_name": "test_stream_keeps_session",
                    "second_doc": "\"\"\"\nTest that a streamed response within a Flask route maintains access to the session data.\n\nThis method verifies that session data set before yielding a response is still accessible when using Flask's streaming support. This ensures consistency and expected behavior when streaming dynamic content tied to client-specific sessions.\n\nArgs:\n    self: The test class instance, providing access to the Flask test client.\n\nReturns:\n    None. Asserts that the streamed response contains the expected session value.\n\"\"\"",
                    "source_code": "@app.route(\"/\")\n        def index():\n            flask.session[\"test\"] = \"flask\"\n\n            @flask.stream_with_context\n            def gen():\n                yield flask.session[\"test\"]\n\n            return flask.Response(gen())\n\n        rv = client.get(\"/\")\n        assert rv.data == b\"flask\""
                }
            ],
            "name": "TestStreaming",
            "type": "class"
        },
        {
            "methods": [
                {
                    "docstring": null,
                    "method_name": "test_safe_join",
                    "second_doc": "\"\"\"\nTests that the safe_join function correctly joins path segments, handling various edge cases to ensure reliable and predictable path construction.\n\nThis is important to prevent security risks and inconsistencies when combining file system paths in web applications, such as avoiding unintentional path traversal or malformed paths.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                    "source_code": "passing = (\n            ((\"a/b/c\",), \"a/b/c\"),\n            ((\"/\", \"a/\", \"b/\", \"c/\"), \"/a/b/c\"),\n            ((\"a\", \"b\", \"c\"), \"a/b/c\"),\n            ((\"/a\", \"b/c\"), \"/a/b/c\"),\n            ((\"a/b\", \"X/../c\"), \"a/b/c\"),\n            ((\"/a/b\", \"c/X/..\"), \"/a/b/c\"),\n            # If last path is '' add a slash\n            ((\"/a/b/c\", \"\"), \"/a/b/c/\"),\n            # Preserve dot slash\n            ((\"/a/b/c\", \"./\"), \"/a/b/c/.\"),\n            ((\"a/b/c\", \"X/..\"), \"a/b/c/.\"),\n            # Base directory is always considered safe\n            ((\"../\", \"a/b/c\"), \"../a/b/c\"),\n            ((\"/..\",), \"/..\"),\n        )\n\n        for args, expected in passing:\n            assert flask.safe_join(*args) == expected"
                },
                {
                    "docstring": null,
                    "method_name": "test_safe_join_exceptions",
                    "second_doc": "\"\"\"\nTests that improper or insecure path joins using flask.safe_join raise a NotFound exception, ensuring that only safe, valid paths are constructed and preventing directory traversal or access outside the intended base directory.\n\nArgs:\n    self: The test class instance.\n\nReturns:\n    None\n\"\"\"",
                    "source_code": "failing = (\n            # path.isabs and ``..'' checks\n            (\"/a\", \"b\", \"/c\"),\n            (\"/a\", \"../b/c\"),\n            (\"/a\", \"..\", \"b/c\"),\n            # Boundaries violations after path normalization\n            (\"/a\", \"b/../b/../../c\"),\n            (\"/a\", \"b\", \"c/../..\"),\n            (\"/a\", \"b/../../c\"),\n        )\n\n        for args in failing:\n            with pytest.raises(NotFound):\n                print(flask.safe_join(*args))"
                }
            ],
            "name": "TestSafeJoin",
            "type": "class"
        },
        {
            "methods": [
                {
                    "docstring": null,
                    "method_name": "test_get_debug_flag",
                    "second_doc": "\"\"\"\nTests how the system interprets various FLASK_DEBUG environment variable values to control debug mode, ensuring environment configuration is handled as expected for application behavior and safety.\n\nArgs:\n    monkeypatch: pytest fixture for modifying environment variables during the test.\n    debug (str): The value to set for the FLASK_DEBUG environment variable.\n    expected_flag (bool or None): The value expected to be returned from get_debug_flag().\n    expected_default_flag (bool): The default expectation from get_debug_flag() when called repeatedly.\n\nReturns:\n    None. Asserts conditions to verify correct interpretation of environment-based debug state.\n\"\"\"",
                    "source_code": "monkeypatch.setenv(\"FLASK_DEBUG\", debug)\n        if expected_flag is None:\n            assert get_debug_flag() is None\n        else:\n            assert get_debug_flag() == expected_flag\n        assert get_debug_flag() == expected_default_flag"
                },
                {
                    "docstring": null,
                    "method_name": "test_get_env",
                    "second_doc": "\"\"\"\nTests the behavior of environment variable parsing and debug flag determination for the application by simulating different FLASK_ENV values. This ensures the application responds with the correct configuration for various deployment environments.\n\nArgs:\n    env (str): The value to set for the 'FLASK_ENV' environment variable.\n    ref_env (str): The expected environment name returned by get_env().\n    debug (bool): The expected debug mode status as determined by get_debug_flag().\n\nReturns:\n    None: The function asserts expected outcomes but does not return a value.\n\"\"\"",
                    "source_code": "monkeypatch.setenv(\"FLASK_ENV\", env)\n        assert get_debug_flag() == debug\n        assert get_env() == ref_env"
                },
                {
                    "docstring": null,
                    "method_name": "test_make_response",
                    "second_doc": "\"\"\"\nTest the behavior of the make_response utility to ensure it generates HTTP responses with correct defaults and content when used within an application context.\n\nThis test verifies that, with and without arguments, the generated response object has appropriate status code, mimetype, and body. This helps maintain predictable HTTP response generation for various scenarios, which is essential for consistent web application behavior.\n\nArgs:\n    self: The test case instance.\n\nReturns:\n    None\n\"\"\"",
                    "source_code": "app = flask.Flask(__name__)\n        with app.test_request_context():\n            rv = flask.helpers.make_response()\n            assert rv.status_code == 200\n            assert rv.mimetype == \"text/html\"\n\n            rv = flask.helpers.make_response(\"Hello\")\n            assert rv.status_code == 200\n            assert rv.data == b\"Hello\"\n            assert rv.mimetype == \"text/html\""
                },
                {
                    "docstring": null,
                    "method_name": "test_open_resource",
                    "second_doc": "\"\"\"\nTests whether a resource file can be correctly opened from the application's static directory using various read modes. This method ensures that the resource access mechanism delivers consistent content across different file opening modes.\n\nArgs:\n    mode (str): The file mode to open the resource with; can be \"r\", \"rb\", or \"rt\".\n\nReturns:\n    None. Asserts that the expected content exists in the file to confirm resource accessibility.\n\"\"\"",
                    "source_code": "app = flask.Flask(__name__)\n\n        with app.open_resource(\"static/index.html\", mode) as f:\n            assert \"<h1>Hello World!</h1>\" in str(f.read())"
                },
                {
                    "docstring": null,
                    "method_name": "test_open_resource_exceptions",
                    "second_doc": "\"\"\"\nTest that attempting to open an application resource in an unsupported write or update mode raises a ValueError.\n\nThis test ensures that the Flask application's method for opening resources strictly enforces read-only access, preventing misuse by raising an exception when other modes are requested.\n\nArgs:\n    mode (str): The file mode in which to open the resource (one of \"w\", \"x\", \"a\", \"r+\").\n\nReturns:\n    None\n\"\"\"",
                    "source_code": "app = flask.Flask(__name__)\n\n        with pytest.raises(ValueError):\n            app.open_resource(\"static/index.html\", mode)"
                }
            ],
            "name": "TestHelpers",
            "type": "class"
        }
    ],
    "flask/tests/test_instance_config.py": [
        {
            "details": {
                "docstring": null,
                "method_name": "test_explicit_instance_paths",
                "second_doc": "\"\"\"\nTests that the Flask application enforces the requirement for an absolute instance path and properly sets the instance_path attribute when provided a valid path.\n\nThis ensures robust handling of application configuration paths to prevent user errors due to invalid paths and to verify correct assignment for valid ones.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "with pytest.raises(ValueError) as excinfo:\n        flask.Flask(__name__, instance_path=\"instance\")\n    assert \"must be absolute\" in str(excinfo.value)\n\n    app = flask.Flask(__name__, instance_path=str(modules_tmpdir))\n    assert app.instance_path == str(modules_tmpdir)"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_main_module_paths",
                "second_doc": "\"\"\"\nTests that the Flask application's instance_path is correctly set when the application is defined in a main module.\nThis ensures that the runtime environment and filesystem interactions behave as expected when initializing an app from the main module.\n\nArgs:\n    modules_tmpdir: A pytest fixture providing a temporary directory for module creation and isolation during the test.\n\nReturns:\n    None. Asserts that the created Flask app's instance_path matches the expected path.\n\"\"\"",
                "source_code": "app = modules_tmpdir.join(\"main_app.py\")\n    app.write('import flask\\n\\napp = flask.Flask(\"__main__\")')\n    purge_module(\"main_app\")\n\n    from main_app import app\n\n    here = os.path.abspath(os.getcwd())\n    assert app.instance_path == os.path.join(here, \"instance\")"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_uninstalled_module_paths",
                "second_doc": "\"\"\"\nTests that an application module, when not installed as part of a package, still resolves the default instance path correctly. \n\nThis ensures that even standalone scripts or modules are able to determine their instance folder location, which is critical for storing configuration and instance-specific files.\n\nArgs:\n    modules_tmpdir (py.path.local): Temporary directory object simulating the application module's file system location.\n\nReturns:\n    None. The test passes if the application's instance path is set as expected; otherwise, it fails or raises an assertion error.\n\"\"\"",
                "source_code": "app = modules_tmpdir.join(\"config_module_app.py\").write(\n        \"import os\\n\"\n        \"import flask\\n\"\n        \"here = os.path.abspath(os.path.dirname(__file__))\\n\"\n        \"app = flask.Flask(__name__)\\n\"\n    )\n    purge_module(\"config_module_app\")\n\n    from config_module_app import app\n\n    assert app.instance_path == str(modules_tmpdir.join(\"instance\"))"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_uninstalled_package_paths",
                "second_doc": "\"\"\"\nTests that the application's instance path is set correctly when imported from an uninstalled package location, ensuring consistent location resolution during development or testing environments.\n\nArgs:\n    modules_tmpdir: A temporary directory fixture used to simulate the package environment.\n\nReturns:\n    None. Asserts that the app's instance_path attribute matches the expected directory structure.\n\"\"\"",
                "source_code": "app = modules_tmpdir.mkdir(\"config_package_app\")\n    init = app.join(\"__init__.py\")\n    init.write(\n        \"import os\\n\"\n        \"import flask\\n\"\n        \"here = os.path.abspath(os.path.dirname(__file__))\\n\"\n        \"app = flask.Flask(__name__)\\n\"\n    )\n    purge_module(\"config_package_app\")\n\n    from config_package_app import app\n\n    assert app.instance_path == str(modules_tmpdir.join(\"instance\"))"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_installed_module_paths",
                "second_doc": "\"\"\"\nTests that a Flask application's instance path is set as expected when the module is installed to a site-packages directory, ensuring proper location of instance-specific files.\n\nArgs:\n    None\n\nReturns:\n    None\n\nWhy:\n    Verifies that the Flask application correctly determines its instance path in environments where modules are installed system-wide, which is crucial for managing configurations and files unique to each application instance.\n\"\"\"",
                "source_code": "site_packages.join(\"site_app.py\").write(\n        \"import flask\\napp = flask.Flask(__name__)\\n\"\n    )\n    purge_module(\"site_app\")\n\n    from site_app import app\n\n    assert app.instance_path == modules_tmpdir.join(\"var\").join(\"site_app-instance\")"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_installed_package_paths",
                "second_doc": "\"\"\"\nTests that a Flask application's instance path is set correctly when the package is installed in a typical environment.\n\nArgs:\n    modules_tmpdir: A pytest fixture providing a temporary directory structure for Python modules.\n    monkeypatch: A pytest fixture for modifying and restoring sys.path during the test.\n\nReturns:\n    None. Asserts internally to verify correct behavior.\n\nWhy:\n    Verifying the application's instance path ensures that package installation and Flask's path logic work as expected, which is essential for correct configuration and deployment of applications that depend on dynamic file locations.\n\"\"\"",
                "source_code": "installed_path = modules_tmpdir.mkdir(\"path\")\n    monkeypatch.syspath_prepend(installed_path)\n\n    app = installed_path.mkdir(\"installed_package\")\n    init = app.join(\"__init__.py\")\n    init.write(\"import flask\\napp = flask.Flask(__name__)\")\n    purge_module(\"installed_package\")\n\n    from installed_package import app\n\n    assert app.instance_path == modules_tmpdir.join(\"var\").join(\n        \"installed_package-instance\"\n    )"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_prefix_package_paths",
                "second_doc": "\"\"\"\nTests that a package's Flask application instance_path is correctly set based on its package location.\n\nThis method creates a mock package, writes an __init__.py file initializing a Flask app, purges it from the import cache, and verifies that the Flask app's instance_path is configured as expected. This ensures applications installed as packages resolve their instance path accurately for consistent environment separation and configuration loading.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "app = site_packages.mkdir(\"site_package\")\n    init = app.join(\"__init__.py\")\n    init.write(\"import flask\\napp = flask.Flask(__name__)\")\n    purge_module(\"site_package\")\n\n    import site_package\n\n    assert site_package.app.instance_path == modules_tmpdir.join(\"var\").join(\n        \"site_package-instance\"\n    )"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_egg_installed_paths",
                "second_doc": "\"\"\"\nTests that when a package is installed in egg format, the Flask application sets its instance path correctly. \n\nThis is important to verify that Flask can accurately determine the instance directory for packages installed as eggs, which ensures that application configuration and data storage remain consistent across different installation methods.\n\nArgs:\n    modules_tmpdir: A temporary directory fixture used for creating and installing the test egg package.\n\nReturns:\n    None. Raises an assertion error if the instance path does not match the expected location.\n\"\"\"",
                "source_code": "modules_tmpdir.mkdir(\"site_egg\").join(\"__init__.py\").write(\n        \"import flask\\n\\napp = flask.Flask(__name__)\"\n    )\n    install_egg(\"site_egg\")\n    try:\n        import site_egg\n\n        assert site_egg.app.instance_path == str(\n            modules_tmpdir.join(\"var/\").join(\"site_egg-instance\")\n        )\n    finally:\n        if \"site_egg\" in sys.modules:\n            del sys.modules[\"site_egg\"]"
            },
            "type": "function"
        }
    ],
    "flask/tests/test_json_tag.py": [
        {
            "details": {
                "docstring": null,
                "method_name": "test_dump_load_unchanged",
                "second_doc": "\"\"\"\nTests that the TaggedJSONSerializer can serialize and deserialize various data types without data loss or modification.\n\nArgs:\n    data: Arbitrary data inputs of varying types, including dicts, tuples, bytes, strings, specialized objects (e.g., Markup, UUIDs, datetimes), to verify the integrity of the (de)serialization process.\n\nReturns:\n    None. Asserts that the input data remains unchanged after being dumped and then loaded, ensuring data consistency.\n\nWhy:\n    Ensures reliable preservation of data structures when serializing and deserializing, which is critical for accurately handling diverse user data and maintaining application state.\n\"\"\"",
                "source_code": "s = TaggedJSONSerializer()\n    assert s.loads(s.dumps(data)) == data"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_duplicate_tag",
                "second_doc": "\"\"\"\nTests the registration of a new tag class to ensure that duplicate tag keys raise an error unless explicitly overridden.\n\nArgs:\n    None\n\nReturns:\n    None\n\nWhy:\n    This method verifies that the serializer enforces unique tag identifiers to prevent accidental overwrites, thus maintaining data integrity and predictable class mapping behavior.\n\"\"\"",
                "source_code": "class TagDict(JSONTag):\n        key = \" d\"\n\n    s = TaggedJSONSerializer()\n    pytest.raises(KeyError, s.register, TagDict)\n    s.register(TagDict, force=True, index=0)\n    assert isinstance(s.tags[\" d\"], TagDict)\n    assert isinstance(s.order[0], TagDict)"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_custom_tag",
                "second_doc": "\"\"\"\nTests the serialization and deserialization of custom Python objects using a user-defined JSON tag, ensuring that objects retain their structure and data when converted to and from a tagged JSON format.\n\nArgs:\n    None\n\nReturns:\n    None\n\nWhy:\n    This test ensures that custom object types can be correctly encoded and decoded using the serializer's tagging system, which is critical for supporting complex data persistence and transfer within applications.\n\"\"\"",
                "source_code": "class Foo:  # noqa: B903, for Python2 compatibility\n        def __init__(self, data):\n            self.data = data\n\n    class TagFoo(JSONTag):\n        __slots__ = ()\n        key = \" f\"\n\n        def check(self, value):\n            return isinstance(value, Foo)\n\n        def to_json(self, value):\n            return self.serializer.tag(value.data)\n\n        def to_python(self, value):\n            return Foo(value)\n\n    s = TaggedJSONSerializer()\n    s.register(TagFoo)\n    assert s.loads(s.dumps(Foo(\"bar\"))).data == \"bar\""
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_tag_interface",
                "second_doc": "\"\"\"\nTests that the JSONTag interface correctly enforces implementation of required methods by raising NotImplementedError when its abstract methods are called.\n\nThis ensures that any subclass must override these methods to provide concrete behavior, thereby maintaining consistency and preventing misuse of the base interface.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "t = JSONTag(None)\n    pytest.raises(NotImplementedError, t.check, None)\n    pytest.raises(NotImplementedError, t.to_json, None)\n    pytest.raises(NotImplementedError, t.to_python, None)"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_tag_order",
                "second_doc": "\"\"\"\nTests that custom JSON tag classes are registered in the expected order within the serializer's registry.\n\nThis ensures consistent serialization behavior when handling data with user-defined or plugin-provided types.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "class Tag1(JSONTag):\n        key = \" 1\"\n\n    class Tag2(JSONTag):\n        key = \" 2\"\n\n    s = TaggedJSONSerializer()\n\n    s.register(Tag1, index=-1)\n    assert isinstance(s.order[-2], Tag1)\n\n    s.register(Tag2, index=None)\n    assert isinstance(s.order[-1], Tag2)"
            },
            "type": "function"
        }
    ],
    "flask/tests/test_logging.py": [
        {
            "details": {
                "docstring": null,
                "method_name": "reset_logging",
                "second_doc": "\"\"\"\nResets the logging configuration before and after each test to ensure test isolation and prevent side effects from log handlers and logger state changes.\n\nArgs:\n    pytestconfig: The pytest configuration object, used to access and manage plugins.\n\nYields:\n    None. This is a pytest fixture that temporarily resets and then restores logging state for the test's duration.\n\"\"\"",
                "source_code": "root_handlers = logging.root.handlers[:]\n    logging.root.handlers = []\n    root_level = logging.root.level\n\n    logger = logging.getLogger(\"flask_test\")\n    logger.handlers = []\n    logger.setLevel(logging.NOTSET)\n\n    logging_plugin = pytestconfig.pluginmanager.unregister(name=\"logging-plugin\")\n\n    yield\n\n    logging.root.handlers[:] = root_handlers\n    logging.root.setLevel(root_level)\n\n    logger.handlers = []\n    logger.setLevel(logging.NOTSET)\n\n    if logging_plugin:\n        pytestconfig.pluginmanager.register(logging_plugin, \"logging-plugin\")"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_logger",
                "second_doc": "\"\"\"\nTests whether the application's logger is properly configured with the expected name, level, and handler setup.\n\nThis method ensures that the application's logging infrastructure adheres to standard settings, maintaining predictable and reliable logging behavior which is crucial for effective debugging and monitoring during development and testing.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "assert app.logger.name == \"flask_test\"\n    assert app.logger.level == logging.NOTSET\n    assert app.logger.handlers == [default_handler]"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_logger_debug",
                "second_doc": "\"\"\"\nTests that enabling debug mode on the application sets the logger to debug level and ensures the correct handler is used.\n\nThis is important to guarantee consistent and informative logging output during development, aiding in troubleshooting and ensuring that only the intended log handlers are active.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "app.debug = True\n    assert app.logger.level == logging.DEBUG\n    assert app.logger.handlers == [default_handler]"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_existing_handler",
                "second_doc": "\"\"\"\nTests that adding a global stream handler to the logging root does not affect the application's logger handlers or logging level. \n\nThis method ensures the isolation of the application's logging configuration when system-wide handlers are present, allowing applications to retain predictable logging behavior regardless of external logging changes.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "logging.root.addHandler(logging.StreamHandler())\n    assert app.logger.level == logging.NOTSET\n    assert not app.logger.handlers"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_wsgi_errors_stream",
                "second_doc": "\"\"\"\nTest that the error logging stream during request handling can be correctly redirected and managed.\n\nThis ensures that errors are captured in the appropriate stream depending on the request context, allowing flexible logging and easier debugging during application development and testing.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "@app.route(\"/\")\n    def index():\n        app.logger.error(\"test\")\n        return \"\"\n\n    stream = StringIO()\n    client.get(\"/\", errors_stream=stream)\n    assert \"ERROR in test_logging: test\" in stream.getvalue()\n\n    assert wsgi_errors_stream._get_current_object() is sys.stderr\n\n    with app.test_request_context(errors_stream=stream):\n        assert wsgi_errors_stream._get_current_object() is stream"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_has_level_handler",
                "second_doc": "\"\"\"\nTests the behavior of the has_level_handler utility by verifying whether a logger can properly detect if it has a handler set for a specific logging level. This ensures logging events are appropriately processed or propagated based on handler presence and configuration.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "logger = logging.getLogger(\"flask.app\")\n    assert not has_level_handler(logger)\n\n    handler = logging.StreamHandler()\n    logging.root.addHandler(handler)\n    assert has_level_handler(logger)\n\n    logger.propagate = False\n    assert not has_level_handler(logger)\n    logger.propagate = True\n\n    handler.setLevel(logging.ERROR)\n    assert not has_level_handler(logger)"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_log_view_exception",
                "second_doc": "\"\"\"\nTests if the application correctly logs exceptions occurring during request handling and returns the appropriate error response.\n\nThis method verifies that when an exception is raised during the handling of a request, the error is logged as expected and the client receives an HTTP 500 response.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "@app.route(\"/\")\n    def index():\n        raise Exception(\"test\")\n\n    app.testing = False\n    stream = StringIO()\n    rv = client.get(\"/\", errors_stream=stream)\n    assert rv.status_code == 500\n    assert rv.data\n    err = stream.getvalue()\n    assert \"Exception on / [GET]\" in err\n    assert \"Exception: test\" in err"
            },
            "type": "function"
        }
    ],
    "flask/tests/test_regression.py": [
        {
            "methods": [
                {
                    "docstring": null,
                    "method_name": "__enter__",
                    "second_doc": "\"\"\"\nPrepares the environment for leak detection by freezing the current state of tracked Python objects and ensuring deterministic garbage collection. This makes subsequent checks for resource leaks reliable during framework operations.\n\nArgs:\n    self: The instance of the assert_no_leak class.\n\nReturns:\n    self: Returns the context manager instance after setting up the leak-detection state.\n\"\"\"",
                    "source_code": "gc.disable()\n        _gc_lock.acquire()\n        loc = flask._request_ctx_stack._local\n\n        # Force Python to track this dictionary at all times.\n        # This is necessary since Python only starts tracking\n        # dicts if they contain mutable objects.  It's a horrible,\n        # horrible hack but makes this kinda testable.\n        loc.__storage__[\"FOOO\"] = [1, 2, 3]\n\n        gc.collect()\n        self.old_objects = len(gc.get_objects())"
                },
                {
                    "docstring": null,
                    "method_name": "__exit__",
                    "second_doc": "\"\"\"\nEnsures that test code does not introduce unexpected memory object leaks by comparing the number of tracked objects before and after the code block execution. If there are more objects after execution than before, the test fails.\n\nThis helps maintain reliability and cleanliness in the test environment by detecting inadvertent memory retention during test runs.\n\nArgs:\n    exc_type (type): The type of the exception raised (if any) within the context.\n    exc_value (Exception): The exception instance raised (if any).\n    traceback (traceback): Traceback object associated with the exception.\n\nReturns:\n    None\n\"\"\"",
                    "source_code": "gc.collect()\n        new_objects = len(gc.get_objects())\n        if new_objects > self.old_objects:\n            pytest.fail(\"Example code leaked\")\n        _gc_lock.release()\n        gc.enable()"
                }
            ],
            "name": "assert_no_leak",
            "type": "class"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_memory_consumption",
                "second_doc": "\"\"\"\nTests that repeated requests to render a template do not cause a memory leak in the application.\n\nThis ensures that the system efficiently manages resources when handling multiple incoming requests and rendering templates, thereby maintaining application stability during normal usage.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "app = flask.Flask(__name__)\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"simple_template.html\", whiskey=42)\n\n    def fire():\n        with app.test_client() as c:\n            rv = c.get(\"/\")\n            assert rv.status_code == 200\n            assert rv.data == b\"<h1>42</h1>\"\n\n    # Trigger caches\n    fire()\n\n    with assert_no_leak():\n        for _x in range(10):\n            fire()"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_safe_join_toplevel_pardir",
                "second_doc": "\"\"\"\nTest that safe_join raises a NotFound exception when attempting to navigate above the top-level directory.\n\nThis method ensures that directory traversal attempts leveraging parent directory references are properly blocked, preventing unsafe file path access.\n\nArgs:\n    None\n\nReturns:\n    None\n\nRaises:\n    AssertionError: If safe_join does not raise a NotFound exception as expected.\n\"\"\"",
                "source_code": "from flask.helpers import safe_join\n\n    with pytest.raises(NotFound):\n        safe_join(\"/foo\", \"..\")"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_aborting",
                "second_doc": "\"\"\"\nTests custom error handling and redirect behavior in route handlers.\nThis method simulates request handling for specific routes to ensure that custom exceptions are processed and HTTP redirects are correctly performed. By raising exceptions and examining the resulting HTTP responses, it validates that the application's error and redirect mechanisms work as intended.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "class Foo(Exception):\n        whatever = 42\n\n    @app.errorhandler(Foo)\n    def handle_foo(e):\n        return str(e.whatever)\n\n    @app.route(\"/\")\n    def index():\n        raise flask.abort(flask.redirect(flask.url_for(\"test\")))\n\n    @app.route(\"/test\")\n    def test():\n        raise Foo()\n\n    with app.test_client() as c:\n        rv = c.get(\"/\")\n        assert rv.headers[\"Location\"] == \"http://localhost/test\"\n        rv = c.get(\"/test\")\n        assert rv.data == b\"42\""
            },
            "type": "function"
        }
    ],
    "flask/tests/test_reqctx.py": [
        {
            "details": {
                "docstring": null,
                "method_name": "test_teardown_on_pop",
                "second_doc": "\"\"\"\nTests that the teardown_request callback is properly triggered when the request context is popped, ensuring that cleanup logic is executed at the appropriate lifecycle moment.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "buffer = []\n\n    @app.teardown_request\n    def end_of_request(exception):\n        buffer.append(exception)\n\n    ctx = app.test_request_context()\n    ctx.push()\n    assert buffer == []\n    ctx.pop()\n    assert buffer == [None]"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_teardown_with_previous_exception",
                "second_doc": "\"\"\"\nTests the teardown_request behavior when a previous exception has been handled, ensuring the teardown function receives the correct exception context.\n\nArgs:\n    None\n\nReturns:\n    None\n\nWhy:\n    This method verifies that after an exception is raised and handled before entering a Flask request context, the teardown handler is still invoked as expected during request teardown, and that it receives the appropriate exception (None in this case). This helps ensure Flask's teardown mechanism maintains consistent cleanup semantics even in the presence of prior exceptions.\n\"\"\"",
                "source_code": "buffer = []\n\n    @app.teardown_request\n    def end_of_request(exception):\n        buffer.append(exception)\n\n    try:\n        raise Exception(\"dummy\")\n    except Exception:\n        pass\n\n    with app.test_request_context():\n        assert buffer == []\n    assert buffer == [None]"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_teardown_with_handled_exception",
                "second_doc": "\"\"\"\nTests that the teardown request handler receives None when an exception is raised and caught during a request, ensuring proper cleanup behavior even when errors are handled internally.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "buffer = []\n\n    @app.teardown_request\n    def end_of_request(exception):\n        buffer.append(exception)\n\n    with app.test_request_context():\n        assert buffer == []\n        try:\n            raise Exception(\"dummy\")\n        except Exception:\n            pass\n    assert buffer == [None]"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_proper_test_request_context",
                "second_doc": "\"\"\"\nTests the behavior of Flask's request context, especially in relation to URL generation and server configuration overrides.\n\nThis method verifies that the application correctly handles test request contexts and generates proper URLs according to the app configuration, including handling subdomains and different SERVER_NAME settings. This ensures that internal mechanisms for managing context and routing operate as intended under various conditions, which is crucial for predictable request handling and application testing.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "app.config.update(SERVER_NAME=\"localhost.localdomain:5000\")\n\n    @app.route(\"/\")\n    def index():\n        return None\n\n    @app.route(\"/\", subdomain=\"foo\")\n    def sub():\n        return None\n\n    with app.test_request_context(\"/\"):\n        assert (\n            flask.url_for(\"index\", _external=True)\n            == \"http://localhost.localdomain:5000/\"\n        )\n\n    with app.test_request_context(\"/\"):\n        assert (\n            flask.url_for(\"sub\", _external=True)\n            == \"http://foo.localhost.localdomain:5000/\"\n        )\n\n    # suppress Werkzeug 0.15 warning about name mismatch\n    with pytest.warns(None):\n        with app.test_request_context(\n            \"/\", environ_overrides={\"HTTP_HOST\": \"localhost\"}\n        ):\n            pass\n\n    app.config.update(SERVER_NAME=\"localhost\")\n    with app.test_request_context(\"/\", environ_overrides={\"SERVER_NAME\": \"localhost\"}):\n        pass\n\n    app.config.update(SERVER_NAME=\"localhost:80\")\n    with app.test_request_context(\n        \"/\", environ_overrides={\"SERVER_NAME\": \"localhost:80\"}\n    ):\n        pass"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_context_binding",
                "second_doc": "\"\"\"\nTests request context isolation and binding for route handlers by simulating HTTP requests internally. This ensures route functions correctly access request-specific data and that the request context is properly managed and cleaned up after processing.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "@app.route(\"/\")\n    def index():\n        return f\"Hello {flask.request.args['name']}!\"\n\n    @app.route(\"/meh\")\n    def meh():\n        return flask.request.url\n\n    with app.test_request_context(\"/?name=World\"):\n        assert index() == \"Hello World!\"\n    with app.test_request_context(\"/meh\"):\n        assert meh() == \"http://localhost/meh\"\n    assert flask._request_ctx_stack.top is None"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_context_test",
                "second_doc": "\"\"\"\nTests the management of the request context stack to ensure that it is correctly set up and torn down during a simulated request.\n\nThis check ensures that before a request context is pushed, request-specific variables are unavailable, and after pushing, they become accessible as expected. This is important for validating the correctness of request context handling, which underpins how request data is isolated during application and testing.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "assert not flask.request\n    assert not flask.has_request_context()\n    ctx = app.test_request_context()\n    ctx.push()\n    try:\n        assert flask.request\n        assert flask.has_request_context()\n    finally:\n        ctx.pop()"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_manual_context_binding",
                "second_doc": "\"\"\"\nTests that a Flask view function can properly access request context when it is manually managed. This ensures the application behaves as expected when the context is pushed and raises the appropriate error when accessed outside of an active context.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "@app.route(\"/\")\n    def index():\n        return f\"Hello {flask.request.args['name']}!\"\n\n    ctx = app.test_request_context(\"/?name=World\")\n    ctx.push()\n    assert index() == \"Hello World!\"\n    ctx.pop()\n    with pytest.raises(RuntimeError):\n        index()"
            },
            "type": "function"
        },
        {
            "methods": [
                {
                    "docstring": null,
                    "method_name": "test_greenlet_context_copying",
                    "second_doc": "\"\"\"\nTest that request and application contexts can be manually copied and activated in a separate greenlet, ensuring Flask's internal objects (like request, session, and current_app) are properly managed across concurrent execution contexts.\n\nArgs:\n    self: The test case instance.\n\nReturns:\n    None\n\nWhy:\n    Properly managing context copying is crucial for safely handling concurrent operations (such as those with greenlets or coroutines) so that each execution flow retains isolation and correctness of per-request data in Flask applications.\n\"\"\"",
                    "source_code": "greenlets = []\n\n        @app.route(\"/\")\n        def index():\n            flask.session[\"fizz\"] = \"buzz\"\n            reqctx = flask._request_ctx_stack.top.copy()\n\n            def g():\n                assert not flask.request\n                assert not flask.current_app\n                with reqctx:\n                    assert flask.request\n                    assert flask.current_app == app\n                    assert flask.request.path == \"/\"\n                    assert flask.request.args[\"foo\"] == \"bar\"\n                    assert flask.session.get(\"fizz\") == \"buzz\"\n                assert not flask.request\n                return 42\n\n            greenlets.append(greenlet(g))\n            return \"Hello World!\"\n\n        rv = client.get(\"/?foo=bar\")\n        assert rv.data == b\"Hello World!\"\n\n        result = greenlets[0].run()\n        assert result == 42"
                },
                {
                    "docstring": null,
                    "method_name": "test_greenlet_context_copying_api",
                    "second_doc": "\"\"\"\nTests that the current request context, including request, app, session, and query parameters, can be reliably captured and accessed inside a greenlet using Flask's context copying utility. This helps ensure consistent behavior when performing concurrent operations that require access to request-specific data.\n\nArgs:\n    self: The test case instance.\n\nReturns:\n    None\n\"\"\"",
                    "source_code": "greenlets = []\n\n        @app.route(\"/\")\n        def index():\n            flask.session[\"fizz\"] = \"buzz\"\n\n            @flask.copy_current_request_context\n            def g():\n                assert flask.request\n                assert flask.current_app == app\n                assert flask.request.path == \"/\"\n                assert flask.request.args[\"foo\"] == \"bar\"\n                assert flask.session.get(\"fizz\") == \"buzz\"\n                return 42\n\n            greenlets.append(greenlet(g))\n            return \"Hello World!\"\n\n        rv = client.get(\"/?foo=bar\")\n        assert rv.data == b\"Hello World!\"\n\n        result = greenlets[0].run()\n        assert result == 42"
                }
            ],
            "name": "TestGreenletContextCopying",
            "type": "class"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_session_error_pops_context",
                "second_doc": "\"\"\"\nTests that an exception raised during session creation results in proper cleanup of the request and application context, ensuring no residual state is left behind after a failure in the session interface.\n\nArgs:\n    None\n\nReturns:\n    None\n\nWhy:\n    This method verifies that when a session-related error occurs during request processing, the framework properly discards contextual objects. This prevents resource leaks and ensures subsequent requests or tests are not affected by stale or inconsistent state.\n\"\"\"",
                "source_code": "class SessionError(Exception):\n        pass\n\n    class FailingSessionInterface(SessionInterface):\n        def open_session(self, app, request):\n            raise SessionError()\n\n    class CustomFlask(flask.Flask):\n        session_interface = FailingSessionInterface()\n\n    app = CustomFlask(__name__)\n\n    @app.route(\"/\")\n    def index():\n        # shouldn't get here\n        AssertionError()\n\n    response = app.test_client().get(\"/\")\n    assert response.status_code == 500\n    assert not flask.request\n    assert not flask.current_app"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_session_dynamic_cookie_name",
                "second_doc": "\"\"\"\nTests that session data is isolated by dynamically assigning different cookie names based on the request path. This ensures that state management per endpoint can be independently controlled, supporting scenarios where multiple session contexts are desired within the same application.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "class PathAwareSessionInterface(SecureCookieSessionInterface):\n        def get_cookie_name(self, app):\n            if flask.request.url.endswith(\"dynamic_cookie\"):\n                return \"dynamic_cookie_name\"\n            else:\n                return super().get_cookie_name(app)\n\n    class CustomFlask(flask.Flask):\n        session_interface = PathAwareSessionInterface()\n\n    app = CustomFlask(__name__)\n    app.secret_key = \"secret_key\"\n\n    @app.route(\"/set\", methods=[\"POST\"])\n    def set():\n        flask.session[\"value\"] = flask.request.form[\"value\"]\n        return \"value set\"\n\n    @app.route(\"/get\")\n    def get():\n        v = flask.session.get(\"value\", \"None\")\n        return v\n\n    @app.route(\"/set_dynamic_cookie\", methods=[\"POST\"])\n    def set_dynamic_cookie():\n        flask.session[\"value\"] = flask.request.form[\"value\"]\n        return \"value set\"\n\n    @app.route(\"/get_dynamic_cookie\")\n    def get_dynamic_cookie():\n        v = flask.session.get(\"value\", \"None\")\n        return v\n\n    test_client = app.test_client()\n\n    # first set the cookie in both /set urls but each with a different value\n    assert test_client.post(\"/set\", data={\"value\": \"42\"}).data == b\"value set\"\n    assert (\n        test_client.post(\"/set_dynamic_cookie\", data={\"value\": \"616\"}).data\n        == b\"value set\"\n    )\n\n    # now check that the relevant values come back - meaning that different\n    # cookies are being used for the urls that end with \"dynamic cookie\"\n    assert test_client.get(\"/get\").data == b\"42\"\n    assert test_client.get(\"/get_dynamic_cookie\").data == b\"616\""
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_bad_environ_raises_bad_request",
                "second_doc": "\"\"\"\nTests that when a malformed HTTP_HOST header containing non-printable characters is provided, the application responds with a 400 Bad Request status code.\n\nThis ensures the application properly validates incoming request headers to maintain security and protocol conformance.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "app = flask.Flask(__name__)\n\n    from flask.testing import EnvironBuilder\n\n    builder = EnvironBuilder(app)\n    environ = builder.get_environ()\n\n    # use a non-printable character in the Host - this is key to this test\n    environ[\"HTTP_HOST\"] = \"\\x8a\"\n\n    with app.request_context(environ):\n        response = app.full_dispatch_request()\n    assert response.status_code == 400"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_environ_for_valid_idna_completes",
                "second_doc": "\"\"\"\nTests that request environments with IDNA-compatible hostnames are handled correctly by simulating a web request to a Flask application and ensuring a successful response.\n\nArgs:\n    None\n\nReturns:\n    None\n\nWhy:\n    To confirm that the application correctly processes HTTP requests where the host header uses internationalized domain names, ensuring robust handling of diverse client environments.\n\"\"\"",
                "source_code": "app = flask.Flask(__name__)\n\n    @app.route(\"/\")\n    def index():\n        return \"Hello World!\"\n\n    from flask.testing import EnvironBuilder\n\n    builder = EnvironBuilder(app)\n    environ = builder.get_environ()\n\n    # these characters are all IDNA-compatible\n    environ[\"HTTP_HOST\"] = \"\u0105\u015b\u017a\u00e4\u00fc\u0436\u0160\u00df\u044f.com\"\n\n    with app.request_context(environ):\n        response = app.full_dispatch_request()\n\n    assert response.status_code == 200"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_normal_environ_completes",
                "second_doc": "\"\"\"\nTests that a Flask application correctly handles an HTTP GET request using an internationalized domain name (IDN) in the Host header, ensuring proper response behavior in such scenarios.\n\nArgs:\n    None\n\nReturns:\n    None. Asserts that the response status code is 200, indicating the application successfully completes the request.\n\"\"\"",
                "source_code": "app = flask.Flask(__name__)\n\n    @app.route(\"/\")\n    def index():\n        return \"Hello World!\"\n\n    response = app.test_client().get(\"/\", headers={\"host\": \"xn--on-0ia.com\"})\n    assert response.status_code == 200"
            },
            "type": "function"
        }
    ],
    "flask/tests/test_signals.py": [
        {
            "details": {
                "docstring": null,
                "method_name": "test_template_rendered",
                "second_doc": "\"\"\"\nTests that a template is correctly rendered with the expected context data when a specific route is accessed.\n\nArgs:\n    None\n\nReturns:\n    None\n\nWhy: Verifies that the rendering process passes the intended template and data to the template system, ensuring application responses are constructed as expected.\n\"\"\"",
                "source_code": "@app.route(\"/\")\n    def index():\n        return flask.render_template(\"simple_template.html\", whiskey=42)\n\n    recorded = []\n\n    def record(sender, template, context):\n        recorded.append((template, context))\n\n    flask.template_rendered.connect(record, app)\n    try:\n        client.get(\"/\")\n        assert len(recorded) == 1\n        template, context = recorded[0]\n        assert template.name == \"simple_template.html\"\n        assert context[\"whiskey\"] == 42\n    finally:\n        flask.template_rendered.disconnect(record, app)"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_before_render_template",
                "second_doc": "\"\"\"\nTests that modifying the template context via the before_render_template signal successfully updates the rendered output.\n\nArgs:\n    None\n\nReturns:\n    None\n\nWhy:\n    This method ensures that signal handlers can alter the template context data before rendering, which is essential for dynamic content customization during the request lifecycle.\n\"\"\"",
                "source_code": "app = flask.Flask(__name__)\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"simple_template.html\", whiskey=42)\n\n    recorded = []\n\n    def record(sender, template, context):\n        context[\"whiskey\"] = 43\n        recorded.append((template, context))\n\n    flask.before_render_template.connect(record, app)\n    try:\n        rv = app.test_client().get(\"/\")\n        assert len(recorded) == 1\n        template, context = recorded[0]\n        assert template.name == \"simple_template.html\"\n        assert context[\"whiskey\"] == 43\n        assert rv.data == b\"<h1>43</h1>\"\n    finally:\n        flask.before_render_template.disconnect(record, app)"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_request_signals",
                "second_doc": "\"\"\"\nTests that both request signals and request handlers are triggered in the correct order during a typical request lifecycle by recording their invocations and verifying the resulting sequence. This ensures that signal connections and handler hooks function as designed, supporting reliable extension points for request processing.\n\nArgs:\n    None\n\nReturns:\n    None\n\nRaises:\n    AssertionError: If response data does not match expectation or if the call order of request hooks and signals is incorrect.\n\"\"\"",
                "source_code": "app = flask.Flask(__name__)\n    calls = []\n\n    def before_request_signal(sender):\n        calls.append(\"before-signal\")\n\n    def after_request_signal(sender, response):\n        assert response.data == b\"stuff\"\n        calls.append(\"after-signal\")\n\n    @app.before_request\n    def before_request_handler():\n        calls.append(\"before-handler\")\n\n    @app.after_request\n    def after_request_handler(response):\n        calls.append(\"after-handler\")\n        response.data = \"stuff\"\n        return response\n\n    @app.route(\"/\")\n    def index():\n        calls.append(\"handler\")\n        return \"ignored anyway\"\n\n    flask.request_started.connect(before_request_signal, app)\n    flask.request_finished.connect(after_request_signal, app)\n\n    try:\n        rv = app.test_client().get(\"/\")\n        assert rv.data == b\"stuff\"\n\n        assert calls == [\n            \"before-signal\",\n            \"before-handler\",\n            \"handler\",\n            \"after-handler\",\n            \"after-signal\",\n        ]\n    finally:\n        flask.request_started.disconnect(before_request_signal, app)\n        flask.request_finished.disconnect(after_request_signal, app)"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_request_exception_signal",
                "second_doc": "\"\"\"\nTests that an exception raised during a request triggers the request exception signal and properly records the exception.\n\nArgs:\n    None\n\nReturns:\n    None\n\nThis method ensures that exceptions occurring within request handlers are correctly signaled and can be observed or logged by connected handlers.\n\"\"\"",
                "source_code": "app = flask.Flask(__name__)\n    recorded = []\n\n    @app.route(\"/\")\n    def index():\n        1 // 0\n\n    def record(sender, exception):\n        recorded.append(exception)\n\n    flask.got_request_exception.connect(record, app)\n    try:\n        assert app.test_client().get(\"/\").status_code == 500\n        assert len(recorded) == 1\n        assert isinstance(recorded[0], ZeroDivisionError)\n    finally:\n        flask.got_request_exception.disconnect(record, app)"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_appcontext_signals",
                "second_doc": "\"\"\"\nTests that application context push and pop signals are correctly emitted during the handling of a request. This ensures signal handlers can track when the application context lifecycle events occur, which is vital for resource management and cleanup in web applications.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "app = flask.Flask(__name__)\n    recorded = []\n\n    def record_push(sender, **kwargs):\n        recorded.append(\"push\")\n\n    def record_pop(sender, **kwargs):\n        recorded.append(\"pop\")\n\n    @app.route(\"/\")\n    def index():\n        return \"Hello\"\n\n    flask.appcontext_pushed.connect(record_push, app)\n    flask.appcontext_popped.connect(record_pop, app)\n    try:\n        with app.test_client() as c:\n            rv = c.get(\"/\")\n            assert rv.data == b\"Hello\"\n            assert recorded == [\"push\"]\n        assert recorded == [\"push\", \"pop\"]\n    finally:\n        flask.appcontext_pushed.disconnect(record_push, app)\n        flask.appcontext_popped.disconnect(record_pop, app)"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_flash_signal",
                "second_doc": "\"\"\"\nTests that flashing a message on a route successfully triggers the message_flashed signal, ensuring that messages intended for users can be programmatically tracked and handled within the application.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "@app.route(\"/\")\n    def index():\n        flask.flash(\"This is a flash message\", category=\"notice\")\n        return flask.redirect(\"/other\")\n\n    recorded = []\n\n    def record(sender, message, category):\n        recorded.append((message, category))\n\n    flask.message_flashed.connect(record, app)\n    try:\n        client = app.test_client()\n        with client.session_transaction():\n            client.get(\"/\")\n            assert len(recorded) == 1\n            message, category = recorded[0]\n            assert message == \"This is a flash message\"\n            assert category == \"notice\"\n    finally:\n        flask.message_flashed.disconnect(record, app)"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_appcontext_tearing_down_signal",
                "second_doc": "\"\"\"\nTests that the appcontext_tearing_down signal is properly emitted when the application context is torn down, even during an unhandled exception in a request. This ensures teardown handlers are correctly invoked to facilitate resource cleanup after request processing.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "app = flask.Flask(__name__)\n    recorded = []\n\n    def record_teardown(sender, **kwargs):\n        recorded.append((\"tear_down\", kwargs))\n\n    @app.route(\"/\")\n    def index():\n        1 // 0\n\n    flask.appcontext_tearing_down.connect(record_teardown, app)\n    try:\n        with app.test_client() as c:\n            rv = c.get(\"/\")\n            assert rv.status_code == 500\n            assert recorded == []\n        assert recorded == [(\"tear_down\", {\"exc\": None})]\n    finally:\n        flask.appcontext_tearing_down.disconnect(record_teardown, app)"
            },
            "type": "function"
        }
    ],
    "flask/tests/test_subclassing.py": [
        {
            "details": {
                "docstring": null,
                "method_name": "test_suppressed_exception_logging",
                "second_doc": "\"\"\"\nTests that when exception logging is intentionally suppressed in a Flask application, the exception output does not appear in the error stream during handling of server errors. This ensures that applications can avoid logging sensitive or unnecessary information under certain conditions.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "class SuppressedFlask(flask.Flask):\n        def log_exception(self, exc_info):\n            pass\n\n    out = StringIO()\n    app = SuppressedFlask(__name__)\n\n    @app.route(\"/\")\n    def index():\n        raise Exception(\"test\")\n\n    rv = app.test_client().get(\"/\", errors_stream=out)\n    assert rv.status_code == 500\n    assert b\"Internal Server Error\" in rv.data\n    assert not out.getvalue()"
            },
            "type": "function"
        }
    ],
    "flask/tests/test_templating.py": [
        {
            "details": {
                "docstring": null,
                "method_name": "test_context_processing",
                "second_doc": "\"\"\"\nTests whether template context processors correctly inject additional variables into the rendering context for templates, ensuring extended flexibility and customization during template rendering.\n\nArgs:\n    None\n\nReturns:\n    None\n\nWhy:\n    This test verifies that values provided by context processors are properly available within rendered templates, which is essential for supporting dynamic and site-wide context customization in web applications.\n\"\"\"",
                "source_code": "@app.context_processor\n    def context_processor():\n        return {\"injected_value\": 42}\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"context_template.html\", value=23)\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"<p>23|42\""
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_original_win",
                "second_doc": "\"\"\"\nTests whether the server correctly renders a simple template variable via an HTTP GET request.\n\nThis method verifies that the response data matches the expected output when visiting the root route, ensuring accurate template rendering in a request context.\n\nArgs:\n    None\n\nReturns:\n    None\n\nRaises:\n    AssertionError: If the response data does not exactly match the expected rendered value.\n\"\"\"",
                "source_code": "@app.route(\"/\")\n    def index():\n        return flask.render_template_string(\"{{ config }}\", config=42)\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"42\""
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_request_less_rendering",
                "second_doc": "\"\"\"\nTests that the template rendering system correctly combines application configuration values with context variables, ensuring templates can access both types of data for dynamic content generation.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "app.config[\"WORLD_NAME\"] = \"Special World\"\n\n    @app.context_processor\n    def context_processor():\n        return dict(foo=42)\n\n    rv = flask.render_template_string(\"Hello {{ config.WORLD_NAME }} {{ foo }}\")\n    assert rv == \"Hello Special World 42\""
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_standard_context",
                "second_doc": "\"\"\"\nTests that the application context properly handles request arguments, global variables, configuration values, and session data. This ensures that essential Flask context mechanisms work as expected, supporting dynamic content rendering and reliable state management during request handling.\n\nArgs:\n    None\n\nReturns:\n    None. Asserts that the rendered template output contains the expected values from the request arguments, global variables, configuration, and session.\n\"\"\"",
                "source_code": "@app.route(\"/\")\n    def index():\n        flask.g.foo = 23\n        flask.session[\"test\"] = \"aha\"\n        return flask.render_template_string(\n            \"\"\"\n            {{ request.args.foo }}\n            {{ g.foo }}\n            {{ config.DEBUG }}\n            {{ session.test }}\n        \"\"\"\n        )\n\n    rv = client.get(\"/?foo=42\")\n    assert rv.data.split() == [b\"42\", b\"23\", b\"False\", b\"aha\"]"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_escaping",
                "second_doc": "\"\"\"\nTests that text passed to the template is correctly handled as both escaped and unescaped content, verifying the template rendering manages HTML safety as intended.\n\nArgs:\n    None\n\nReturns:\n    None\n\nWhy:\n    This ensures the web application securely handles user-provided and pre-marked HTML content, preventing potential security issues and preserving intended formatting in rendered templates.\n\"\"\"",
                "source_code": "text = \"<p>Hello World!\"\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\n            \"escaping_template.html\", text=text, html=flask.Markup(text)\n        )\n\n    lines = client.get(\"/\").data.splitlines()\n    assert lines == [\n        b\"&lt;p&gt;Hello World!\",\n        b\"<p>Hello World!\",\n        b\"<p>Hello World!\",\n        b\"<p>Hello World!\",\n        b\"&lt;p&gt;Hello World!\",\n        b\"<p>Hello World!\",\n    ]"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_no_escaping",
                "second_doc": "\"\"\"\nTests that template content and variables are rendered without additional escaping where not needed, demonstrating proper handling of literal and marked-up HTML in templates.\n\nArgs:\n    None\n\nReturns:\n    None\n\nWhy:\n    Verifies that the rendering logic preserves the intended format and escapes only when required, ensuring output correctness and preventing unintended transformation of the template data.\n\"\"\"",
                "source_code": "text = \"<p>Hello World!\"\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\n            \"non_escaping_template.txt\", text=text, html=flask.Markup(text)\n        )\n\n    lines = client.get(\"/\").data.splitlines()\n    assert lines == [\n        b\"<p>Hello World!\",\n        b\"<p>Hello World!\",\n        b\"<p>Hello World!\",\n        b\"<p>Hello World!\",\n        b\"&lt;p&gt;Hello World!\",\n        b\"<p>Hello World!\",\n        b\"<p>Hello World!\",\n        b\"<p>Hello World!\",\n    ]"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_escaping_without_template_filename",
                "second_doc": "\"\"\"\nTests how template rendering handles escaping special characters, specifically verifying that rendering directly from a string auto-escapes input, while rendering from a template file does not.\n\nArgs:\n    None\n\nReturns:\n    None\n\nWhy:\n    Ensures the template rendering system applies or skips HTML escaping appropriately based on rendering context, which is crucial for preventing security vulnerabilities like cross-site scripting and for producing correct output for different use cases.\n\"\"\"",
                "source_code": "assert flask.render_template_string(\"{{ foo }}\", foo=\"<test>\") == \"&lt;test&gt;\"\n    assert flask.render_template(\"mail.txt\", foo=\"<test>\") == \"<test> Mail\""
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_macros",
                "second_doc": "\"\"\"\nTests that a Jinja2 macro can be retrieved from a template and produces the expected rendered output.\n\nThis ensures the template rendering engine correctly loads and executes macros, which is essential for generating dynamic web content reliably in applications.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "macro = flask.get_template_attribute(\"_macro.html\", \"hello\")\n    assert macro(\"World\") == \"Hello World!\""
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_template_filter",
                "second_doc": "\"\"\"\nTests the registration and functionality of a custom template filter in the application's Jinja environment. This ensures that user-defined filters are correctly added and callable, helping to verify the template engine's extensibility.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "@app.template_filter()\n    def my_reverse(s):\n        return s[::-1]\n\n    assert \"my_reverse\" in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters[\"my_reverse\"] == my_reverse\n    assert app.jinja_env.filters[\"my_reverse\"](\"abcd\") == \"dcba\""
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_add_template_filter",
                "second_doc": "\"\"\"\nTests that a custom filter function can be successfully registered with the template engine, ensuring it becomes available for use within template rendering. Verifies that the filter is correctly added and behaves as expected when applied.\n\nWhy: This test confirms the mechanism for extending template functionality works as intended, supporting flexible and dynamic template processing.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "def my_reverse(s):\n        return s[::-1]\n\n    app.add_template_filter(my_reverse)\n    assert \"my_reverse\" in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters[\"my_reverse\"] == my_reverse\n    assert app.jinja_env.filters[\"my_reverse\"](\"abcd\") == \"dcba\""
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_template_filter_with_name",
                "second_doc": "\"\"\"\nTests registration and functionality of a custom template filter by confirming it is correctly added to the template environment and transforms input data as expected.\n\nThis method ensures that extensions to the template engine, such as filters, are properly integrated and usable, verifying the framework's ability to support template customization.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "@app.template_filter(\"strrev\")\n    def my_reverse(s):\n        return s[::-1]\n\n    assert \"strrev\" in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters[\"strrev\"] == my_reverse\n    assert app.jinja_env.filters[\"strrev\"](\"abcd\") == \"dcba\""
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_add_template_filter_with_name",
                "second_doc": "\"\"\"\nTests whether a custom template filter function can be registered under a specific name and accessed correctly within the application's template environment.\n\nArgs:\n    None\n\nReturns:\n    None\n\nWhy:\n    Verifying the registration and usage of custom template filters ensures that developers can extend template rendering capabilities, enabling more flexible and maintainable output generation in web applications.\n\"\"\"",
                "source_code": "def my_reverse(s):\n        return s[::-1]\n\n    app.add_template_filter(my_reverse, \"strrev\")\n    assert \"strrev\" in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters[\"strrev\"] == my_reverse\n    assert app.jinja_env.filters[\"strrev\"](\"abcd\") == \"dcba\""
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_template_filter_with_template",
                "second_doc": "\"\"\"\nTests the functionality of a custom template filter that reverses strings by rendering a template and verifying its output. This ensures that user-defined template filters are correctly registered and applied within the template rendering process.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "@app.template_filter()\n    def super_reverse(s):\n        return s[::-1]\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_filter.html\", value=\"abcd\")\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"dcba\""
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_add_template_filter_with_template",
                "second_doc": "\"\"\"\nTests that a custom template filter can be added to the application's filter registry and that it is correctly applied during template rendering.\n\nArgs:\n    None\n\nReturns:\n    None\n\nWhy:\n    Ensures that user-defined template filters alter data as intended when rendering templates, which is crucial for allowing dynamic content manipulation and extensibility in rendered views.\n\"\"\"",
                "source_code": "def super_reverse(s):\n        return s[::-1]\n\n    app.add_template_filter(super_reverse)\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_filter.html\", value=\"abcd\")\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"dcba\""
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_template_filter_with_name_and_template",
                "second_doc": "\"\"\"\nTests that a custom template filter correctly processes input values when rendering a template.\n\nArgs:\n    None\n\nReturns:\n    None\n\nThis method verifies that a user-defined filter for reversing strings is properly registered in the template engine and works as expected during template rendering, ensuring template customization features behave correctly.\n\"\"\"",
                "source_code": "@app.template_filter(\"super_reverse\")\n    def my_reverse(s):\n        return s[::-1]\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_filter.html\", value=\"abcd\")\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"dcba\""
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_add_template_filter_with_name_and_template",
                "second_doc": "\"\"\"\nTests whether a custom template filter can be added to the application with a specific name, and verifies that it correctly processes template data during rendering.\n\nArgs:\n    None\n\nReturns:\n    None\n\nThis method ensures that dynamic data transformation can be seamlessly integrated into template rendering through named filters, enabling greater flexibility and customization in output formatting.\n\"\"\"",
                "source_code": "def my_reverse(s):\n        return s[::-1]\n\n    app.add_template_filter(my_reverse, \"super_reverse\")\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_filter.html\", value=\"abcd\")\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"dcba\""
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_template_test",
                "second_doc": "\"\"\"\nTest registration and functionality of a custom Jinja template test for boolean detection.\n\nThis method verifies that a custom test for identifying boolean values can be correctly registered and used in the template environment. Ensuring template tests behave as expected is important for dynamic content rendering and application logic within templates.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "@app.template_test()\n    def boolean(value):\n        return isinstance(value, bool)\n\n    assert \"boolean\" in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests[\"boolean\"] == boolean\n    assert app.jinja_env.tests[\"boolean\"](False)"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_add_template_test",
                "second_doc": "\"\"\"\nTests the registration of a custom template test function within the application's Jinja environment to ensure custom logic can be integrated into template rendering.\n\nArgs:\n    None\n\nReturns:\n    None\n\nRaises:\n    AssertionError: If the template test is not added correctly or does not function as intended.\n\"\"\"",
                "source_code": "def boolean(value):\n        return isinstance(value, bool)\n\n    app.add_template_test(boolean)\n    assert \"boolean\" in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests[\"boolean\"] == boolean\n    assert app.jinja_env.tests[\"boolean\"](False)"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_template_test_with_name",
                "second_doc": "\"\"\"\nTests the registration and functionality of a custom Jinja template test by adding a 'boolean' test to the application's template environment and verifying its behavior.\n\nArgs:\n    None\n\nReturns:\n    None\n\nWhy:\n    This verifies that custom tests can be correctly registered and are functional within the template engine, ensuring that templates can support extended logic defined by the developer.\n\"\"\"",
                "source_code": "@app.template_test(\"boolean\")\n    def is_boolean(value):\n        return isinstance(value, bool)\n\n    assert \"boolean\" in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests[\"boolean\"] == is_boolean\n    assert app.jinja_env.tests[\"boolean\"](False)"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_add_template_test_with_name",
                "second_doc": "\"\"\"\nTests whether a custom test function can be added to the template environment and is accessible by name.\n\nArgs:\n    None\n\nReturns:\n    None\n\nWhy:\n    Ensuring the ability to register and use custom tests in the template environment helps extend the expressiveness and reusability of templates when performing type checks or other validations during template rendering.\n\"\"\"",
                "source_code": "def is_boolean(value):\n        return isinstance(value, bool)\n\n    app.add_template_test(is_boolean, \"boolean\")\n    assert \"boolean\" in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests[\"boolean\"] == is_boolean\n    assert app.jinja_env.tests[\"boolean\"](False)"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_template_test_with_template",
                "second_doc": "\"\"\"\nTests the integration of a custom template test within the application's template rendering system to ensure proper registration and execution.\n\nArgs:\n    None\n\nReturns:\n    None\n\nThis method verifies that a user-defined test for template expressions operates as intended, helping confirm that dynamic content and custom logic are processed correctly during template rendering.\n\"\"\"",
                "source_code": "@app.template_test()\n    def boolean(value):\n        return isinstance(value, bool)\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_test.html\", value=False)\n\n    rv = client.get(\"/\")\n    assert b\"Success!\" in rv.data"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_add_template_test_with_template",
                "second_doc": "\"\"\"\nRegisters a custom template test to check for boolean values, integrates it with the app, and verifies that templates can use this test to conditionally render content. This ensures that custom logic for template processing is functioning correctly.\n\nArgs:\n    None\n\nReturns:\n    None\n\nWhy:\n    To confirm that the application correctly supports user-defined template tests, enabling more powerful and customized template rendering logic.\n\"\"\"",
                "source_code": "def boolean(value):\n        return isinstance(value, bool)\n\n    app.add_template_test(boolean)\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_test.html\", value=False)\n\n    rv = client.get(\"/\")\n    assert b\"Success!\" in rv.data"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_template_test_with_name_and_template",
                "second_doc": "\"\"\"\nTests whether a custom template test filter with a specific name and function operates as expected within a rendered template context.\n\nArgs:\n    None\n\nReturns:\n    None\n\nThis test ensures that custom logic for evaluating template variables can be registered and invoked during template rendering, verifying the integration of user-defined template filters with the application's rendering system.\n\"\"\"",
                "source_code": "@app.template_test(\"boolean\")\n    def is_boolean(value):\n        return isinstance(value, bool)\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_test.html\", value=False)\n\n    rv = client.get(\"/\")\n    assert b\"Success!\" in rv.data"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_add_template_test_with_name_and_template",
                "second_doc": "\"\"\"\nTests the integration of a custom template test within the application's rendering system using a specific name.\n\nArgs:\n    None\n\nReturns:\n    None\n\nWhy:\n    This method ensures that custom logic registered as a template test (e.g., checking if a value is a boolean) can be correctly recognized and utilized during template rendering, thereby verifying the framework's extensibility and correctness in template customization.\n\"\"\"",
                "source_code": "def is_boolean(value):\n        return isinstance(value, bool)\n\n    app.add_template_test(is_boolean, \"boolean\")\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_test.html\", value=False)\n\n    rv = client.get(\"/\")\n    assert b\"Success!\" in rv.data"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_add_template_global",
                "second_doc": "\"\"\"\nTests whether a function can be registered as a global template helper, ensuring it is properly exposed to the template environment and can be invoked from within templates.\n\nThis validation is important to guarantee that custom helper functions are accessible for use during template rendering, supporting dynamic content generation in application views.\n\nReturns:\n    None\n\"\"\"",
                "source_code": "@app.template_global()\n    def get_stuff():\n        return 42\n\n    assert \"get_stuff\" in app.jinja_env.globals.keys()\n    assert app.jinja_env.globals[\"get_stuff\"] == get_stuff\n    assert app.jinja_env.globals[\"get_stuff\"](), 42\n\n    rv = flask.render_template_string(\"{{ get_stuff() }}\")\n    assert rv == \"42\""
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_custom_template_loader",
                "second_doc": "\"\"\"\nTests that a Flask application can use a custom Jinja template loader to render content based on predefined template sources.\n\nArgs:\n    None\n\nReturns:\n    None\n\nWhy:\nThis method verifies that replacing the default template loading mechanism works correctly, ensuring developers can inject or override templates as needed for greater control and customization of rendered output.\n\"\"\"",
                "source_code": "class MyFlask(flask.Flask):\n        def create_global_jinja_loader(self):\n            from jinja2 import DictLoader\n\n            return DictLoader({\"index.html\": \"Hello Custom World!\"})\n\n    app = MyFlask(__name__)\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"index.html\")\n\n    c = app.test_client()\n    rv = c.get(\"/\")\n    assert rv.data == b\"Hello Custom World!\""
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_iterable_loader",
                "second_doc": "\"\"\"\nTests the template rendering behavior when given an iterable of template names, ensuring that Flask selects the first available template and applies the appropriate context for rendering.\n\nArgs:\n    None\n\nReturns:\n    None\n\nWhy:\n    This method verifies Flask's ability to search through a list of template names, skip unavailable templates, render the first existing one, and pass context variables (including those from context processors) to the template rendering process. This behavior is important for supporting flexible and robust template selection and context management in web applications.\n\"\"\"",
                "source_code": "@app.context_processor\n    def context_processor():\n        return {\"whiskey\": \"Jameson\"}\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\n            [\n                \"no_template.xml\",  # should skip this one\n                \"simple_template.html\",  # should render this\n                \"context_template.html\",\n            ],\n            value=23,\n        )\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"<h1>Jameson</h1>\""
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_templates_auto_reload",
                "second_doc": "\"\"\"\nTests the relationship between the Flask application's debug mode, the TEMPLATES_AUTO_RELOAD configuration, and the resulting auto_reload behavior in the Jinja template environment.\n\nThis method verifies that template auto-reloading behaves as expected with different combinations of debug mode and the TEMPLATES_AUTO_RELOAD configuration. Ensuring this behavior is correct is important for accurately reflecting code and template changes during development while maintaining efficiency in production.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "assert app.debug is False\n    assert app.config[\"TEMPLATES_AUTO_RELOAD\"] is None\n    assert app.jinja_env.auto_reload is False\n    # debug is False, config option is False\n    app = flask.Flask(__name__)\n    app.config[\"TEMPLATES_AUTO_RELOAD\"] = False\n    assert app.debug is False\n    assert app.jinja_env.auto_reload is False\n    # debug is False, config option is True\n    app = flask.Flask(__name__)\n    app.config[\"TEMPLATES_AUTO_RELOAD\"] = True\n    assert app.debug is False\n    assert app.jinja_env.auto_reload is True\n    # debug is True, config option is None\n    app = flask.Flask(__name__)\n    app.config[\"DEBUG\"] = True\n    assert app.config[\"TEMPLATES_AUTO_RELOAD\"] is None\n    assert app.jinja_env.auto_reload is True\n    # debug is True, config option is False\n    app = flask.Flask(__name__)\n    app.config[\"DEBUG\"] = True\n    app.config[\"TEMPLATES_AUTO_RELOAD\"] = False\n    assert app.jinja_env.auto_reload is False\n    # debug is True, config option is True\n    app = flask.Flask(__name__)\n    app.config[\"DEBUG\"] = True\n    app.config[\"TEMPLATES_AUTO_RELOAD\"] = True\n    assert app.jinja_env.auto_reload is True"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_templates_auto_reload_debug_run",
                "second_doc": "\"\"\"\nTests that the application's template auto-reloading behavior and the Jinja environment's auto-reload setting correctly respond to the debug mode configuration when running the server.\n\nArgs:\n    *args: Positional arguments used to mock the server run method.\n    **kwargs: Keyword arguments used to mock the server run method.\n\nReturns:\n    None\n\nWhy:\n    Ensuring that template reloading is dynamically enabled or disabled based on the application's debug status helps streamline the development experience by allowing live template updates during development and optimizing performance in production.\n\"\"\"",
                "source_code": "def run_simple_mock(*args, **kwargs):\n        pass\n\n    monkeypatch.setattr(werkzeug.serving, \"run_simple\", run_simple_mock)\n\n    app.run()\n    assert not app.templates_auto_reload\n    assert not app.jinja_env.auto_reload\n\n    app.run(debug=True)\n    assert app.templates_auto_reload\n    assert app.jinja_env.auto_reload"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_template_loader_debugging",
                "second_doc": "\"\"\"\nTests that template loading debugging information is correctly logged and handled when a template is missing, ensuring the system traces the order of template loaders and reports informative errors for developers. This is crucial for diagnosing template resolution issues in complex or modular applications.\n\nArgs:\n    monkeypatch (pytest.MonkeyPatch): Used to temporarily modify Flask app configuration and logging handlers during the test.\n\nReturns:\n    None. Asserts correct log messages and exception handling during template loading, raising AssertionError if expected conditions are not met.\n\"\"\"",
                "source_code": "from blueprintapp import app\n\n    called = []\n\n    class _TestHandler(logging.Handler):\n        def handle(self, record):\n            called.append(True)\n            text = str(record.msg)\n            assert \"1: trying loader of application 'blueprintapp'\" in text\n            assert (\n                \"2: trying loader of blueprint 'admin' (blueprintapp.apps.admin)\"\n            ) in text\n            assert (\n                \"trying loader of blueprint 'frontend' (blueprintapp.apps.frontend)\"\n            ) in text\n            assert \"Error: the template could not be found\" in text\n            assert (\n                \"looked up from an endpoint that belongs to the blueprint 'frontend'\"\n            ) in text\n            assert \"See https://flask.palletsprojects.com/blueprints/#templates\" in text\n\n    with app.test_client() as c:\n        monkeypatch.setitem(app.config, \"EXPLAIN_TEMPLATE_LOADING\", True)\n        monkeypatch.setattr(\n            logging.getLogger(\"blueprintapp\"), \"handlers\", [_TestHandler()]\n        )\n\n        with pytest.raises(TemplateNotFound) as excinfo:\n            c.get(\"/missing\")\n\n        assert \"missing_template.html\" in str(excinfo.value)\n\n    assert len(called) == 1"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_custom_jinja_env",
                "second_doc": "\"\"\"\nTest that a Flask application can use a custom Jinja template environment class.\n\nThis ensures that template rendering behavior can be customized by assigning a different Jinja environment class to the Flask app, which is important for developers needing advanced template handling.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "class CustomEnvironment(flask.templating.Environment):\n        pass\n\n    class CustomFlask(flask.Flask):\n        jinja_environment = CustomEnvironment\n\n    app = CustomFlask(__name__)\n    assert isinstance(app.jinja_env, CustomEnvironment)"
            },
            "type": "function"
        }
    ],
    "flask/tests/test_testing.py": [
        {
            "details": {
                "docstring": null,
                "method_name": "test_environ_defaults_from_config",
                "second_doc": "\"\"\"\nTests that request URLs are correctly constructed using environment defaults supplied via application configuration. This ensures the app generates accurate external URLs when settings such as SERVER_NAME and APPLICATION_ROOT are specified, which is vital for consistent URL generation and routing in different deployment scenarios.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "app.config[\"SERVER_NAME\"] = \"example.com:1234\"\n    app.config[\"APPLICATION_ROOT\"] = \"/foo\"\n\n    @app.route(\"/\")\n    def index():\n        return flask.request.url\n\n    ctx = app.test_request_context()\n    assert ctx.request.url == \"http://example.com:1234/foo/\"\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"http://example.com:1234/foo/\""
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_environ_defaults",
                "second_doc": "\"\"\"\nTests that the application's request environment provides the correct default URL, both within a manual request context and through the test client.\n\nArgs:\n    None\n\nReturns:\n    None\n\nRaises:\n    AssertionError: If the default request URL does not match the expected value in the provided contexts.\n    \nWhy:\n    Verifies consistency and correctness of the request environment setup, ensuring predictable behavior when handling HTTP requests in different application contexts.\n\"\"\"",
                "source_code": "@app.route(\"/\")\n    def index():\n        return flask.request.url\n\n    ctx = app.test_request_context()\n    assert ctx.request.url == \"http://localhost/\"\n    with client:\n        rv = client.get(\"/\")\n        assert rv.data == b\"http://localhost/\""
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_environ_base_default",
                "second_doc": "\"\"\"\nTests that the application correctly sets the 'User-Agent' and 'remote_addr' information for an incoming request, ensuring the WSGI environment defaults are properly initialized during a typical route dispatch.\n\nArgs:\n    None\n\nReturns:\n    None\n\nWhy:\n    This is performed to verify that the application correctly extracts and exposes key request context data, which is fundamental for handling client-related logic and maintaining proper environment consistency during web request processing.\n\"\"\"",
                "source_code": "@app.route(\"/\")\n    def index():\n        flask.g.user_agent = flask.request.headers[\"User-Agent\"]\n        return flask.request.remote_addr\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"127.0.0.1\"\n    assert flask.g.user_agent == f\"werkzeug/{werkzeug.__version__}\""
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_environ_base_modified",
                "second_doc": "\"\"\"\nTests that modifying the WSGI environment base of the test client correctly simulates different client request properties, ensuring that values like remote address and user agent are updated and accessible within the application context.\n\nArgs:\n    None\n\nReturns:\n    None\n\nWhy:\n    This method verifies that altering the base environment variables for test requests accurately mimics varied client scenarios during testing, thus ensuring the application's ability to read and respond to different request headers and metadata as expected.\n\"\"\"",
                "source_code": "@app.route(\"/\")\n    def index():\n        flask.g.user_agent = flask.request.headers[\"User-Agent\"]\n        return flask.request.remote_addr\n\n    client.environ_base[\"REMOTE_ADDR\"] = \"0.0.0.0\"\n    client.environ_base[\"HTTP_USER_AGENT\"] = \"Foo\"\n    rv = client.get(\"/\")\n    assert rv.data == b\"0.0.0.0\"\n    assert flask.g.user_agent == \"Foo\"\n\n    client.environ_base[\"REMOTE_ADDR\"] = \"0.0.0.1\"\n    client.environ_base[\"HTTP_USER_AGENT\"] = \"Bar\"\n    rv = client.get(\"/\")\n    assert rv.data == b\"0.0.0.1\"\n    assert flask.g.user_agent == \"Bar\""
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_client_open_environ",
                "second_doc": "\"\"\"\nSimulates HTTP requests to verify that different approaches to setting the remote client address in the request environment are handled correctly.\n\nArgs:\n    client: The Flask test client instance used for sending requests.\n    request: The pytest request context used for resource finalization.\n    app: The Flask application instance under test.\n\nReturns:\n    None\n\nThis method ensures the application returns the appropriate remote address when accessed through both an EnvironBuilder and a manually constructed WSGI environ. This verifies that the application's request handling correctly interprets environment overrides, supporting accurate test simulations for request context and address.\n\"\"\"",
                "source_code": "@app.route(\"/index\")\n    def index():\n        return flask.request.remote_addr\n\n    builder = EnvironBuilder(app, path=\"/index\", method=\"GET\")\n    request.addfinalizer(builder.close)\n\n    rv = client.open(builder)\n    assert rv.data == b\"127.0.0.1\"\n\n    environ = builder.get_environ()\n    client.environ_base[\"REMOTE_ADDR\"] = \"127.0.0.2\"\n    rv = client.open(environ)\n    assert rv.data == b\"127.0.0.2\""
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_specify_url_scheme",
                "second_doc": "\"\"\"\nTests that specifying a custom URL scheme when handling requests ensures the generated request URLs reflect the correct protocol. This helps verify that the application can accurately construct URLs based on the incoming request scheme, which is essential for supporting secure or non-standard protocols.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "@app.route(\"/\")\n    def index():\n        return flask.request.url\n\n    ctx = app.test_request_context(url_scheme=\"https\")\n    assert ctx.request.url == \"https://localhost/\"\n\n    rv = client.get(\"/\", url_scheme=\"https\")\n    assert rv.data == b\"https://localhost/\""
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_path_is_url",
                "second_doc": "\"\"\"\nVerify that EnvironBuilder correctly parses and assigns URL components when provided with a full URL, ensuring it properly interprets scheme, host, script root, and path values.\n\nArgs:\n    None\n\nReturns:\n    None\n\nThis method helps ensure accurate handling of request environments constructed from URLs, which is fundamental for testing and development workflows that rely on precise request simulation.\n\"\"\"",
                "source_code": "eb = EnvironBuilder(app, \"https://example.com/\")\n    assert eb.url_scheme == \"https\"\n    assert eb.host == \"example.com\"\n    assert eb.script_root == \"\"\n    assert eb.path == \"/\""
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": "\"\"\"EnvironBuilder.json_dumps() takes settings from the app.\"\"\"",
                "first_doc": "\"\"\"\nValidates that EnvironBuilder correctly serializes Unicode JSON input.\n\nArgs:\n    app: The Flask application instance whose configuration will be updated for the test.\n\nReturns:\n    None. This method performs assertions to verify correct behavior.\n\"\"\"",
                "method_name": "test_environbuilder_json_dumps",
                "second_doc": "\"\"\"\nEnsures that the JSON input containing non-ASCII Unicode characters is correctly serialized by EnvironBuilder, verifying that proper encoding and configuration options are respected during request construction.\n\nArgs:\n    app: Flask application instance whose JSON serialization settings will be modified for this test.\n\nReturns:\n    None. Performs assertions to confirm that Unicode characters are encoded as expected in the resulting request body.\n\"\"\"",
                "source_code": "app.config[\"JSON_AS_ASCII\"] = False\n    eb = EnvironBuilder(app, json=\"\\u20ac\")\n    assert eb.input_stream.read().decode(\"utf8\") == '\"\\u20ac\"'"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_blueprint_with_subdomain",
                "second_doc": "\"\"\"\nTests the integration of blueprints with subdomains to ensure correct routing, request context handling, and URL generation when subdomain support is enabled in the application.\n\nArgs:\n    None\n\nReturns:\n    None\n\nWhy:\n    This method verifies that blueprints configured with a subdomain work as expected, helping maintain modular application structure and accurate routing in more complex deployment scenarios where subdomains are used for separation or organization of routes.\n\"\"\"",
                "source_code": "app = flask.Flask(__name__, subdomain_matching=True)\n    app.config[\"SERVER_NAME\"] = \"example.com:1234\"\n    app.config[\"APPLICATION_ROOT\"] = \"/foo\"\n    client = app.test_client()\n\n    bp = flask.Blueprint(\"company\", __name__, subdomain=\"xxx\")\n\n    @bp.route(\"/\")\n    def index():\n        return flask.request.url\n\n    app.register_blueprint(bp)\n\n    ctx = app.test_request_context(\"/\", subdomain=\"xxx\")\n    assert ctx.request.url == \"http://xxx.example.com:1234/foo/\"\n\n    with ctx:\n        assert ctx.request.blueprint == bp.name\n\n    rv = client.get(\"/\", subdomain=\"xxx\")\n    assert rv.data == b\"http://xxx.example.com:1234/foo/\""
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_redirect_keep_session",
                "second_doc": "\"\"\"\nTests that the session data persists correctly across redirects and different request methods, ensuring that session management operates as intended within the application.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "@app.route(\"/\", methods=[\"GET\", \"POST\"])\n    def index():\n        if flask.request.method == \"POST\":\n            return flask.redirect(\"/getsession\")\n        flask.session[\"data\"] = \"foo\"\n        return \"index\"\n\n    @app.route(\"/getsession\")\n    def get_session():\n        return flask.session.get(\"data\", \"<missing>\")\n\n    with client:\n        rv = client.get(\"/getsession\")\n        assert rv.data == b\"<missing>\"\n\n        rv = client.get(\"/\")\n        assert rv.data == b\"index\"\n        assert flask.session.get(\"data\") == \"foo\"\n\n        rv = client.post(\"/\", data={}, follow_redirects=True)\n        assert rv.data == b\"foo\"\n        assert flask.session.get(\"data\") == \"foo\"\n\n        rv = client.get(\"/getsession\")\n        assert rv.data == b\"foo\""
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_session_transactions",
                "second_doc": "\"\"\"\nTests the mechanism that allows manipulation and inspection of session data within a controlled test context.\n\nThis method ensures that session information persists correctly between simulated requests and can be modified as expected during application testing. It validates the behavior of session storage and retrieval in a way that mirrors real user interactions.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "@app.route(\"/\")\n    def index():\n        return str(flask.session[\"foo\"])\n\n    with client:\n        with client.session_transaction() as sess:\n            assert len(sess) == 0\n            sess[\"foo\"] = [42]\n            assert len(sess) == 1\n        rv = client.get(\"/\")\n        assert rv.data == b\"[42]\"\n        with client.session_transaction() as sess:\n            assert len(sess) == 1\n            assert sess[\"foo\"] == [42]"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_session_transactions_no_null_sessions",
                "second_doc": "\"\"\"\nTests that attempting to use a session transaction when no session backend is available raises the appropriate RuntimeError. This ensures proper error handling for session management in client applications.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "app = flask.Flask(__name__)\n    app.testing = True\n\n    with app.test_client() as c:\n        with pytest.raises(RuntimeError) as e:\n            with c.session_transaction():\n                pass\n        assert \"Session backend did not open a session\" in str(e.value)"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_session_transactions_keep_context",
                "second_doc": "\"\"\"\nTests that the request context remains unchanged when using a session transaction within a client request cycle.\n\nThis ensures consistency in the request context, which is vital for reliable access to request-specific data during testing.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "client.get(\"/\")\n    req = flask.request._get_current_object()\n    assert req is not None\n    with client.session_transaction():\n        assert req is flask.request._get_current_object()"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_session_transaction_needs_cookies",
                "second_doc": "\"\"\"\nTests that attempting to use session transactions without enabling cookies raises a RuntimeError.\n\nArgs:\n    None\n\nReturns:\n    None\n\nThis method verifies that session functionality enforces cookie usage to maintain consistent session state and security during testing.\n\"\"\"",
                "source_code": "c = app.test_client(use_cookies=False)\n    with pytest.raises(RuntimeError) as e:\n        with c.session_transaction():\n            pass\n    assert \"cookies\" in str(e.value)"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_test_client_context_binding",
                "second_doc": "\"\"\"\nTests that the request and application context are properly managed and bound during and after client requests. Verifies that context locals are accessible within a test client context and correctly cleaned up on error or after the context ends.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "app.testing = False\n\n    @app.route(\"/\")\n    def index():\n        flask.g.value = 42\n        return \"Hello World!\"\n\n    @app.route(\"/other\")\n    def other():\n        1 // 0\n\n    with client:\n        resp = client.get(\"/\")\n        assert flask.g.value == 42\n        assert resp.data == b\"Hello World!\"\n        assert resp.status_code == 200\n\n        resp = client.get(\"/other\")\n        assert not hasattr(flask.g, \"value\")\n        assert b\"Internal Server Error\" in resp.data\n        assert resp.status_code == 500\n        flask.g.value = 23\n\n    try:\n        flask.g.value\n    except (AttributeError, RuntimeError):\n        pass\n    else:\n        raise AssertionError(\"some kind of exception expected\")"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_reuse_client",
                "second_doc": "\"\"\"\nVerify that the same client instance can be reused across multiple context managers without loss of functionality or state.\n\nThis test ensures consistent handling of application and request contexts for isolated client sessions, validating that the test client can be repeatedly entered and exited as part of application testing processes.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "c = client\n\n    with c:\n        assert client.get(\"/\").status_code == 404\n\n    with c:\n        assert client.get(\"/\").status_code == 404"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_test_client_calls_teardown_handlers",
                "second_doc": "\"\"\"\nTests that teardown handlers registered with the application are properly invoked after each request during the use of the test client, ensuring cleanup code is executed as expected when a request context ends.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "called = []\n\n    @app.teardown_request\n    def remember(error):\n        called.append(error)\n\n    with client:\n        assert called == []\n        client.get(\"/\")\n        assert called == []\n    assert called == [None]\n\n    del called[:]\n    with client:\n        assert called == []\n        client.get(\"/\")\n        assert called == []\n        client.get(\"/\")\n        assert called == [None]\n    assert called == [None, None]"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_full_url_request",
                "second_doc": "\"\"\"\nTests the application's ability to correctly process both query parameters and form data in a POST request targeting a full URL path. This ensures the application's request handling separates and makes accessible parameters from the query string and from the posted form body.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "@app.route(\"/action\", methods=[\"POST\"])\n    def action():\n        return \"x\"\n\n    with client:\n        rv = client.post(\"http://domain.com/action?vodka=42\", data={\"gin\": 43})\n        assert rv.status_code == 200\n        assert \"gin\" in flask.request.form\n        assert \"vodka\" in flask.request.args"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_json_request_and_response",
                "second_doc": "\"\"\"\nTests that a server endpoint correctly receives JSON data in a POST request and responds with the same JSON content, ensuring proper serialization and deserialization of JSON payloads in both the request and response cycle.\n\nArgs:\n    None\n\nReturns:\n    None\n\nThis ensures that JSON handling between the client and server works as expected, verifying accurate parsing and echoing of structured data.\n\"\"\"",
                "source_code": "@app.route(\"/echo\", methods=[\"POST\"])\n    def echo():\n        return jsonify(flask.request.get_json())\n\n    with client:\n        json_data = {\"drink\": {\"gin\": 1, \"tonic\": True}, \"price\": 10}\n        rv = client.post(\"/echo\", json=json_data)\n\n        # Request should be in JSON\n        assert flask.request.is_json\n        assert flask.request.get_json() == json_data\n\n        # Response should be in JSON\n        assert rv.status_code == 200\n        assert rv.is_json\n        assert rv.get_json() == json_data"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_client_json_no_app_context",
                "second_doc": "\"\"\"\nTests that sending a JSON request to a route using the Flask test client correctly processes the payload and triggers the application context teardown signal when an application context is not explicitly present. This verifies the interaction between request handling, JSON parsing, and context management signals.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "@app.route(\"/hello\", methods=[\"POST\"])\n    def hello():\n        return f\"Hello, {flask.request.json['name']}!\"\n\n    class Namespace:\n        count = 0\n\n        def add(self, app):\n            self.count += 1\n\n    ns = Namespace()\n\n    with appcontext_popped.connected_to(ns.add, app):\n        rv = client.post(\"/hello\", json={\"name\": \"Flask\"})\n\n    assert rv.get_data(as_text=True) == \"Hello, Flask!\"\n    assert ns.count == 1"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_subdomain",
                "second_doc": "\"\"\"\nTests that the application correctly handles subdomain routing by verifying route resolution and response content for a specific subdomain value.\n\nThis method constructs a minimal web server with subdomain matching enabled, defines a route that captures the subdomain as a variable, and simulates a client request to validate that the correct value is returned. It is designed to ensure routing logic can differentiate and process subdomain patterns as expected, which is important for building features like multi-tenant sites or company-specific views.\n\nArgs:\n    None\n\nReturns:\n    None; asserts are used to validate correct response status and content.\n\"\"\"",
                "source_code": "app = flask.Flask(__name__, subdomain_matching=True)\n    app.config[\"SERVER_NAME\"] = \"example.com\"\n    client = app.test_client()\n\n    @app.route(\"/\", subdomain=\"<company_id>\")\n    def view(company_id):\n        return company_id\n\n    with app.test_request_context():\n        url = flask.url_for(\"view\", company_id=\"xxx\")\n\n    with client:\n        response = client.get(url)\n\n    assert 200 == response.status_code\n    assert b\"xxx\" == response.data"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_nosubdomain",
                "second_doc": "\"\"\"\nTests that a route without using a subdomain correctly responds and returns the requested company_id, validating that URL building and routing behave as expected in a basic server configuration.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "app.config[\"SERVER_NAME\"] = \"example.com\"\n\n    @app.route(\"/<company_id>\")\n    def view(company_id):\n        return company_id\n\n    with app.test_request_context():\n        url = flask.url_for(\"view\", company_id=\"xxx\")\n\n    with client:\n        response = client.get(url)\n\n    assert 200 == response.status_code\n    assert b\"xxx\" == response.data"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_cli_runner_class",
                "second_doc": "\"\"\"\nTests whether the application's CLI runner uses the correct class before and after overriding the default runner class.\n\nThis method ensures that the application creates instances of the default CLI runner class and supports customization by allowing the runner class to be replaced with a subclass. This helps verify the correct extensibility and adaptation of the application's command-line interface for various development and testing needs.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "runner = app.test_cli_runner()\n    assert isinstance(runner, FlaskCliRunner)\n\n    class SubRunner(FlaskCliRunner):\n        pass\n\n    app.test_cli_runner_class = SubRunner\n    runner = app.test_cli_runner()\n    assert isinstance(runner, SubRunner)"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_cli_invoke",
                "second_doc": "\"\"\"\nTests invoking a custom CLI command for the application using the testing utility to ensure command-line commands can be registered and executed as expected.\n\nArgs:\n    None\n\nReturns:\n    None\n\nWhy:\n    This test verifies that the application's CLI integration works properly, allowing developers to automate tasks and extend application functionality beyond handling HTTP requests.\n\"\"\"",
                "source_code": "@app.cli.command(\"hello\")\n    def hello_command():\n        click.echo(\"Hello, World!\")\n\n    runner = app.test_cli_runner()\n    # invoke with command name\n    result = runner.invoke(args=[\"hello\"])\n    assert \"Hello\" in result.output\n    # invoke with command object\n    result = runner.invoke(hello_command)\n    assert \"Hello\" in result.output"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_cli_custom_obj",
                "second_doc": "\"\"\"\nTest that a custom object can be passed to a Flask CLI command, ensuring that the application factory is invoked as expected.\n\nArgs:\n    None\n\nReturns:\n    None\n\nWhy:\n    This verifies that providing a custom object to the CLI context triggers application creation logic, ensuring correct initialization and extensibility of CLI commands.\n\"\"\"",
                "source_code": "class NS:\n        called = False\n\n    def create_app():\n        NS.called = True\n        return app\n\n    @app.cli.command(\"hello\")\n    def hello_command():\n        click.echo(\"Hello, World!\")\n\n    script_info = ScriptInfo(create_app=create_app)\n    runner = app.test_cli_runner()\n    runner.invoke(hello_command, obj=script_info)\n    assert NS.called"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_client_pop_all_preserved",
                "second_doc": "\"\"\"\nTests that only the initial request context remains after the client processes a streamed response, ensuring proper management of context stacks during request handling.\n\nArgs:\n    None\n\nReturns:\n    None\n\nWhy:\n    This method verifies that context preservation mechanics work as intended, so resource cleanup and context separation are reliably maintained throughout request lifecycles.\n\"\"\"",
                "source_code": "@app.route(\"/\")\n    def index():\n        # stream_with_context pushes a third context, preserved by client\n        return flask.Response(flask.stream_with_context(\"hello\"))\n\n    # req_ctx fixture pushed an initial context, not marked preserved\n    with client:\n        # request pushes a second request context, preserved by client\n        client.get(\"/\")\n\n    # only req_ctx fixture should still be pushed\n    assert flask._request_ctx_stack.top is req_ctx"
            },
            "type": "function"
        }
    ],
    "flask/tests/test_user_error_handler.py": [
        {
            "details": {
                "docstring": null,
                "method_name": "test_error_handler_no_match",
                "second_doc": "\"\"\"\nTests the application's error handling mechanism to ensure that error handlers are correctly registered and invoked. Verifies that only valid exception types can be used with error handlers, and checks the application's response to raised exceptions through various routes.\n\nArgs:\n    None\n\nReturns:\n    None\n\nWhy:\n    To validate that the application's error handling setup enforces correct association of exceptions with handlers and provides predictable responses to different error scenarios. This helps ensure robust and consistent behavior in the face of errors during request processing.\n\"\"\"",
                "source_code": "class CustomException(Exception):\n        pass\n\n    class UnacceptableCustomException(BaseException):\n        pass\n\n    @app.errorhandler(CustomException)\n    def custom_exception_handler(e):\n        assert isinstance(e, CustomException)\n        return \"custom\"\n\n    with pytest.raises(\n        AssertionError, match=\"Custom exceptions must be subclasses of Exception.\"\n    ):\n        app.register_error_handler(UnacceptableCustomException, None)\n\n    @app.errorhandler(500)\n    def handle_500(e):\n        assert isinstance(e, InternalServerError)\n        original = getattr(e, \"original_exception\", None)\n\n        if original is not None:\n            return f\"wrapped {type(original).__name__}\"\n\n        return \"direct\"\n\n    @app.route(\"/custom\")\n    def custom_test():\n        raise CustomException()\n\n    @app.route(\"/keyerror\")\n    def key_error():\n        raise KeyError()\n\n    @app.route(\"/abort\")\n    def do_abort():\n        flask.abort(500)\n\n    app.testing = False\n    assert client.get(\"/custom\").data == b\"custom\"\n    assert client.get(\"/keyerror\").data == b\"wrapped KeyError\"\n    assert client.get(\"/abort\").data == b\"direct\""
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_error_handler_subclass",
                "second_doc": "\"\"\"\nTests the behavior of the application's error handling system with respect to exception inheritance, specifically verifying that requests raising an exception are handled by the most specific registered error handler available for that exception or its parent classes.\n\nArgs:\n    None\n\nReturns:\n    None\n\nWhy:\n    This method ensures that the error handler resolution mechanism correctly prioritizes the most specific handler for an exception, falling back to more general handlers as appropriate, which is crucial to ensure robust and predictable error processing within web applications.\n\"\"\"",
                "source_code": "class ParentException(Exception):\n        pass\n\n    class ChildExceptionUnregistered(ParentException):\n        pass\n\n    class ChildExceptionRegistered(ParentException):\n        pass\n\n    @app.errorhandler(ParentException)\n    def parent_exception_handler(e):\n        assert isinstance(e, ParentException)\n        return \"parent\"\n\n    @app.errorhandler(ChildExceptionRegistered)\n    def child_exception_handler(e):\n        assert isinstance(e, ChildExceptionRegistered)\n        return \"child-registered\"\n\n    @app.route(\"/parent\")\n    def parent_test():\n        raise ParentException()\n\n    @app.route(\"/child-unregistered\")\n    def unregistered_test():\n        raise ChildExceptionUnregistered()\n\n    @app.route(\"/child-registered\")\n    def registered_test():\n        raise ChildExceptionRegistered()\n\n    c = app.test_client()\n\n    assert c.get(\"/parent\").data == b\"parent\"\n    assert c.get(\"/child-unregistered\").data == b\"parent\"\n    assert c.get(\"/child-registered\").data == b\"child-registered\""
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_error_handler_http_subclass",
                "second_doc": "\"\"\"\nTests how error handlers respond to both base and subclass HTTP exceptions by raising different types of exceptions and verifying handler selection.\n\nArgs:\n    None\n\nReturns:\n    None\n\nWhy:\n    This verifies that error handling mechanisms correctly associate registered exception handlers with their respective HTTP exception classes and subclasses, ensuring accurate and predictable response behavior.\n\"\"\"",
                "source_code": "class ForbiddenSubclassRegistered(Forbidden):\n        pass\n\n    class ForbiddenSubclassUnregistered(Forbidden):\n        pass\n\n    @app.errorhandler(403)\n    def code_exception_handler(e):\n        assert isinstance(e, Forbidden)\n        return \"forbidden\"\n\n    @app.errorhandler(ForbiddenSubclassRegistered)\n    def subclass_exception_handler(e):\n        assert isinstance(e, ForbiddenSubclassRegistered)\n        return \"forbidden-registered\"\n\n    @app.route(\"/forbidden\")\n    def forbidden_test():\n        raise Forbidden()\n\n    @app.route(\"/forbidden-registered\")\n    def registered_test():\n        raise ForbiddenSubclassRegistered()\n\n    @app.route(\"/forbidden-unregistered\")\n    def unregistered_test():\n        raise ForbiddenSubclassUnregistered()\n\n    c = app.test_client()\n\n    assert c.get(\"/forbidden\").data == b\"forbidden\"\n    assert c.get(\"/forbidden-unregistered\").data == b\"forbidden\"\n    assert c.get(\"/forbidden-registered\").data == b\"forbidden-registered\""
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_error_handler_blueprint",
                "second_doc": "\"\"\"\nTests that error handlers defined at both the application and blueprint level respond appropriately to exceptions raised within their respective routes.\n\nArgs:\n    None\n\nReturns:\n    None\n\nWhy:\n    This method ensures that error handling logic is correctly scoped in the application and its blueprints, verifying that exceptions in different parts of the app are handled by the intended error handlers. This helps maintain modularity and predictable error responses across different components of the application.\n\"\"\"",
                "source_code": "bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.errorhandler(500)\n    def bp_exception_handler(e):\n        return \"bp-error\"\n\n    @bp.route(\"/error\")\n    def bp_test():\n        raise InternalServerError()\n\n    @app.errorhandler(500)\n    def app_exception_handler(e):\n        return \"app-error\"\n\n    @app.route(\"/error\")\n    def app_test():\n        raise InternalServerError()\n\n    app.register_blueprint(bp, url_prefix=\"/bp\")\n\n    c = app.test_client()\n\n    assert c.get(\"/error\").data == b\"app-error\"\n    assert c.get(\"/bp/error\").data == b\"bp-error\""
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_default_error_handler",
                "second_doc": "\"\"\"\nTests the error handling mechanism for HTTP exceptions and custom errors at both the application and blueprint levels. This ensures that the correct error handlers are invoked for each scenario, confirming that error routing and response logic behave as intended and that separation of concerns between blueprints and the main application is maintained.\n\nArgs:\n    None\n\nReturns:\n    None\n\nWhy:\n    This method validates the association between registered error handlers and specific error conditions to guarantee predictable and appropriate responses across different contexts in the application. This helps ensure robust error management in web request handling.\n\"\"\"",
                "source_code": "bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.errorhandler(HTTPException)\n    def bp_exception_handler(e):\n        assert isinstance(e, HTTPException)\n        assert isinstance(e, NotFound)\n        return \"bp-default\"\n\n    @bp.errorhandler(Forbidden)\n    def bp_forbidden_handler(e):\n        assert isinstance(e, Forbidden)\n        return \"bp-forbidden\"\n\n    @bp.route(\"/undefined\")\n    def bp_registered_test():\n        raise NotFound()\n\n    @bp.route(\"/forbidden\")\n    def bp_forbidden_test():\n        raise Forbidden()\n\n    app = flask.Flask(__name__)\n\n    @app.errorhandler(HTTPException)\n    def catchall_exception_handler(e):\n        assert isinstance(e, HTTPException)\n        assert isinstance(e, NotFound)\n        return \"default\"\n\n    @app.errorhandler(Forbidden)\n    def catchall_forbidden_handler(e):\n        assert isinstance(e, Forbidden)\n        return \"forbidden\"\n\n    @app.route(\"/forbidden\")\n    def forbidden():\n        raise Forbidden()\n\n    @app.route(\"/slash/\")\n    def slash():\n        return \"slash\"\n\n    app.register_blueprint(bp, url_prefix=\"/bp\")\n\n    c = app.test_client()\n    assert c.get(\"/bp/undefined\").data == b\"bp-default\"\n    assert c.get(\"/bp/forbidden\").data == b\"bp-forbidden\"\n    assert c.get(\"/undefined\").data == b\"default\"\n    assert c.get(\"/forbidden\").data == b\"forbidden\"\n    # Don't handle RequestRedirect raised when adding slash.\n    assert c.get(\"/slash\", follow_redirects=True).data == b\"slash\""
            },
            "type": "function"
        },
        {
            "methods": [
                {
                    "docstring": null,
                    "method_name": "app",
                    "second_doc": "\"\"\"\nCreates and configures a Flask test application with custom routes that deliberately raise various exceptions for the purpose of testing error handling behavior.\n\nThese routes simulate different error conditions that a server may encounter, allowing thorough verification of exception propagation, response codes, and error handling logic.\n\nArgs:\n    None\n\nReturns:\n    Flask: A configured Flask application instance with predefined routes for error simulation.\n\"\"\"",
                    "source_code": "@app.route(\"/custom\")\n        def do_custom():\n            raise self.Custom()\n\n        @app.route(\"/error\")\n        def do_error():\n            raise KeyError()\n\n        @app.route(\"/abort\")\n        def do_abort():\n            flask.abort(500)\n\n        @app.route(\"/raise\")\n        def do_raise():\n            raise InternalServerError()\n\n        app.config[\"PROPAGATE_EXCEPTIONS\"] = False\n        return app"
                },
                {
                    "docstring": null,
                    "method_name": "report_error",
                    "second_doc": "\"\"\"\nAnalyzes an exception to determine if it is a direct error or wraps another original exception, returning a descriptive string. This distinction is useful for diagnostics and for understanding the structure of errors encountered during request handling.\n\nArgs:\n    e (Exception): The exception instance to be analyzed.\n\nReturns:\n    str: A string describing whether the error is a direct exception or wrapped around another exception, including the exception type.\n\"\"\"",
                    "source_code": "original = getattr(e, \"original_exception\", None)\n\n        if original is not None:\n            return f\"wrapped {type(original).__name__}\"\n\n        return f\"direct {type(e).__name__}\""
                },
                {
                    "docstring": "\"\"\"``InternalServerError`` and ``500`` are aliases, they should\n        have the same behavior. Both should only receive\n        ``InternalServerError``, which might wrap another error.\n        \"\"\"",
                    "first_doc": "\"\"\"\nTests that both InternalServerError and HTTP 500 error handler registrations behave identically and handle InternalServerError as expected, regardless of whether the error is wrapped or direct.\n\nArgs:\n    self: The test case instance.\n    app: The application instance where the error handler is registered.\n    client: The test client used to make requests to the application.\n    to_handle: The error type or code (either InternalServerError or 500) to parameterize the test.\n\nReturns:\n    None: This method performs assertions to verify correct application behavior and does not return a value.\n\"\"\"",
                    "method_name": "test_handle_class_or_code",
                    "second_doc": "\"\"\"\nEnsures that error handlers respond consistently to server errors, whether the error is triggered directly or wrapped internally, to maintain predictable error handling behavior in web applications.\n\nArgs:\n    self: The test case instance.\n    app: The Flask application instance with the error handler registered.\n    client: The test client used to simulate requests to the application.\n    to_handle: The error handler target, parameterized as either InternalServerError or the HTTP 500 status code.\n\nReturns:\n    None: Performs assertions to validate correct error handling, without returning a value.\n\"\"\"",
                    "source_code": "@app.errorhandler(to_handle)\n        def handle_500(e):\n            assert isinstance(e, InternalServerError)\n            return self.report_error(e)\n\n        assert client.get(\"/custom\").data == b\"wrapped Custom\"\n        assert client.get(\"/error\").data == b\"wrapped KeyError\"\n        assert client.get(\"/abort\").data == b\"direct InternalServerError\"\n        assert client.get(\"/raise\").data == b\"direct InternalServerError\""
                },
                {
                    "docstring": "\"\"\"``HTTPException`` should only receive ``HTTPException``\n        subclasses. It will receive ``404`` routing exceptions.\n        \"\"\"",
                    "first_doc": "\"\"\"\nTests the HTTPException error handler for generic HTTP errors in a Flask application.\n\nArgs:\n    self: The test case instance.\n    app: The Flask application instance to attach the error handler to.\n    client: The test client used to simulate HTTP requests.\n\nReturns:\n    None. The method asserts correctness of HTTP error handling by the application.\n\"\"\"",
                    "method_name": "test_handle_generic_http",
                    "second_doc": "\"\"\"\nVerifies that the application correctly handles generic HTTP errors and returns appropriate status codes in the HTTP response body. This ensures reliable error reporting to clients and consistent error handling behavior within the application.\n\nArgs:\n    self: The current test case instance.\n    app: The Flask application instance, used for registering error handlers within the test scope.\n    client: The Flask test client instance, used to simulate HTTP requests for endpoints that trigger HTTP exceptions.\n\nReturns:\n    None. The method uses assertions to validate that error responses from the application match expected HTTP status codes.\n\"\"\"",
                    "source_code": "@app.errorhandler(HTTPException)\n        def handle_http(e):\n            assert isinstance(e, HTTPException)\n            return str(e.code)\n\n        assert client.get(\"/error\").data == b\"500\"\n        assert client.get(\"/abort\").data == b\"500\"\n        assert client.get(\"/not-found\").data == b\"404\""
                },
                {
                    "docstring": "\"\"\"Generic ``Exception`` will handle all exceptions directly,\n        including ``HTTPExceptions``.\n        \"\"\"",
                    "first_doc": "\"\"\"\nTests that a generic exception handler is registered and functions correctly for all exceptions, including HTTP exceptions.\n\nArgs:\n    self: The test case instance.\n    app: The Flask application to register the error handler with.\n    client: The test client used to send requests to the Flask application.\n\nReturns:\n    None. This method performs assertions to verify response data when various errors are triggered.\n\"\"\"",
                    "method_name": "test_handle_generic",
                    "second_doc": "\"\"\"\nVerifies that the application's error handling mechanism consistently processes different types of exceptions by invoking a custom error reporter. This ensures robustness and predictable error responses when unforeseen or common errors occur during request handling.\n\nArgs:\n    self: The current test case instance.\n    app: The Flask application instance in which the generic error handler is registered.\n    client: The Flask test client used to simulate HTTP requests and capture response data.\n\nReturns:\n    None: The method uses assertions to confirm the expected responses are returned for various endpoint-induced exceptions.\n\"\"\"",
                    "source_code": "@app.errorhandler(Exception)\n        def handle_exception(e):\n            return self.report_error(e)\n\n        assert client.get(\"/custom\").data == b\"direct Custom\"\n        assert client.get(\"/error\").data == b\"direct KeyError\"\n        assert client.get(\"/abort\").data == b\"direct InternalServerError\"\n        assert client.get(\"/not-found\").data == b\"direct NotFound\""
                }
            ],
            "name": "TestGenericHandlers",
            "type": "class"
        }
    ],
    "flask/tests/test_views.py": [
        {
            "details": {
                "docstring": null,
                "method_name": "common_test",
                "second_doc": "\"\"\"\nTests the routing behavior of the application's HTTP methods to ensure correct handling of GET, POST, and OPTIONS requests, as well as appropriate error responses for unsupported methods. This verification helps maintain expected web endpoint behavior and compliance with HTTP standards.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "c = app.test_client()\n\n    assert c.get(\"/\").data == b\"GET\"\n    assert c.post(\"/\").data == b\"POST\"\n    assert c.put(\"/\").status_code == 405\n    meths = parse_set_header(c.open(\"/\", method=\"OPTIONS\").headers[\"Allow\"])\n    assert sorted(meths) == [\"GET\", \"HEAD\", \"OPTIONS\", \"POST\"]"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_basic_view",
                "second_doc": "\"\"\"\nTests that the application's root endpoint correctly responds to HTTP requests by returning the method used (e.g., GET or POST). This helps ensure that the view dispatching mechanism accurately interprets and exposes request methods, verifying route configuration and handler invocation.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "class Index(flask.views.View):\n        methods = [\"GET\", \"POST\"]\n\n        def dispatch_request(self):\n            return flask.request.method\n\n    app.add_url_rule(\"/\", view_func=Index.as_view(\"index\"))\n    common_test(app)"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_method_based_view",
                "second_doc": "\"\"\"\nTests that a class-based view correctly handles different HTTP request methods (GET and POST) by registering it as a route and verifying its responses. This ensures the application properly dispatches requests to the appropriate handler methods, promoting maintainable and organized code structure for web endpoints.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "class Index(flask.views.MethodView):\n        def get(self):\n            return \"GET\"\n\n        def post(self):\n            return \"POST\"\n\n    app.add_url_rule(\"/\", view_func=Index.as_view(\"index\"))\n\n    common_test(app)"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_view_patching",
                "second_doc": "\"\"\"\nTests the patching of Flask MethodView instances by assigning a different view class and verifying that the appropriate HTTP method implementations are invoked during request handling.\n\nArgs:\n    None\n\nReturns:\n    None\n\nThis method ensures that dynamically replacing the view class for a given route works correctly, which is important for supporting flexible and customizable request handling patterns in Flask-based applications.\n\"\"\"",
                "source_code": "class Index(flask.views.MethodView):\n        def get(self):\n            1 // 0\n\n        def post(self):\n            1 // 0\n\n    class Other(Index):\n        def get(self):\n            return \"GET\"\n\n        def post(self):\n            return \"POST\"\n\n    view = Index.as_view(\"index\")\n    view.view_class = Other\n    app.add_url_rule(\"/\", view_func=view)\n    common_test(app)"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_view_inheritance",
                "second_doc": "\"\"\"\nTests whether HTTP method discovery recognizes inherited and extended methods in class-based views, ensuring correct exposure of allowed HTTP verbs on a resource.\n\nArgs:\n    None\n\nReturns:\n    None\n\nWhy:\n    Verifies that HTTP method handling for views is correctly aggregated from base and subclass implementations, ensuring accurate reflection of available actions for clients and proper API behavior.\n\"\"\"",
                "source_code": "class Index(flask.views.MethodView):\n        def get(self):\n            return \"GET\"\n\n        def post(self):\n            return \"POST\"\n\n    class BetterIndex(Index):\n        def delete(self):\n            return \"DELETE\"\n\n    app.add_url_rule(\"/\", view_func=BetterIndex.as_view(\"index\"))\n\n    meths = parse_set_header(client.open(\"/\", method=\"OPTIONS\").headers[\"Allow\"])\n    assert sorted(meths) == [\"DELETE\", \"GET\", \"HEAD\", \"OPTIONS\", \"POST\"]"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_view_decorators",
                "second_doc": "\"\"\"\nTests whether view decorators can successfully intercept and modify the HTTP response generated by a class-based view. This ensures custom headers or behaviors applied via decorators are properly integrated into the response pipeline.\n\nArgs:\n    None\n\nReturns:\n    None. Asserts conditions to verify the decorator's effect on the response.\n\"\"\"",
                "source_code": "def add_x_parachute(f):\n        def new_function(*args, **kwargs):\n            resp = flask.make_response(f(*args, **kwargs))\n            resp.headers[\"X-Parachute\"] = \"awesome\"\n            return resp\n\n        return new_function\n\n    class Index(flask.views.View):\n        decorators = [add_x_parachute]\n\n        def dispatch_request(self):\n            return \"Awesome\"\n\n    app.add_url_rule(\"/\", view_func=Index.as_view(\"index\"))\n    rv = client.get(\"/\")\n    assert rv.headers[\"X-Parachute\"] == \"awesome\"\n    assert rv.data == b\"Awesome\""
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_view_provide_automatic_options_attr",
                "second_doc": "\"\"\"\nTests the behavior of the 'provide_automatic_options' attribute in class-based views, ensuring the Flask application responds correctly to HTTP OPTIONS requests based on different configurations of view classes.\n\nArgs:\n    None\n\nReturns:\n    None\n\nWhy:\n    This method verifies how web routes handle automatic generation of HTTP OPTIONS responses for class-based views, ensuring the routing mechanism aligns with expected HTTP standards and configurable view attributes.\n\"\"\"",
                "source_code": "app = flask.Flask(__name__)\n\n    class Index1(flask.views.View):\n        provide_automatic_options = False\n\n        def dispatch_request(self):\n            return \"Hello World!\"\n\n    app.add_url_rule(\"/\", view_func=Index1.as_view(\"index\"))\n    c = app.test_client()\n    rv = c.open(\"/\", method=\"OPTIONS\")\n    assert rv.status_code == 405\n\n    app = flask.Flask(__name__)\n\n    class Index2(flask.views.View):\n        methods = [\"OPTIONS\"]\n        provide_automatic_options = True\n\n        def dispatch_request(self):\n            return \"Hello World!\"\n\n    app.add_url_rule(\"/\", view_func=Index2.as_view(\"index\"))\n    c = app.test_client()\n    rv = c.open(\"/\", method=\"OPTIONS\")\n    assert sorted(rv.allow) == [\"OPTIONS\"]\n\n    app = flask.Flask(__name__)\n\n    class Index3(flask.views.View):\n        def dispatch_request(self):\n            return \"Hello World!\"\n\n    app.add_url_rule(\"/\", view_func=Index3.as_view(\"index\"))\n    c = app.test_client()\n    rv = c.open(\"/\", method=\"OPTIONS\")\n    assert \"OPTIONS\" in rv.allow"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_implicit_head",
                "second_doc": "\"\"\"\nTests the default behavior of HTTP HEAD requests by verifying that the response is generated correctly even when only a GET handler is defined. This ensures that the framework automatically provides appropriate responses for HEAD requests, omitting the body while maintaining the correct headers.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "class Index(flask.views.MethodView):\n        def get(self):\n            return flask.Response(\"Blub\", headers={\"X-Method\": flask.request.method})\n\n    app.add_url_rule(\"/\", view_func=Index.as_view(\"index\"))\n    rv = client.get(\"/\")\n    assert rv.data == b\"Blub\"\n    assert rv.headers[\"X-Method\"] == \"GET\"\n    rv = client.head(\"/\")\n    assert rv.data == b\"\"\n    assert rv.headers[\"X-Method\"] == \"HEAD\""
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_explicit_head",
                "second_doc": "\"\"\"\nTests that the response for an explicit HTTP HEAD request differs from a GET request and properly sets custom headers.\n\nArgs:\n    None\n\nReturns:\n    None\n\nThis method ensures the application handles HEAD requests separately from GET requests, validating that no body content is returned for HEAD while custom headers are still present to confirm correct HTTP protocol behavior.\n\"\"\"",
                "source_code": "class Index(flask.views.MethodView):\n        def get(self):\n            return \"GET\"\n\n        def head(self):\n            return flask.Response(\"\", headers={\"X-Method\": \"HEAD\"})\n\n    app.add_url_rule(\"/\", view_func=Index.as_view(\"index\"))\n    rv = client.get(\"/\")\n    assert rv.data == b\"GET\"\n    rv = client.head(\"/\")\n    assert rv.data == b\"\"\n    assert rv.headers[\"X-Method\"] == \"HEAD\""
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_endpoint_override",
                "second_doc": "\"\"\"\nTests whether registering the same endpoint multiple times correctly raises an exception, ensuring that duplicate route definitions are detected and application routing remains unambiguous.\n\nArgs:\n    None\n\nReturns:\n    None\n\nRaises:\n    AssertionError: If an attempt is made to add a duplicate URL rule.\n\"\"\"",
                "source_code": "app.debug = True\n\n    class Index(flask.views.View):\n        methods = [\"GET\", \"POST\"]\n\n        def dispatch_request(self):\n            return flask.request.method\n\n    app.add_url_rule(\"/\", view_func=Index.as_view(\"index\"))\n\n    with pytest.raises(AssertionError):\n        app.add_url_rule(\"/\", view_func=Index.as_view(\"index\"))\n\n    # But these tests should still pass. We just log a warning.\n    common_test(app)"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_methods_var_inheritance",
                "second_doc": "\"\"\"\nTest that HTTP methods specified in a parent view class are properly inherited and routed in a subclass view.\n\nArgs:\n    None\n\nReturns:\n    None\n\nWhy:\n    Ensures that HTTP verb mappings defined at the class level in view hierarchies are respected during request dispatching, which is important for consistent route handling and for extending or customizing endpoint behavior through inheritance.\n\"\"\"",
                "source_code": "class BaseView(flask.views.MethodView):\n        methods = [\"GET\", \"PROPFIND\"]\n\n    class ChildView(BaseView):\n        def get(self):\n            return \"GET\"\n\n        def propfind(self):\n            return \"PROPFIND\"\n\n    app.add_url_rule(\"/\", view_func=ChildView.as_view(\"index\"))\n\n    assert client.get(\"/\").data == b\"GET\"\n    assert client.open(\"/\", method=\"PROPFIND\").data == b\"PROPFIND\"\n    assert ChildView.methods == {\"PROPFIND\", \"GET\"}"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_multiple_inheritance",
                "second_doc": "\"\"\"\nTests that a view class can inherit HTTP methods from multiple parent MethodView classes, ensuring that all inherited methods are exposed as HTTP endpoints and accessible via corresponding HTTP requests.\n\nArgs:\n    None\n\nReturns:\n    None\n\nWhy:\n    This method verifies the framework's ability to correctly support multiple inheritance for view classes, enabling flexible composition of HTTP method handlers within the application.\n\"\"\"",
                "source_code": "class GetView(flask.views.MethodView):\n        def get(self):\n            return \"GET\"\n\n    class DeleteView(flask.views.MethodView):\n        def delete(self):\n            return \"DELETE\"\n\n    class GetDeleteView(GetView, DeleteView):\n        pass\n\n    app.add_url_rule(\"/\", view_func=GetDeleteView.as_view(\"index\"))\n\n    assert client.get(\"/\").data == b\"GET\"\n    assert client.delete(\"/\").data == b\"DELETE\"\n    assert sorted(GetDeleteView.methods) == [\"DELETE\", \"GET\"]"
            },
            "type": "function"
        },
        {
            "details": {
                "docstring": null,
                "method_name": "test_remove_method_from_parent",
                "second_doc": "\"\"\"\nTests that when a view class inherits HTTP methods from multiple parent views, only the explicitly specified methods are made available, ensuring the route responds correctly and restricts unsupported methods.\n\nArgs:\n    None\n\nReturns:\n    None\n\"\"\"",
                "source_code": "class GetView(flask.views.MethodView):\n        def get(self):\n            return \"GET\"\n\n    class OtherView(flask.views.MethodView):\n        def post(self):\n            return \"POST\"\n\n    class View(GetView, OtherView):\n        methods = [\"GET\"]\n\n    app.add_url_rule(\"/\", view_func=View.as_view(\"index\"))\n\n    assert client.get(\"/\").data == b\"GET\"\n    assert client.post(\"/\").status_code == 405\n    assert sorted(View.methods) == [\"GET\"]"
            },
            "type": "function"
        }
    ]
}