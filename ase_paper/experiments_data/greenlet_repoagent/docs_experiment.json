{
    "conftest.py": [],
    "my_build_ext.py": [
        {
            "type": "class",
            "name": "build_ext",
            "methods": [
                {
                    "method_name": "initialize_options",
                    "source_code": "def initialize_options(self):\n    self.my_inplace = None\n    _build_ext.initialize_options(self)",
                    "first_doc": "**initialize_options**: The function of initialize_options is to set up initial values for options before any command-line or configuration processing occurs.\n\n**parameters**: The parameters of this Function.\n· self: Refers to the instance of the class where this method is defined.\n\n**Code Description**:  \nThis method initializes the option my_inplace by setting it to None, ensuring that the attribute exists and has a known starting value before any further processing. After setting my_inplace, it calls the initialize_options method of the parent class (_build_ext), which allows the base class to perform its own option initialization. This ensures that both the custom options defined in the subclass and the standard options from the base class are properly initialized.\n\n**Note**:  \nThis method should be called before any option values are set or used. It is important to always call the parent class’s initialize_options method to maintain compatibility and ensure that all expected options are initialized correctly."
                },
                {
                    "method_name": "finalize_options",
                    "source_code": "def finalize_options(self):\n    if self.my_inplace is None:\n        self.my_inplace = self.inplace\n        self.inplace = 0\n    _build_ext.finalize_options(self)",
                    "first_doc": "**finalize_options**: The function of finalize_options is to finalize and adjust build extension options before proceeding with the build process.\n\n**parameters**: The parameters of this Function.\n· self: Refers to the instance of the class where this method is defined.\n\n**Code Description**:  \nThis method checks if the attribute my_inplace is None. If it is, the method assigns the current value of the inplace attribute to my_inplace and then sets inplace to 0. This ensures that the original value of inplace is preserved in my_inplace, while inplace itself is reset to 0 for the subsequent build process. After these adjustments, the method calls the finalize_options method of the parent _build_ext class to perform any additional finalization steps required by the base implementation.\n\n**Note**:  \n- This method is intended to be used as part of a custom build extension process, typically within a build system or setup script.\n- It is important that my_inplace and inplace are properly initialized and managed elsewhere in the class to avoid unexpected behavior.\n- The call to the parent class's finalize_options ensures that standard build extension finalization logic is not bypassed."
                },
                {
                    "method_name": "build_extension",
                    "source_code": "def build_extension(self, ext):\n    _build_ext.build_extension(self, ext)\n    if not self.my_inplace:\n        build_lib = os.path.abspath(self.build_lib)\n        if build_lib not in sys.path:\n            sys.path.insert(0, build_lib)\n        return\n    filename = self.get_ext_filename(ext.name)\n    build_path = os.path.abspath(os.path.join(self.build_lib, filename))\n    src_path = os.path.abspath(filename)\n    if build_path != src_path:\n        try:\n            os.unlink(src_path)\n        except OSError:\n            pass\n\n        if self.verbose:\n            sys.stderr.write('Linking %s to %s\\n' % (build_path, src_path))\n\n        symlink_or_copy(build_path, src_path)",
                    "first_doc": "**build_extension**: The function of build_extension is to handle the process of building a single extension module, managing both standard and \"in-place\" build scenarios.\n\n**parameters**: The parameters of this Function.\n· ext: The extension module object to be built.\n\n**Code Description**:  \nThis function first delegates the core build process to the parent _build_ext.build_extension method, which compiles and links the extension module as specified. After the standard build, the function checks whether the build should be performed \"in place\" (i.e., placing the built extension directly into the source directory rather than the build directory) by evaluating the my_inplace attribute.\n\n- If my_inplace is False (not an in-place build), the function ensures that the build output directory (build_lib) is present in sys.path. This is necessary so that the newly built extension can be imported and used immediately after building, even if it resides outside the source directory. The function then returns, as no further action is needed.\n\n- If my_inplace is True (in-place build), the function determines the expected filename for the extension using get_ext_filename, and computes both the build path (where the extension was built) and the source path (where the extension should appear in the source directory). If these paths differ, it attempts to remove any existing file at the source path to avoid conflicts.\n\n  If verbose mode is enabled, a message is written to sys.stderr indicating the linking or copying action. The function then calls symlink_or_copy to either create a symbolic link from the build output to the source directory or copy the file if symbolic linking is not available. This ensures that the built extension is accessible in the source directory, regardless of the underlying platform's capabilities.\n\nThe symlink_or_copy function is responsible for handling the platform-specific details of linking or copying, providing a seamless experience across different operating systems.\n\n**Note**:  \n- The function modifies sys.path only when not building in place, ensuring that the built extension can be imported immediately.\n- When building in place, any existing file at the target location is unlinked (deleted) before the new file is linked or copied.\n- The function relies on symlink_or_copy to handle differences between operating systems regarding symbolic link support.\n- No value is returned by this function; its effect is the side effect of building and placing the extension module in the appropriate location.\n\n**Output Example**:  \nThis function does not return a value. After execution, the built extension module will be available either in the build directory (with sys.path updated accordingly) or in the source directory (linked or copied), depending on the build mode. For example, after calling build_extension(ext), the extension ext will be accessible for import in the intended location."
                }
            ]
        }
    ],
    "setup.py": [],
    "run-tests.py": [],
    "tests/test_leaks.py": [
        {
            "type": "class",
            "name": "ArgRefcountTests",
            "methods": [
                {
                    "method_name": "test_arg_refs",
                    "source_code": "def test_arg_refs(self):\n    args = ('a', 'b', 'c')\n    refcount_before = sys.getrefcount(args)\n    g = greenlet.greenlet(\n        lambda *args: greenlet.getcurrent().parent.switch(*args))\n    for i in range(100):\n        g.switch(*args)\n    self.assertEqual(sys.getrefcount(args), refcount_before)",
                    "first_doc": "**test_arg_refs**: The function of test_arg_refs is to verify that repeatedly switching a greenlet with the same argument tuple does not increase its reference count, ensuring there are no reference leaks.\n\n**parameters**: The parameters of this Function.\n· self: The instance of the test case class, used to access assertion methods.\n\n**Code Description**:  \nThis function creates a tuple args containing three string elements: 'a', 'b', and 'c'. It then records the initial reference count of this tuple using sys.getrefcount. A new greenlet is created, which, when switched to, immediately switches back to its parent greenlet, passing along any arguments it receives. The function then performs 100 switches to this greenlet, each time passing the same args tuple as arguments. After all switches, it asserts that the reference count of args remains unchanged compared to its initial value. This confirms that the greenlet switching mechanism does not introduce reference leaks for the argument tuple.\n\n**Note**:  \n- This test is specifically designed to detect reference leaks related to argument passing in greenlet context switches.\n- The use of sys.getrefcount provides a direct way to monitor reference count changes, but it should be noted that the value returned by getrefcount can be affected by temporary references within the function itself.\n- The test assumes that the greenlet and sys modules are properly imported and available in the test environment."
                },
                {
                    "method_name": "test_kwarg_refs",
                    "source_code": "def test_kwarg_refs(self):\n    kwargs = {}\n    g = greenlet.greenlet(\n        lambda **kwargs: greenlet.getcurrent().parent.switch(**kwargs))\n    for i in range(100):\n        g.switch(**kwargs)\n    self.assertEqual(sys.getrefcount(kwargs), 2)",
                    "first_doc": "**test_kwarg_refs**: The function of test_kwarg_refs is to verify that repeatedly switching a greenlet with keyword arguments does not cause a reference count leak for the kwargs dictionary.\n\n**parameters**: The parameters of this Function.\n· self: The instance of the test case class, used to access test methods and assertions.\n\n**Code Description**:  \nThis function is a unit test designed to check for reference leaks when passing keyword arguments to a greenlet. It begins by creating an empty dictionary named kwargs. A new greenlet is then instantiated, with its run function defined as a lambda that accepts arbitrary keyword arguments and immediately switches control back to its parent greenlet, passing along the same keyword arguments.\n\nThe test then enters a loop that runs 100 times. In each iteration, it switches to the greenlet, passing the kwargs dictionary as keyword arguments. After the loop, the function asserts that the reference count of the kwargs dictionary is exactly 2. This ensures that switching the greenlet with the same kwargs dictionary multiple times does not increase its reference count, confirming that no reference leak occurs during the process.\n\n**Note**:  \n- This test relies on the behavior of sys.getrefcount, which returns the reference count of the object plus one for the temporary reference as an argument to getrefcount.\n- The test assumes that the greenlet implementation does not retain unnecessary references to the kwargs dictionary after switching.\n- The test is specific to the CPython implementation, as reference counting and sys.getrefcount are implementation details of CPython."
                },
                {
                    "method_name": "recycle_threads",
                    "source_code": "def recycle_threads(self):\n    # By introducing a thread that does sleep we allow other threads,\n    # that have triggered their __block condition, but did not have a\n    # chance to deallocate their thread state yet, to finally do so.\n    # The way it works is by requring a GIL switch (different thread),\n    # which does a GIL release (sleep), which might do a GIL switch\n    # to finished threads and allow them to clean up.\n    def worker():\n        time.sleep(0.001)\n    t = threading.Thread(target=worker)\n    t.start()\n    time.sleep(0.001)\n    t.join()",
                    "first_doc": "**recycle_threads**: The function of recycle_threads is to facilitate the cleanup and deallocation of thread states by forcing a context switch between threads.\n\n**parameters**: The parameters of this Function.\n· self: Reference to the instance of the test case class (ArgRefcountTests).\n\n**Code Description**:  \nThis method is designed to assist in the proper cleanup of thread states, particularly in the context of reference counting and garbage collection tests involving threads and greenlets. The method defines a short-lived worker function that simply sleeps for a brief period (0.001 seconds). It then creates and starts a new thread to execute this worker function. After starting the thread, the main thread also sleeps for the same short duration before joining the worker thread to ensure it has finished execution.\n\nThe purpose of this sequence is to force a Global Interpreter Lock (GIL) switch. By introducing a new thread that sleeps, the method ensures that any threads which have triggered their __block condition but have not yet had the opportunity to deallocate their thread state are given a chance to do so. The sleep operation in the worker thread causes the GIL to be released, which may allow the Python interpreter to switch to other threads that have finished but are pending cleanup. This mechanism is particularly important in tests that check for memory leaks or reference count issues in multi-threaded scenarios.\n\nWithin the project, recycle_threads is called by test_threaded_leak and test_threaded_adv_leak. In both cases, after running threaded operations and before performing garbage collection and assertions, recycle_threads is invoked to ensure that all thread states are properly cleaned up. This helps to avoid false positives in leak detection by making sure that any lingering thread states are finalized before reference checks are performed.\n\n**Note**:  \n- This method is intended for use in test environments where precise control over thread state cleanup is necessary, especially when testing for memory leaks or reference count issues.\n- The timing (sleep duration) is chosen to be minimal but sufficient to trigger a GIL switch; it should not be altered unless necessary for the test environment.\n- This method should be used in conjunction with explicit garbage collection and reference checks to ensure accurate test results."
                },
                {
                    "method_name": "worker",
                    "source_code": "def worker():\n    time.sleep(0.001)",
                    "first_doc": "**worker**: The function of worker is to pause execution for a short period of time.\n\n**parameters**: The parameters of this Function.\n· None\n\n**Code Description**:  \nThis function, when called, causes the current thread to sleep for 0.001 seconds (one millisecond). It achieves this by invoking time.sleep with the specified duration. The function does not accept any arguments and does not return any value. Its sole purpose is to introduce a minimal delay in the thread's execution flow.\n\n**Note**:  \nThis function is typically used in scenarios where a brief pause is required, such as in multi-threaded tests to simulate work or to yield execution. The duration of the sleep is very short and may be affected by the system's timer resolution."
                },
                {
                    "method_name": "test_threaded_leak",
                    "source_code": "def test_threaded_leak(self):\n    gg = []\n    def worker():\n        # only main greenlet present\n        gg.append(weakref.ref(greenlet.getcurrent()))\n    for i in range(2):\n        t = threading.Thread(target=worker)\n        t.start()\n        t.join()\n        del t\n    greenlet.getcurrent() # update ts_current\n    self.recycle_threads()\n    greenlet.getcurrent() # update ts_current\n    gc.collect()\n    greenlet.getcurrent() # update ts_current\n    for g in gg:\n        self.assertTrue(g() is None)",
                    "first_doc": "**test_threaded_leak**: The function of test_threaded_leak is to verify that greenlet objects created in separate threads do not leak memory after the threads have finished execution.\n\n**parameters**: The parameters of this Function.\n· self: Reference to the instance of the ArgRefcountTests test case class.\n\n**Code Description**:  \nThis method is designed to test for memory leaks related to greenlet objects in a multi-threaded environment. It achieves this by creating a list, gg, to store weak references to the greenlet objects associated with each thread. The worker function, defined within test_threaded_leak, appends a weak reference to the current greenlet (obtained via greenlet.getcurrent()) to the gg list. This function is executed in two separate threads, each of which is started, joined, and then deleted to ensure proper thread lifecycle management.\n\nAfter the threads have completed, greenlet.getcurrent() is called multiple times to update the thread state and ensure the main thread's greenlet context is current. The method then calls self.recycle_threads(), which is responsible for facilitating the cleanup and deallocation of thread states by forcing a context switch between threads. This step is crucial to ensure that any thread-local resources, including greenlet objects, are properly finalized.\n\nFollowing the thread recycling, garbage collection is explicitly triggered using gc.collect() to ensure that any unreachable objects are collected. The method then iterates over the list of weak references (gg) and asserts that each referenced greenlet object has been properly garbage collected (i.e., g() is None). This confirms that no greenlet objects from the worker threads have leaked.\n\n**Note**:  \n- This method is intended for use in test environments to detect memory leaks involving greenlet objects in threaded scenarios.\n- The use of weak references ensures that the test only passes if the greenlet objects are truly deallocated after thread termination.\n- The recycle_threads method is essential to guarantee that thread states are cleaned up before garbage collection and reference checks are performed.\n- Multiple calls to greenlet.getcurrent() are used to update the thread state and ensure the test environment is consistent before and after cleanup operations."
                },
                {
                    "method_name": "worker",
                    "source_code": "def worker():\n    # only main greenlet present\n    gg.append(weakref.ref(greenlet.getcurrent()))",
                    "first_doc": "**worker**: The function of worker is to append a weak reference to the current greenlet to the list gg.\n\n**parameters**: The parameters of this Function.\n· None: This function does not accept any parameters.\n\n**Code Description**:  \nThis function, when called, retrieves the current greenlet using greenlet.getcurrent(). It then creates a weak reference to this greenlet object using weakref.ref and appends this weak reference to the list gg. The comment indicates that only the main greenlet is present at the time this function executes. This approach helps in tracking greenlet objects without preventing their garbage collection, which is useful for detecting memory leaks or monitoring object lifetimes in threaded or concurrent environments.\n\n**Note**:  \n- The function assumes that the list gg is defined and accessible in the enclosing scope.\n- The greenlet and weakref modules must be imported and available.\n- This function is intended for use in a context where greenlet-based concurrency is being tested, particularly for reference counting or leak detection.\n- No arguments are required when calling this function."
                },
                {
                    "method_name": "test_threaded_adv_leak",
                    "source_code": "def test_threaded_adv_leak(self):\n    gg = []\n    def worker():\n        # main and additional *finished* greenlets\n        ll = greenlet.getcurrent().ll = []\n        def additional():\n            ll.append(greenlet.getcurrent())\n        for i in range(2):\n            greenlet.greenlet(additional).switch()\n        gg.append(weakref.ref(greenlet.getcurrent()))\n    for i in range(2):\n        t = threading.Thread(target=worker)\n        t.start()\n        t.join()\n        del t\n    greenlet.getcurrent() # update ts_current\n    self.recycle_threads()\n    greenlet.getcurrent() # update ts_current\n    gc.collect()\n    greenlet.getcurrent() # update ts_current\n    for g in gg:\n        self.assertTrue(g() is None)",
                    "first_doc": "**test_threaded_adv_leak**: The function of test_threaded_adv_leak is to verify that no reference leaks occur when using greenlets in a multi-threaded environment, particularly after greenlets have finished execution and threads have been cleaned up.\n\n**parameters**: The parameters of this Function.\n· self: Reference to the instance of the ArgRefcountTests test case class.\n\n**Code Description**:  \nThis method is designed as a test case to ensure that greenlets, when used in conjunction with threads, do not result in reference leaks after the threads and greenlets have completed their execution. The test proceeds as follows:\n\n1. An empty list gg is initialized to store weak references to greenlet objects.\n2. A worker function is defined. Within this function:\n   - A list ll is attached to the current greenlet object (via greenlet.getcurrent().ll) to hold references to additional greenlets.\n   - An inner function additional is defined, which appends the current greenlet to ll.\n   - The worker then creates and switches to two new greenlets, each running the additional function, ensuring that these greenlets are created and finished within the worker's context.\n   - After creating the additional greenlets, a weak reference to the current greenlet is appended to gg.\n3. The worker function is executed in two separate threads. Each thread is started, joined (waited for completion), and then deleted to ensure proper thread lifecycle management.\n4. After all threads have run, greenlet.getcurrent() is called multiple times to update the thread state for the current greenlet context.\n5. The recycle_threads method is called to force a context switch and facilitate the cleanup and deallocation of thread states. This is crucial to ensure that any threads that have finished but not yet had their thread state deallocated are given the opportunity to do so.\n6. Explicit garbage collection is triggered using gc.collect() to finalize the cleanup of any objects that are no longer referenced.\n7. Finally, the test iterates over all weak references in gg and asserts that each referenced greenlet object has been properly collected (i.e., the weak reference returns None), confirming that no reference leaks remain.\n\nThe method relies on recycle_threads to ensure that thread state cleanup is enforced before performing garbage collection and leak checks. This sequence is essential to avoid false positives in leak detection, as thread-local storage and greenlet state may otherwise persist longer than expected.\n\n**Note**:  \n- This test is specifically designed for environments where greenlets and threads are used together, and it checks for proper cleanup and absence of reference leaks.\n- The use of weak references ensures that the test only passes if greenlet objects are truly deallocated after thread and greenlet execution.\n- The test should be run in an environment where explicit garbage collection and thread state management are necessary to accurately detect leaks.\n- Proper functioning of this test depends on the correct implementation of thread and greenlet cleanup mechanisms in the underlying libraries."
                },
                {
                    "method_name": "worker",
                    "source_code": "def worker():\n    # main and additional *finished* greenlets\n    ll = greenlet.getcurrent().ll = []\n    def additional():\n        ll.append(greenlet.getcurrent())\n    for i in range(2):\n        greenlet.greenlet(additional).switch()\n    gg.append(weakref.ref(greenlet.getcurrent()))",
                    "first_doc": "**worker**: The function of worker is to create and manage additional greenlets, collect references to them, and store a weak reference to the current greenlet.\n\n**parameters**: The parameters of this Function.\n· None\n\n**Code Description**:  \nThe worker function operates within the context of greenlets (lightweight coroutines). It begins by creating an empty list ll and assigns it as an attribute to the current greenlet object (greenlet.getcurrent().ll). Inside worker, a nested function named additional is defined, which, when executed, appends the current greenlet (greenlet.getcurrent()) to the ll list.\n\nThe worker function then creates and switches to two new greenlets, each running the additional function. As a result, two greenlet objects are appended to the ll list, representing the additional greenlets that have been started and finished.\n\nAfter creating and switching to the additional greenlets, the function appends a weak reference to the current greenlet (greenlet.getcurrent()) to the global list gg. This allows for later inspection of the greenlet's lifecycle without preventing its garbage collection.\n\n**Note**:  \n- This function assumes that the global list gg is defined and accessible in the surrounding scope.\n- The function is designed for use in a context where greenlet-based concurrency is being tested, particularly for reference counting and leak detection.\n- The ll attribute is dynamically attached to the current greenlet, which may not be standard practice outside of testing or experimental scenarios.\n- The use of weakref.ref ensures that the reference to the current greenlet does not prevent it from being garbage collected."
                },
                {
                    "method_name": "additional",
                    "source_code": "def additional():\n    ll.append(greenlet.getcurrent())",
                    "first_doc": "**additional**: The function of additional is to append the current greenlet object to the list ll.\n\n**parameters**: The parameters of this Function.\n· None: This function does not accept any parameters.\n\n**Code Description**:  \nThis function utilizes the greenlet.getcurrent() method to obtain a reference to the currently executing greenlet (a lightweight coroutine-like object). It then appends this reference to the list named ll. The function does not return any value and is intended to be used in a context where tracking or collecting references to active greenlets is necessary, such as in concurrency or memory leak tests.\n\n**Note**:  \n- The list ll and the greenlet module must be defined and imported in the enclosing scope for this function to operate correctly.\n- This function is designed for internal use, likely within a test or monitoring scenario, and assumes that the environment is already set up for greenlet-based concurrency.\n- Improper management of the ll list may lead to unintended memory retention, as references to greenlet objects are stored."
                }
            ]
        }
    ],
    "tests/test_cpp.py": [
        {
            "type": "class",
            "name": "CPPTests",
            "methods": [
                {
                    "method_name": "test_exception_switch",
                    "source_code": "def test_exception_switch(self):\n    greenlets = []\n    for i in range(4):\n        g = greenlet.greenlet(_test_extension_cpp.test_exception_switch)\n        g.switch(i)\n        greenlets.append(g)\n    for i, g in enumerate(greenlets):\n        self.assertEqual(g.switch(), i)",
                    "first_doc": "**test_exception_switch**: The function of test_exception_switch is to test the behavior of exception handling and value switching in greenlets created with a C++ extension.\n\n**parameters**: The parameters of this Function.\n· self: The instance of the test case class, used to access test methods and assertions.\n\n**Code Description**:  \nThis function creates a list of greenlets, each initialized with the function _test_extension_cpp.test_exception_switch. It iterates four times, and in each iteration, it creates a new greenlet, switches to it with the current index i as an argument, and appends the greenlet to the greenlets list. After all greenlets are created and switched once, the function iterates over the list of greenlets. For each greenlet, it calls switch() again and asserts that the value returned matches the index i. This ensures that each greenlet, when switched, returns the expected value, verifying the correct handling of control flow and value passing, particularly in the context of exception handling within the C++ extension.\n\n**Note**:  \n- The function assumes that _test_extension_cpp.test_exception_switch is a valid callable compatible with greenlet.greenlet.\n- The test relies on the correct implementation of exception handling and value propagation in the C++ extension.\n- The test uses self.assertEqual, indicating it is intended to be run within a unittest.TestCase or similar testing framework."
                }
            ]
        }
    ],
    "tests/test_tracing.py": [
        {
            "type": "class",
            "name": "SomeError",
            "methods": []
        },
        {
            "type": "class",
            "name": "TracingTests",
            "methods": [
                {
                    "method_name": "test_greenlet_tracing",
                    "source_code": "def test_greenlet_tracing(self):\n    main = greenlet.getcurrent()\n    actions = []\n    def trace(*args):\n        actions.append(args)\n    def dummy():\n        pass\n    def dummyexc():\n        raise SomeError()\n    oldtrace = greenlet.settrace(trace)\n    try:\n        g1 = greenlet.greenlet(dummy)\n        g1.switch()\n        g2 = greenlet.greenlet(dummyexc)\n        self.assertRaises(SomeError, g2.switch)\n    finally:\n        greenlet.settrace(oldtrace)\n    self.assertEqual(actions, [\n        ('switch', (main, g1)),\n        ('switch', (g1, main)),\n        ('switch', (main, g2)),\n        ('throw', (g2, main)),\n    ])",
                    "first_doc": "**test_greenlet_tracing**: The function of test_greenlet_tracing is to verify that the greenlet tracing mechanism correctly records context switches and exception propagation between greenlets.\n\n**parameters**: The parameters of this Function.\n· self: The instance of the test case class, used to access assertion methods and maintain test context.\n\n**Code Description**:  \nThis function is a unit test designed to ensure that the greenlet tracing facility operates as expected during both normal and exceptional control flow between greenlets. The test performs the following steps:\n\n1. It retrieves the current (main) greenlet using greenlet.getcurrent().\n2. It initializes an empty list, actions, to record trace events.\n3. It defines a trace callback function, trace, which appends its arguments to the actions list whenever a greenlet event occurs.\n4. It defines two simple functions:\n   - dummy: a no-op function for normal greenlet execution.\n   - dummyexc: a function that raises a custom exception, SomeError, to simulate an error in a greenlet.\n5. It sets the greenlet tracing function to the custom trace callback using greenlet.settrace(trace), saving the previous trace function for later restoration.\n6. Within a try/finally block to ensure cleanup:\n   - It creates and switches to a greenlet running dummy, recording the switch events.\n   - It creates and switches to a greenlet running dummyexc, expecting it to raise SomeError. The test asserts that this exception is raised using self.assertRaises.\n7. After the test actions, it restores the original trace function with greenlet.settrace(oldtrace) in the finally block to avoid side effects on other tests.\n8. Finally, it asserts that the actions list matches the expected sequence of events:\n   - ('switch', (main, g1)): Switching from the main greenlet to g1.\n   - ('switch', (g1, main)): Switching back from g1 to the main greenlet.\n   - ('switch', (main, g2)): Switching from the main greenlet to g2.\n   - ('throw', (g2, main)): An exception (SomeError) is thrown from g2 back to the main greenlet.\n\nThe test relies on the custom exception SomeError to clearly distinguish the error event during tracing. The trace callback captures both 'switch' and 'throw' events, allowing the test to verify the precise order and nature of greenlet context changes.\n\n**Note**:  \n- This test is specifically designed for use with the greenlet library's tracing API and assumes that greenlet.settrace and related tracing features are available.\n- The test ensures that the tracing function is always restored to its previous state, even if an exception occurs, to prevent interference with other tests.\n- The custom exception SomeError is used solely for testing and should not be used in production code.\n- The test checks both normal greenlet switching and exception propagation, making it a comprehensive check for greenlet tracing behavior."
                },
                {
                    "method_name": "trace",
                    "source_code": "def trace(*args):\n    actions.append(args)",
                    "first_doc": "**trace**: The function of trace is to record its input arguments by appending them as a tuple to the actions list.\n\n**parameters**: The parameters of this Function.\n· *args: A variable-length argument list capturing all positional arguments passed to the function.\n\n**Code Description**:  \nThe trace function is designed to accept any number of positional arguments. When called, it collects all provided arguments into a tuple (via *args) and appends this tuple to the actions list. This effectively logs every invocation of trace, preserving the exact arguments that were passed each time. The function does not return any value or perform any processing beyond this logging action. The actions list must exist in the enclosing scope for trace to function correctly.\n\n**Note**:  \n- The actions list must be defined and accessible in the scope where trace is used; otherwise, a NameError will occur.\n- The function is intended for tracking or logging calls and their arguments, which is useful in testing or tracing scenarios.\n- No validation or transformation is performed on the input arguments; they are stored as-is."
                },
                {
                    "method_name": "dummy",
                    "source_code": "def dummy():\n    pass",
                    "first_doc": "**dummy**: The function of dummy is to serve as a placeholder function that performs no operations.\n\n**parameters**: The parameters of this Function.\n· None\n\n**Code Description**:  \nThe dummy function is defined without any parameters and contains only a pass statement. This means that when the function is called, it will immediately return without executing any code or producing any side effects. Such functions are commonly used as stubs during development or testing, where a function is required syntactically but no actual logic is needed at that point. It can also be used to temporarily disable functionality or to provide a minimal implementation for interface compatibility.\n\n**Note**:  \n- The dummy function does not accept any arguments and does not return any value.\n- It is intended solely for structural or placeholder purposes and should be replaced or extended with actual logic as needed in the final implementation.\n- Using dummy functions can help avoid errors related to missing function definitions during testing or prototyping."
                },
                {
                    "method_name": "dummyexc",
                    "source_code": "def dummyexc():\n    raise SomeError()",
                    "first_doc": "**dummyexc**: The function of dummyexc is to deliberately raise a custom exception (SomeError) for testing purposes.\n\n**parameters**: The parameters of this Function.\n· None. dummyexc does not accept any parameters.\n\n**Code Description**:  \ndummyexc is a simple utility function designed for use within test scenarios, particularly those involving tracing and exception handling in greenlet-based concurrency. When called, dummyexc immediately raises an instance of the custom exception SomeError. This behavior is intentional and is used to simulate error conditions within a controlled environment, allowing tests to verify that exceptions are correctly propagated, caught, and traced as expected.\n\nThe function relies on the SomeError class, which is a custom exception type defined specifically for the test suite. By raising SomeError, dummyexc ensures that the tests can distinguish between expected, intentional exceptions and any other unexpected errors that may occur during execution.\n\nWithin the context of greenlet tracing tests, dummyexc is typically executed inside a greenlet to trigger an exception event. This allows the test framework to observe and assert the correct handling of exceptions, including the proper recording of 'throw' events in the tracing mechanism.\n\n**Note**:  \ndummyexc is intended solely for use in testing environments. It should not be used in production code, as its sole purpose is to raise a test-specific exception. When using this function, ensure that the calling code is prepared to handle the SomeError exception, and that its use is limited to scenarios where controlled exception raising is required for validation or tracing purposes."
                },
                {
                    "method_name": "test_exception_disables_tracing",
                    "source_code": "def test_exception_disables_tracing(self):\n    main = greenlet.getcurrent()\n    actions = []\n    def trace(*args):\n        actions.append(args)\n        raise SomeError()\n    def dummy():\n        main.switch()\n    g = greenlet.greenlet(dummy)\n    g.switch()\n    oldtrace = greenlet.settrace(trace)\n    try:\n        self.assertRaises(SomeError, g.switch)\n        self.assertEqual(greenlet.gettrace(), None)\n    finally:\n        greenlet.settrace(oldtrace)\n    self.assertEqual(actions, [\n        ('switch', (main, g)),\n    ])",
                    "first_doc": "**test_exception_disables_tracing**: The function of test_exception_disables_tracing is to verify that an exception raised within a greenlet trace callback disables further tracing and resets the trace function to None.\n\n**parameters**: The parameters of this Function.\n· self: The instance of the test case class, used to access assertion methods and maintain test context.\n\n**Code Description**:  \nThis function tests the behavior of the greenlet tracing mechanism when an exception is raised from within a trace callback. The test proceeds as follows:\n\n1. It retrieves the current greenlet (main) and initializes an empty list (actions) to record trace events.\n2. It defines a trace function that appends its arguments to the actions list and then deliberately raises the custom exception SomeError. This simulates an error occurring during tracing.\n3. It defines a dummy function that, when run in a greenlet, switches back to the main greenlet.\n4. It creates a new greenlet (g) running the dummy function and switches to it once to set up the context.\n5. The test sets the trace function for greenlet events to the custom trace function and saves the previous trace function (oldtrace) for later restoration.\n6. It then asserts that invoking g.switch (which triggers the trace function) raises SomeError, as expected.\n7. After the exception, it checks that greenlet.gettrace() returns None, confirming that the tracing mechanism has been disabled due to the exception.\n8. In the finally block, it restores the original trace function to avoid side effects on other tests.\n9. Finally, it asserts that the actions list contains exactly one event: a 'switch' event with the main and g greenlets as arguments, confirming that the trace function was called as expected before the exception occurred.\n\nThe test uses the SomeError exception class specifically to ensure that the exception raised in the trace function is recognized and handled correctly. The use of greenlet.settrace and greenlet.gettrace demonstrates how the tracing API responds to errors within trace callbacks.\n\n**Note**:  \n- This test ensures that if a trace callback raises an exception, the greenlet tracing mechanism is automatically disabled to prevent further errors or inconsistent state.\n- The trace function should be restored after the test to avoid affecting other tests or code that relies on greenlet tracing.\n- The test is designed for use in a controlled test environment and relies on the custom SomeError exception for precise error detection."
                },
                {
                    "method_name": "trace",
                    "source_code": "def trace(*args):\n    actions.append(args)\n    raise SomeError()",
                    "first_doc": "**trace**: The function of trace is to record its invocation arguments and immediately raise a custom exception for testing purposes.\n\n**parameters**: The parameters of this Function.\n· *args: A variable-length argument list capturing all positional arguments passed to the function.\n\n**Code Description**:  \nThe trace function is designed as a simple callback that serves two primary purposes within a testing context. First, it appends all received arguments as a tuple to the actions list, effectively recording each invocation for later inspection. This allows the test suite to verify that the trace function was called with the expected arguments during execution.\n\nImmediately after recording the arguments, the function raises a SomeError exception. SomeError is a custom exception class specifically created for the test suite to signal and test error handling behavior. By raising this exception within the trace function, the test can assert how the tracing mechanism responds when an error occurs during tracing—specifically, it can verify that tracing is disabled as expected when an exception is raised from within the trace callback.\n\nThis function does not return any value, as its execution is always interrupted by the raised exception.\n\n**Note**:  \nThe trace function is intended solely for use within the test suite. It is not designed for production use, as it always raises an exception and does not perform any actual tracing logic beyond argument recording. When using this function, ensure that the actions list is properly initialized and accessible in the test context, and that exception handling is in place to catch the SomeError exception."
                },
                {
                    "method_name": "dummy",
                    "source_code": "def dummy():\n    main.switch()",
                    "first_doc": "**dummy**: The function of dummy is to perform a context switch by invoking the switch method on the main object.\n\n**parameters**: The parameters of this Function.\n· None: This function does not accept any parameters.\n\n**Code Description**:  \nThe dummy function is a simple callable that, when executed, calls the switch method on the main object. This action triggers a context switch, which is commonly used in cooperative multitasking or coroutine-based systems to yield control from the current execution context to another. The function does not perform any additional logic or return any value. Its sole purpose is to delegate execution to main.switch(), making it useful in scenarios where a context switch is required as part of a test or control flow.\n\n**Note**:  \n- The main object must be defined and accessible in the scope where dummy is called; otherwise, a NameError will occur.\n- The switch method of main should be implemented to handle the context switching logic appropriately.\n- This function is typically used in testing or coroutine management scenarios where explicit control over execution flow is necessary."
                }
            ]
        }
    ],
    "tests/test_greenlet.py": [
        {
            "type": "class",
            "name": "SomeError",
            "methods": [
                {
                    "method_name": "crasher",
                    "source_code": "def crasher(exc):\n    raise exc",
                    "first_doc": "**crasher**: The function of crasher is to immediately raise the exception provided as its argument.\n\n**parameters**: The parameters of this Function.\n· exc: The exception instance that will be raised when the function is called.\n\n**Code Description**:  \nThis function takes a single argument, exc, which is expected to be an exception instance. When crasher is called, it raises the provided exception, causing the normal flow of the program to be interrupted and the exception to propagate up the call stack. This function does not perform any additional logic, validation, or handling; it simply raises the exception it receives.\n\n**Note**:  \n- The exc parameter must be a valid exception instance; passing other types will result in a TypeError.\n- This function does not return any value, as it always raises an exception.\n- Use this function with caution, as it will immediately interrupt the current execution context with the provided exception."
                }
            ]
        },
        {
            "type": "class",
            "name": "GreenletTests",
            "methods": [
                {
                    "method_name": "test_simple",
                    "source_code": "def test_simple(self):\n    lst = []\n\n    def f():\n        lst.append(1)\n        greenlet.getcurrent().parent.switch()\n        lst.append(3)\n    g = greenlet(f)\n    lst.append(0)\n    g.switch()\n    lst.append(2)\n    g.switch()\n    lst.append(4)\n    self.assertEqual(lst, list(range(5)))",
                    "first_doc": "**test_simple**: The function of test_simple is to verify the basic behavior of greenlet context switching and the correct order of execution between parent and child greenlets.\n\n**parameters**: The parameters of this Function.\n· self: The instance of the test case class, used to access test assertions and context.\n\n**Code Description**:  \nThis function tests the fundamental operation of greenlets by tracking the sequence of execution steps between the main greenlet and a child greenlet. It initializes an empty list lst to record the order of execution. A nested function f is defined, which appends 1 to lst, then yields control back to the parent greenlet using greenlet.getcurrent().parent.switch(), and upon resuming, appends 3 to lst.\n\nA greenlet g is created with f as its target. The main greenlet appends 0 to lst, then switches to g, causing f to execute and append 1. When f yields back, control returns to the main greenlet, which appends 2. Switching to g again resumes f, which appends 3. After returning to the main greenlet, 4 is appended. Finally, the test asserts that lst contains [0, 1, 2, 3, 4], confirming the expected interleaving of execution.\n\nThis function is also called by the f function in the test_threads method, indicating that its correctness is foundational for other tests involving greenlet behavior in threaded contexts.\n\n**Note**:  \n- This test assumes the greenlet library is available and properly imported.\n- The function relies on the correct implementation of greenlet context switching.\n- The order of list modifications is critical for the test to pass; any change in the switching logic will affect the outcome.\n- The test is designed to be deterministic and should always produce the same result if greenlet works as expected."
                },
                {
                    "method_name": "f",
                    "source_code": "def f():\n    lst.append(1)\n    greenlet.getcurrent().parent.switch()\n    lst.append(3)",
                    "first_doc": "**f**: The function of f is to demonstrate a simple greenlet context switch and modify a shared list before and after the switch.\n\n**parameters**: The parameters of this Function.\n· None\n\n**Code Description**:  \nThis function operates on a shared list named lst. When called, it first appends the integer 1 to lst. It then performs a context switch to the parent greenlet using greenlet.getcurrent().parent.switch(). After the context is switched back to this greenlet, it appends the integer 3 to lst. This sequence allows for testing and demonstrating the behavior of greenlet context switching, as well as verifying the order of operations before and after the switch.\n\n**Note**:  \n- The function assumes that lst is a mutable list defined in an accessible scope.\n- The function is intended to be used within a greenlet context; calling it outside of a greenlet environment may result in errors.\n- The order of list modifications (appending 1, switching, then appending 3) is crucial for tests that verify correct greenlet switching behavior."
                },
                {
                    "method_name": "test_parent_equals_None",
                    "source_code": "def test_parent_equals_None(self):\n    g = greenlet(parent=None)",
                    "first_doc": "**test_parent_equals_None**: The function of test_parent_equals_None is to verify that a greenlet can be instantiated with its parent explicitly set to None.\n\n**parameters**: The parameters of this Function.\n· self: Refers to the instance of the test case class, as this is a method within a unittest-style test class.\n\n**Code Description**:  \nThis function creates a new greenlet object by calling greenlet(parent=None). The test checks whether it is valid to specify None as the parent when constructing a greenlet. In the context of greenlet, the parent parameter determines the greenlet to which control will return when the current greenlet finishes execution. Setting parent=None is a way to explicitly indicate that the greenlet should have no parent, which is typically allowed and handled by the greenlet implementation. The function does not perform any assertions or further actions; its purpose is to ensure that the instantiation does not raise an exception.\n\n**Note**:  \nThis test is a basic instantiation check and does not verify any behavior beyond the successful creation of the greenlet object. It assumes that the greenlet class is available in the current scope. If the greenlet implementation changes its handling of parent=None, this test may need to be updated accordingly."
                },
                {
                    "method_name": "test_run_equals_None",
                    "source_code": "def test_run_equals_None(self):\n    g = greenlet(run=None)",
                    "first_doc": "**test_run_equals_None**: The function of test_run_equals_None is to verify that a greenlet can be instantiated with its run attribute explicitly set to None.\n\n**parameters**: The parameters of this Function.\n· self: The instance of the GreenletTests test case class.\n\n**Code Description**:  \nThis function is a unit test method intended to check the behavior of the greenlet constructor when the run parameter is set to None. Within the method, a new greenlet object is created by calling greenlet(run=None). This test ensures that the greenlet library accepts None as a valid value for the run argument during instantiation, which may be relevant for scenarios where the run function is assigned later or intentionally left unset.\n\n**Note**:  \nThis test does not perform any assertions or further actions beyond instantiating the greenlet. It is designed to confirm that no exceptions are raised during this process, implicitly verifying that the constructor handles run=None gracefully. This is useful for validating the robustness of the greenlet API when handling edge cases."
                },
                {
                    "method_name": "test_two_children",
                    "source_code": "def test_two_children(self):\n    lst = []\n\n    def f():\n        lst.append(1)\n        greenlet.getcurrent().parent.switch()\n        lst.extend([1, 1])\n    g = greenlet(f)\n    h = greenlet(f)\n    g.switch()\n    self.assertEqual(len(lst), 1)\n    h.switch()\n    self.assertEqual(len(lst), 2)\n    h.switch()\n    self.assertEqual(len(lst), 4)\n    self.assertEqual(h.dead, True)\n    g.switch()\n    self.assertEqual(len(lst), 6)\n    self.assertEqual(g.dead, True)",
                    "first_doc": "**test_two_children**: The function of test_two_children is to verify the behavior of two independent greenlet instances executing the same function and to ensure their execution and completion states are handled correctly.\n\n**parameters**: The parameters of this Function.\n· self: The instance of the test case class, used to access assertion methods.\n\n**Code Description**:  \nThis function tests the interaction and independence of two greenlet objects, g and h, both running the same function f. The function f appends and extends a shared list lst at different stages of its execution, with context switches between the greenlet and its parent. The test proceeds as follows:\n\n1. An empty list lst is initialized to track execution steps.\n2. The function f is defined. When called, it:\n   - Appends 1 to lst.\n   - Switches control back to the parent greenlet.\n   - Upon resuming, extends lst with two more 1s.\n3. Two greenlet instances, g and h, are created, both targeting f.\n4. g.switch() is called, starting g and executing the first part of f, which appends 1 to lst and yields back. The test asserts that lst has one element.\n5. h.switch() is called, starting h and executing the first part of f for h, appending another 1 to lst. The test asserts that lst now has two elements.\n6. h.switch() is called again, resuming h and executing the remainder of f, which extends lst by [1, 1]. The test asserts that lst now has four elements and that h is dead (finished execution).\n7. g.switch() is called again, resuming g and executing the remainder of f for g, extending lst by [1, 1]. The test asserts that lst now has six elements and that g is dead.\n\nThis sequence ensures that each greenlet maintains its own execution state, and that switching between them does not interfere with their individual progress. The assertions confirm the correct order and number of operations performed on lst, as well as the proper termination of each greenlet.\n\n**Note**:  \n- The test assumes that the greenlet library is available and that greenlet.getcurrent().parent.switch() correctly yields control back to the parent greenlet.\n- The shared list lst is used to track the execution flow and must not be modified outside the test to ensure accurate results.\n- The test checks the dead attribute of each greenlet to confirm that they have completed execution after their respective switches."
                },
                {
                    "method_name": "f",
                    "source_code": "def f():\n    lst.append(1)\n    greenlet.getcurrent().parent.switch()\n    lst.extend([1, 1])",
                    "first_doc": "**f**: The function of f is to modify a list by appending and extending its contents, while yielding control to the parent greenlet in between these operations.\n\n**parameters**: The parameters of this Function.\n· None\n\n**Code Description**:  \nThis function operates on a list named lst, which is expected to be accessible in its enclosing scope. When called, it first appends the integer 1 to lst. It then yields execution back to its parent greenlet by calling greenlet.getcurrent().parent.switch(). After control is returned to this greenlet and execution resumes, the function extends lst by adding two more integers, both with the value 1. This results in lst being modified in two stages: first by a single append, then by an extension with two additional elements after a context switch.\n\n**Note**:  \n- The function assumes that lst is defined and mutable in the accessible scope.\n- It is intended to be used within a greenlet context; calling it outside of a greenlet environment may result in errors.\n- The function relies on cooperative multitasking provided by greenlets, and its behavior is dependent on the correct management of greenlet switching.\n- The modifications to lst occur in two separate phases, separated by a context switch."
                },
                {
                    "method_name": "test_two_recursive_children",
                    "source_code": "def test_two_recursive_children(self):\n    lst = []\n\n    def f():\n        lst.append(1)\n        greenlet.getcurrent().parent.switch()\n\n    def g():\n        lst.append(1)\n        g = greenlet(f)\n        g.switch()\n        lst.append(1)\n    g = greenlet(g)\n    g.switch()\n    self.assertEqual(len(lst), 3)\n    self.assertEqual(sys.getrefcount(g), 2)",
                    "first_doc": "**test_two_recursive_children**: The function of test_two_recursive_children is to verify the behavior of nested greenlets and their reference counts during recursive switching.\n\n**parameters**: The parameters of this Function.\n· self: The instance of the test case class, used to access assertion methods.\n\n**Code Description**:  \nThis function tests the interaction between two nested greenlets and ensures proper reference counting. It begins by initializing an empty list lst. Two inner functions, f and g, are defined:\n\n- The function f appends the integer 1 to lst and then switches control back to its parent greenlet.\n- The function g also appends 1 to lst, creates a new greenlet instance with f as its target, and switches to it. After returning from the switch, it appends another 1 to lst.\n\nA greenlet is created with g as its target and is switched to, initiating the nested greenlet execution. After the greenlet execution completes, the function asserts that three items have been appended to lst, confirming the correct sequence of execution and switching between greenlets. It also asserts that the reference count of the greenlet object g is 2, verifying that no unexpected references remain after execution.\n\n**Note**:  \n- This test assumes the use of the greenlet library and Python's sys module for reference counting.\n- The test checks both the logical flow of greenlet switching and the proper cleanup of greenlet references.\n- The reference count assertion may be sensitive to the Python implementation and environment, as sys.getrefcount returns the number of references including the temporary reference as an argument to the function."
                },
                {
                    "method_name": "f",
                    "source_code": "def f():\n    lst.append(1)\n    greenlet.getcurrent().parent.switch()",
                    "first_doc": "**f**: The function of f is to append the value 1 to the list lst and then yield control back to the parent greenlet.\n\n**parameters**: The parameters of this Function.\n· None\n\n**Code Description**:  \nThis function performs two main actions when called. First, it appends the integer 1 to the list named lst. This operation modifies the list in place, adding a new element at the end. Second, it retrieves the current greenlet using greenlet.getcurrent() and then switches execution back to its parent greenlet by calling the parent.switch() method. This effectively suspends the current greenlet and resumes execution in the parent greenlet, allowing for cooperative multitasking between greenlets.\n\n**Note**:  \n- The function assumes that lst is a mutable list object defined in an accessible scope.\n- It also requires that the greenlet module is imported and properly initialized.\n- This function is intended to be used within a greenlet context; calling it outside such a context may result in errors.\n- The switch to the parent greenlet will pause the current greenlet's execution until it is resumed."
                },
                {
                    "method_name": "g",
                    "source_code": "def g():\n    lst.append(1)\n    g = greenlet(f)\n    g.switch()\n    lst.append(1)",
                    "first_doc": "**g**: The function of g is to append values to a list before and after switching execution to a greenlet running function f.\n\n**parameters**: The parameters of this Function.\n· None\n\n**Code Description**:  \nThe function g performs the following operations in sequence:\n1. Appends the integer 1 to the list lst.\n2. Creates a new greenlet object g, which is initialized to run the function f.\n3. Switches execution to the greenlet g by calling g.switch(). This transfers control to the function f, which will run until it yields or finishes.\n4. After the greenlet execution returns, appends another integer 1 to the list lst.\n\nThis function demonstrates the use of greenlets for cooperative multitasking, where execution can be explicitly switched between different code contexts.\n\n**Note**:  \n- The list lst and the function f must be defined in the enclosing scope for g to work correctly.\n- The greenlet module must be imported and available in the environment.\n- The behavior of g depends on the implementation of function f and how it interacts with greenlet switching."
                },
                {
                    "method_name": "test_threads",
                    "source_code": "def test_threads(self):\n    success = []\n\n    def f():\n        self.test_simple()\n        success.append(True)\n    ths = [threading.Thread(target=f) for i in range(10)]\n    for th in ths:\n        th.start()\n    for th in ths:\n        th.join()\n    self.assertEqual(len(success), len(ths))",
                    "first_doc": "**test_threads**: The function of test_threads is to verify that the test_simple method can be safely executed in multiple threads concurrently.\n\n**parameters**: The parameters of this Function.\n· self: Refers to the instance of the test case class, allowing access to other test methods and assertions.\n\n**Code Description**:  \nThis function tests the thread-safety and concurrent execution of the test_simple method. It defines an inner function f, which calls self.test_simple() and appends True to a shared list named success upon completion. The function then creates a list of 10 threading.Thread objects, each targeting the inner function f. All threads are started, and the function waits for each thread to finish using join(). After all threads have completed, the function asserts that the length of the success list is equal to the number of threads created, confirming that each thread executed the inner function successfully.\n\n**Note**:  \n- The shared list success is used to track the successful execution of each thread.  \n- The test assumes that test_simple is thread-safe and does not introduce race conditions or shared state issues.  \n- This function is intended for use in a test suite and relies on the unittest framework's assertion methods.  \n- Proper synchronization is not used for the success list, but appending to a list is thread-safe in CPython due to the Global Interpreter Lock (GIL)."
                },
                {
                    "method_name": "f",
                    "source_code": "def f():\n    self.test_simple()\n    success.append(True)",
                    "first_doc": "**f**: The function of f is to execute the test_simple method and record its successful completion.\n\n**parameters**: The parameters of this Function.\n· None\n\n**Code Description**:  \nThis function serves as a simple wrapper to invoke the test_simple method within the context of a test case. When called, it first executes self.test_simple(), which is responsible for verifying the basic behavior of greenlet context switching and ensuring the correct order of execution between parent and child greenlets. After test_simple completes, the function appends True to the success list, signaling that the test_simple method ran without raising any exceptions and thus was successful.\n\nThe relationship with its callee, test_simple, is direct: f relies on test_simple to perform the actual validation of greenlet behavior. The role of f is to encapsulate this call and provide a mechanism (via the success list) to track the outcome, which is useful in scenarios where test execution and result collection need to be separated, such as in threaded or concurrent test environments.\n\n**Note**:  \n- This function assumes that self is a valid instance of the test case class and that success is a mutable list accessible in the enclosing scope.\n- The correctness of f depends on the proper implementation and behavior of test_simple.\n- This function is typically used in a threaded context to test greenlet behavior in multi-threaded scenarios, where the result of the test is communicated by appending to the success list."
                },
                {
                    "method_name": "test_exception",
                    "source_code": "def test_exception(self):\n    seen = []\n    g1 = greenlet(fmain)\n    g2 = greenlet(fmain)\n    g1.switch(seen)\n    g2.switch(seen)\n    g2.parent = g1\n    self.assertEqual(seen, [])\n    self.assertRaises(SomeError, g2.switch)\n    self.assertEqual(seen, [SomeError])\n    g2.switch()\n    self.assertEqual(seen, [SomeError])",
                    "first_doc": "**test_exception**: The function of test_exception is to verify that exceptions raised within greenlets are properly propagated, recorded, and isolated between different greenlet instances.\n\n**parameters**: The parameters of this Function.\n· self: The instance of the test case class, used to access assertion methods and test context.\n\n**Code Description**:  \nThis function serves as a unit test for exception handling in the context of greenlet-based concurrency. It begins by initializing an empty list, seen, which is used to record exception types encountered during greenlet execution. Two greenlet instances, g1 and g2, are created, both targeting the fmain function. The fmain function is designed to switch control back to its parent greenlet and, if an exception occurs, append the exception type to the seen list before re-raising it. If no exception occurs, fmain raises the custom SomeError exception.\n\nThe test proceeds as follows:\n1. g1.switch(seen) and g2.switch(seen) are called, starting both greenlets and passing the seen list to each. At this point, both greenlets yield control back to their parent without raising exceptions, so seen remains empty.\n2. The parent of g2 is set to g1, establishing a parent-child relationship between the two greenlets.\n3. The test asserts that seen is still an empty list, confirming that no exceptions have been recorded yet.\n4. The test then calls g2.switch() and asserts that this raises the SomeError exception. This triggers the exception handling logic in fmain, which appends SomeError to the seen list.\n5. The test asserts that seen now contains [SomeError], verifying that the exception was correctly recorded.\n6. g2.switch() is called again, and the test asserts that seen remains [SomeError], confirming that no additional exceptions have been recorded.\n\nThe test makes use of the custom SomeError exception to ensure that only the intended exception is caught and recorded. It also relies on the fmain function to handle the switching and exception recording logic. The use of two separate greenlet instances ensures that exceptions in one greenlet do not interfere with the other, and the manipulation of the parent attribute tests exception propagation in nested greenlet relationships.\n\n**Note**:  \nThis test is specifically designed for use within the greenlet test suite and assumes the presence of the custom SomeError exception and the fmain function. It is not intended for use outside of a controlled testing environment. The test verifies both the propagation and isolation of exceptions in greenlet-based concurrency, ensuring robust exception handling in greenlet implementations."
                },
                {
                    "method_name": "test_send_exception",
                    "source_code": "def test_send_exception(self):\n    seen = []\n    g1 = greenlet(fmain)\n    g1.switch(seen)\n    self.assertRaises(KeyError, send_exception, g1, KeyError)\n    self.assertEqual(seen, [KeyError])",
                    "first_doc": "**test_send_exception**: The function of test_send_exception is to verify that exceptions can be explicitly sent into a greenlet and are correctly propagated and recorded.\n\n**parameters**: The parameters of this Function.\n· self: The test case instance, providing access to assertion methods and test context.\n\n**Code Description**:  \nThis test method is part of a test suite for greenlet-based concurrency. It begins by creating an empty list, seen, which will be used to record the types of exceptions encountered during the test. A new greenlet, g1, is then created with fmain as its run function. The greenlet is started by switching to it and passing the seen list as an argument. At this point, fmain yields control back to the parent greenlet.\n\nThe test then uses the send_exception function to send a KeyError exception into g1. send_exception achieves this by creating a child greenlet that immediately raises the specified exception in the context of g1. The test asserts that a KeyError is raised as expected when send_exception is called.\n\nAfter the exception is sent and handled, the test checks that the seen list contains KeyError, confirming that fmain correctly caught the exception and recorded its type. This verifies both the propagation of the exception into the greenlet and the correct operation of the exception handling and recording logic in fmain.\n\nThe relationship with its callees is as follows:\n- fmain is used as the main function for the greenlet and is responsible for recording any exceptions it encounters in the seen list.\n- send_exception is used to explicitly propagate a KeyError into the greenlet, testing the exception handling path.\n\n**Note**:  \nThis test is specifically designed to validate the explicit propagation of exceptions between greenlets and the correct recording of exception types. It relies on the correct implementation of both fmain and send_exception, and assumes that the seen list is mutable and accessible throughout the test. The test is intended for use within a controlled test environment and is not suitable for production use."
                },
                {
                    "method_name": "test_dealloc",
                    "source_code": "def test_dealloc(self):\n    seen = []\n    g1 = greenlet(fmain)\n    g2 = greenlet(fmain)\n    g1.switch(seen)\n    g2.switch(seen)\n    self.assertEqual(seen, [])\n    del g1\n    gc.collect()\n    self.assertEqual(seen, [greenlet.GreenletExit])\n    del g2\n    gc.collect()\n    self.assertEqual(seen, [greenlet.GreenletExit, greenlet.GreenletExit])",
                    "first_doc": "**test_dealloc**: The function of test_dealloc is to verify that greenlet objects are properly deallocated and that their cleanup triggers the expected GreenletExit exception, which is recorded in a provided list.\n\n**parameters**: The parameters of this Function.\n· self: The test case instance, used to access assertion methods and maintain test context.\n\n**Code Description**:  \nThis function tests the deallocation and garbage collection behavior of greenlet objects, specifically ensuring that when a greenlet is deleted and garbage collected, the GreenletExit exception is raised and recorded as expected. The test proceeds as follows:\n\n1. An empty list named seen is initialized to record exceptions.\n2. Two greenlet objects, g1 and g2, are created, each targeting the fmain function. The fmain function is designed to switch control back to the parent greenlet and, upon certain events (such as greenlet termination), append the exception type to the seen list.\n3. Both greenlets are started by switching to them with the seen list as an argument. At this point, neither greenlet has encountered an exception, so seen remains empty.\n4. The test asserts that seen is still an empty list, confirming that no exceptions have been recorded yet.\n5. The first greenlet, g1, is deleted, and garbage collection is explicitly triggered using gc.collect(). This process should cause the greenlet to be finalized, resulting in a GreenletExit exception being recorded by fmain in the seen list.\n6. The test asserts that seen now contains a single GreenletExit entry, confirming that the deallocation of g1 triggered the expected behavior.\n7. The second greenlet, g2, is then deleted, and garbage collection is triggered again. This should result in another GreenletExit exception being recorded.\n8. The test asserts that seen now contains two GreenletExit entries, one for each greenlet that was deallocated.\n\nThe function relies on the behavior of fmain, which appends the type of any exception it catches (including GreenletExit) to the seen list. This mechanism allows the test to verify that greenlet cleanup is functioning as intended.\n\n**Note**:  \nThis test assumes that the garbage collector will immediately finalize the greenlet objects upon calling gc.collect(), which is generally reliable in controlled test environments. The test is specifically designed for use with the greenlet library and its exception handling semantics. It is important to ensure that the seen list is unique to each test run to avoid interference from previous tests. This function is intended for use within a test suite and is not suitable for production code."
                },
                {
                    "method_name": "test_dealloc_other_thread",
                    "source_code": "def test_dealloc_other_thread(self):\n    seen = []\n    someref = []\n    lock = threading.Lock()\n    lock.acquire()\n    lock2 = threading.Lock()\n    lock2.acquire()\n\n    def f():\n        g1 = greenlet(fmain)\n        g1.switch(seen)\n        someref.append(g1)\n        del g1\n        gc.collect()\n        lock.release()\n        lock2.acquire()\n        greenlet()   # trigger release\n        lock.release()\n        lock2.acquire()\n    t = threading.Thread(target=f)\n    t.start()\n    lock.acquire()\n    self.assertEqual(seen, [])\n    self.assertEqual(len(someref), 1)\n    del someref[:]\n    gc.collect()\n    # g1 is not released immediately because it's from another thread\n    self.assertEqual(seen, [])\n    lock2.release()\n    lock.acquire()\n    self.assertEqual(seen, [greenlet.GreenletExit])\n    lock2.release()\n    t.join()",
                    "first_doc": "**test_dealloc_other_thread**: The function of test_dealloc_other_thread is to verify the behavior of greenlet deallocation and finalization when the greenlet object is created in one thread and deleted in another.\n\n**parameters**: The parameters of this Function.\n· self: The instance of the test class GreenletTests.\n\n**Code Description**:  \nThis function is a unit test designed to ensure that greenlet objects are properly finalized when they are deallocated from a thread different from the one in which they were created. The test uses two threading.Lock objects, lock and lock2, to synchronize actions between the main thread and a worker thread.\n\nThe test proceeds as follows:\n- Two lists, seen and someref, are initialized to track results and references.\n- Two locks are acquired to control the flow between threads.\n- A nested function f is defined, which:\n  - Creates a greenlet object g1 with fmain as its target.\n  - Switches to g1, passing the seen list.\n  - Appends g1 to someref, then deletes g1 and forces garbage collection.\n  - Releases lock to signal the main thread, then waits for lock2.\n  - Creates a new greenlet to trigger any pending finalization, releases lock, and waits for lock2 again.\n- A new thread is started to run f.\n- The main thread waits for the worker thread to reach a certain point (lock.acquire()), then checks that seen is still empty and someref contains one reference.\n- The reference in someref is deleted and garbage collection is forced. At this point, the greenlet object is not finalized because it was created in another thread.\n- The main thread checks that seen is still empty, then releases lock2 to allow the worker thread to proceed.\n- After the worker thread triggers finalization, the main thread checks that seen now contains greenlet.GreenletExit, confirming that the greenlet was finalized as expected.\n- The test ensures proper synchronization and cleanup by joining the worker thread at the end.\n\n**Note**:  \n- This test is specifically designed to check the cross-thread finalization behavior of greenlet objects, which is important for correct resource management in multi-threaded applications.\n- Proper synchronization using locks is crucial to avoid race conditions and ensure the test's reliability.\n- The test assumes that fmain and greenlet are properly defined and imported in the test environment.\n- Garbage collection is explicitly triggered to ensure timely finalization of the greenlet object."
                },
                {
                    "method_name": "f",
                    "source_code": "def f():\n    g1 = greenlet(fmain)\n    g1.switch(seen)\n    someref.append(g1)\n    del g1\n    gc.collect()\n    lock.release()\n    lock2.acquire()\n    greenlet()   # trigger release\n    lock.release()\n    lock2.acquire()",
                    "first_doc": "**f**: The function of f is to coordinate the creation, switching, and cleanup of a greenlet in a controlled multithreaded test scenario, ensuring proper synchronization and triggering garbage collection.\n\n**parameters**: This function does not take any parameters.\n\n**Code Description**:  \nThe function f is designed as part of a test to verify the correct deallocation and cleanup behavior of greenlets, particularly when greenlets are manipulated across threads. The function performs the following sequence of operations:\n\n1. It creates a new greenlet g1, assigning it the target function fmain. The fmain function is responsible for testing exception propagation and recording within greenlet-based concurrency scenarios.\n2. It switches execution to g1, passing the seen list as an argument. This initiates the execution of fmain within the greenlet context, allowing fmain to perform its context switch and exception handling logic.\n3. The greenlet g1 is appended to the someref list, which is typically used to maintain a reference to the greenlet for later inspection or to prevent premature garbage collection.\n4. The local reference to g1 is deleted using del g1, making the greenlet eligible for garbage collection.\n5. The garbage collector is explicitly invoked with gc.collect() to ensure that any unreachable objects, including the greenlet, are cleaned up immediately.\n6. The function then releases a synchronization lock (lock.release()), signaling to another thread or test component that this phase of the test is complete.\n7. It waits for another lock (lock2.acquire()) to be acquired, ensuring proper synchronization and sequencing with other threads or test steps.\n8. A new, anonymous greenlet is created and immediately discarded. This operation is used to trigger the release of any resources or finalization logic associated with greenlet cleanup.\n9. The function again releases the lock and waits for lock2 to be acquired, maintaining synchronization with other test components.\n\nThroughout its execution, f ensures that greenlet creation, switching, and cleanup are performed in a controlled and synchronized manner, making it possible to test for correct deallocation behavior, especially in multithreaded contexts. The function interacts closely with fmain, which handles the actual greenlet logic and exception recording, and with synchronization primitives (lock and lock2) to coordinate with other threads or test routines.\n\n**Note**:  \nThis function is intended for use within a test suite and relies on external synchronization primitives (lock, lock2), a reference list (someref), and a logging list (seen) that must be defined in the test environment. It is not suitable for use outside of controlled test scenarios. The explicit use of garbage collection and synchronization is critical for ensuring deterministic test behavior when verifying greenlet deallocation and resource management."
                },
                {
                    "method_name": "test_frame",
                    "source_code": "def test_frame(self):\n    def f1():\n        f = sys._getframe(0)\n        self.assertEqual(f.f_back, None)\n        greenlet.getcurrent().parent.switch(f)\n        return \"meaning of life\"\n    g = greenlet(f1)\n    frame = g.switch()\n    self.assertTrue(frame is g.gr_frame)\n    self.assertTrue(g)\n    next = g.switch()\n    self.assertFalse(g)\n    self.assertEqual(next, 'meaning of life')\n    self.assertEqual(g.gr_frame, None)",
                    "first_doc": "**test_frame**: The function of test_frame is to verify the behavior of greenlet frames and their lifecycle during context switching.\n\n**parameters**: The parameters of this Function.\n· self: The test case instance, typically provided by the unittest framework.\n\n**Code Description**:  \nThis function is a unit test designed to check the correct handling of Python stack frames when using greenlets. It defines an inner function f1 that retrieves its own stack frame using sys._getframe(0), asserts that its f_back attribute is None (indicating it is the bottom of the stack), and then switches control back to the parent greenlet, passing the frame object. The test then performs several assertions:\n\n- It creates a greenlet g running f1.\n- It switches to g, which yields the frame object from f1.\n- It asserts that the returned frame is the same as g.gr_frame, confirming that the greenlet's frame is correctly set.\n- It asserts that g is still active after the first switch.\n- It switches to g again, which resumes f1 and completes its execution, returning \"meaning of life\".\n- It asserts that g is no longer active after completion.\n- It checks that the value returned is \"meaning of life\".\n- It asserts that g.gr_frame is None after the greenlet has finished, confirming that the frame is released.\n\nThis test ensures that greenlet frames are properly managed, that frame references are accurate during execution, and that they are cleared after the greenlet terminates.\n\n**Note**:  \n- This test requires the sys and greenlet modules.\n- It is intended to be run within a unittest framework.\n- The test checks internal frame management, which is important for memory management and debugging.\n\n**Output Example**:  \nThe function does not return a value but will pass silently if all assertions succeed. If any assertion fails, an AssertionError will be raised, indicating a problem with greenlet frame handling."
                },
                {
                    "method_name": "f1",
                    "source_code": "def f1():\n    f = sys._getframe(0)\n    self.assertEqual(f.f_back, None)\n    greenlet.getcurrent().parent.switch(f)\n    return \"meaning of life\"",
                    "first_doc": "**f1**: The function of f1 is to obtain the current stack frame, verify its parent frame, and perform a context switch to the parent greenlet, passing the frame object.\n\n**parameters**: The parameters of this Function.\n· None\n\n**Code Description**:  \nThis function first retrieves the current stack frame using sys._getframe(0), which returns the frame object at the top of the call stack. It then asserts that the parent frame (f.f_back) is None, confirming that this function is at the bottom of the call stack or is not called from another Python function. After this assertion, it uses greenlet.getcurrent().parent.switch(f) to switch execution to the parent greenlet, passing the current frame object as an argument. This effectively suspends the current greenlet and resumes execution in its parent, with the frame object available to the parent. After the context switch, if execution resumes in this greenlet, the function returns the string \"meaning of life\".\n\n**Note**:  \n- This function is intended to be used within a greenlet context and relies on the greenlet library for context switching.\n- The assertion ensures that f1 is not called from another Python function, which may be important for the test's correctness.\n- The function does not accept any arguments.\n- The return value \"meaning of life\" will only be produced if execution resumes in this greenlet after the context switch.\n\n**Output Example**:  \n\"meaning of life\""
                },
                {
                    "method_name": "test_thread_bug",
                    "source_code": "def test_thread_bug(self):\n    def runner(x):\n        g = greenlet(lambda: time.sleep(x))\n        g.switch()\n    t1 = threading.Thread(target=runner, args=(0.2,))\n    t2 = threading.Thread(target=runner, args=(0.3,))\n    t1.start()\n    t2.start()\n    t1.join()\n    t2.join()",
                    "first_doc": "**test_thread_bug**: The function of test_thread_bug is to verify the behavior of greenlet switching within multiple threads and ensure there are no threading-related issues.\n\n**parameters**: The parameters of this Function.\n· self: Refers to the instance of the test case class, allowing access to other methods and attributes if needed.\n\n**Code Description**:  \nThis function defines a test scenario where two separate threads are created and started. Each thread executes the runner function, which creates a greenlet that runs a lambda function sleeping for a specified duration (0.2 seconds for the first thread, 0.3 seconds for the second). The greenlet is switched to immediately, causing the sleep to occur in the context of the greenlet. After both threads are started, the function waits for both to complete using join(). This test is designed to check for any issues or bugs that may arise when using greenlets in a multi-threaded environment, particularly focusing on context switching and thread safety.\n\n**Note**:  \n- This test assumes that the greenlet and threading modules are properly imported and available.\n- The function does not return any value or assert any condition; it is likely intended to expose threading bugs such as deadlocks or exceptions when greenlets are used with threads.\n- Ensure that the environment supports greenlet operations within threads, as improper usage may lead to unpredictable behavior or errors."
                },
                {
                    "method_name": "runner",
                    "source_code": "def runner(x):\n    g = greenlet(lambda: time.sleep(x))\n    g.switch()",
                    "first_doc": "**runner**: The function of runner is to create and start a greenlet that sleeps for a specified duration.\n\n**parameters**: The parameters of this Function.\n· x: The number of seconds for which the greenlet will sleep.\n\n**Code Description**:  \nThis function defines a single parameter, x, which represents the sleep duration in seconds. Inside the function, a new greenlet is created using the greenlet constructor. The target of this greenlet is a lambda function that calls time.sleep(x), causing the greenlet to pause execution for x seconds when run. The g.switch() call immediately transfers execution to the greenlet, starting the sleep operation. The main thread will yield control to the greenlet until the sleep is complete or the greenlet yields back.\n\n**Note**:  \n- The function assumes that both the greenlet and time modules are already imported and available in the scope.\n- This function does not return any value.\n- The sleep operation is performed within the greenlet, not the main thread, which can be useful for concurrency testing or cooperative multitasking scenarios.\n- If called from a thread that does not support greenlets, or if greenlet is not properly installed, this function will raise an exception."
                },
                {
                    "method_name": "test_switch_kwargs",
                    "source_code": "def test_switch_kwargs(self):\n    def foo(a, b):\n        self.assertEqual(a, 4)\n        self.assertEqual(b, 2)\n    greenlet(foo).switch(a=4, b=2)",
                    "first_doc": "**test_switch_kwargs**: The function of test_switch_kwargs is to verify that keyword arguments can be correctly passed to a greenlet when switching execution.\n\n**parameters**: The parameters of this Function.\n· self: The instance of the test case class, providing access to assertion methods.\n\n**Code Description**:  \nThis function defines an inner function foo that takes two parameters, a and b. Inside foo, it asserts that a equals 4 and b equals 2 using the test case's assertion methods. The function then creates a new greenlet with foo as its target and immediately switches to it, passing the arguments a=4 and b=2 as keyword arguments. This test ensures that the greenlet implementation supports passing keyword arguments to the target function upon switching, and that these arguments are received correctly.\n\n**Note**:  \nThis test relies on the greenlet library's ability to handle keyword arguments during context switches. If the greenlet implementation does not support keyword arguments, this test will fail. The assertions inside foo will raise errors if the arguments are not passed correctly."
                },
                {
                    "method_name": "foo",
                    "source_code": "def foo(a, b):\n    self.assertEqual(a, 4)\n    self.assertEqual(b, 2)",
                    "first_doc": "**foo**: The function of foo is to verify that its two input arguments have specific expected values.\n\n**parameters**: The parameters of this Function.\n· a: The first argument, expected to be the integer 4.\n· b: The second argument, expected to be the integer 2.\n\n**Code Description**:  \nThis function performs two assertions using self.assertEqual. It checks that the value of parameter a is equal to 4 and that the value of parameter b is equal to 2. If either assertion fails, an AssertionError will be raised, indicating that the provided arguments do not match the expected values. This function is typically used within a test case to ensure that the arguments passed to it are correct.\n\n**Note**:  \n- The function relies on self.assertEqual, which implies it is intended to be used within a class that inherits from a unittest.TestCase or similar testing framework.\n- Both parameters a and b must be provided when calling this function, and they must have the exact values 4 and 2, respectively, for the assertions to pass.\n- This function does not return any value; its sole purpose is to perform assertions for testing."
                },
                {
                    "method_name": "test_switch_kwargs_to_parent",
                    "source_code": "def test_switch_kwargs_to_parent(self):\n    def foo(x):\n        greenlet.getcurrent().parent.switch(x=x)\n        greenlet.getcurrent().parent.switch(2, x=3)\n        return x, x ** 2\n    g = greenlet(foo)\n    self.assertEqual({'x': 3}, g.switch(3))\n    self.assertEqual(((2,), {'x': 3}), g.switch())\n    self.assertEqual((3, 9), g.switch())",
                    "first_doc": "**test_switch_kwargs_to_parent**: The function of test_switch_kwargs_to_parent is to verify that switching between greenlets correctly passes positional and keyword arguments to the parent greenlet.\n\n**parameters**: The parameters of this Function.\n· self: The instance of the test case class, used to access assertion methods.\n\n**Code Description**:  \nThis test method defines an inner function foo that takes a single argument x. Inside foo, the current greenlet switches control back to its parent twice:  \n- The first switch passes x as a keyword argument to the parent.\n- The second switch passes 2 as a positional argument and x=3 as a keyword argument to the parent.\n\nAfter these switches, foo returns a tuple containing x and x squared.\n\nA greenlet g is created with foo as its run function. The test then performs the following assertions:\n- It calls g.switch(3), which starts foo with x=3. The first switch in foo sends control back to the parent, and the test asserts that the parent receives {'x': 3}.\n- It calls g.switch() again, which resumes foo. The second switch in foo sends control back to the parent, and the test asserts that the parent receives ((2,), {'x': 3}), indicating that the positional and keyword arguments were passed correctly.\n- It calls g.switch() a final time, which resumes foo and allows it to return (3, 9). The test asserts that this is the returned value.\n\nThis test ensures that both positional and keyword arguments are correctly handled when switching between greenlets and their parents.\n\n**Note**:  \n- This test assumes the use of the greenlet library and its interface for switching between greenlets.\n- The test relies on the correct propagation of arguments through greenlet switches.\n- The test uses self.assertEqual to verify expected behavior, so it should be run within a unittest-compatible test runner.\n\n**Output Example**:  \n- After the first switch: {'x': 3}\n- After the second switch: ((2,), {'x': 3})\n- After the third switch: (3, 9)"
                },
                {
                    "method_name": "foo",
                    "source_code": "def foo(x):\n    greenlet.getcurrent().parent.switch(x=x)\n    greenlet.getcurrent().parent.switch(2, x=3)\n    return x, x ** 2",
                    "first_doc": "**foo**: The function of foo is to switch execution to the parent greenlet, passing keyword arguments, and then return a tuple containing the input value and its square.\n\n**parameters**: The parameters of this Function.\n· x: The input value to be passed to the parent greenlet and used in the return value.\n\n**Code Description**:  \nThis function utilizes the greenlet library to perform context switching between greenlets. When called, foo first switches execution to its parent greenlet, passing the value of x as a keyword argument. After the parent greenlet resumes foo, it switches again to the parent, this time passing two arguments: the positional argument 2 and the keyword argument x=3. After both switches, the function returns a tuple containing the original input x and the square of x (x ** 2). The function demonstrates how to use greenlet's switch method with both positional and keyword arguments, and how to manage control flow between child and parent greenlets.\n\n**Note**:  \n- This function must be executed within a greenlet context; otherwise, greenlet.getcurrent().parent may not behave as expected.\n- The parent greenlet must be prepared to handle the arguments passed during the switch calls.\n- The function does not modify x; it always returns the original input and its square, regardless of any values passed during the switches.\n\n**Output Example**:  \nIf called as foo(4), after the necessary greenlet context switches, the return value will be (4, 16)."
                },
                {
                    "method_name": "test_switch_to_another_thread",
                    "source_code": "def test_switch_to_another_thread(self):\n    data = {}\n    error = None\n    created_event = threading.Event()\n    done_event = threading.Event()\n\n    def foo():\n        data['g'] = greenlet(lambda: None)\n        created_event.set()\n        done_event.wait()\n    thread = threading.Thread(target=foo)\n    thread.start()\n    created_event.wait()\n    try:\n        data['g'].switch()\n    except greenlet.error:\n        error = sys.exc_info()[1]\n    self.assertTrue(error != None, \"greenlet.error was not raised!\")\n    done_event.set()\n    thread.join()",
                    "first_doc": "**test_switch_to_another_thread**: The function of test_switch_to_another_thread is to verify that attempting to switch to a greenlet created in a different thread raises a greenlet.error exception.\n\n**parameters**: The parameters of this Function.\n· self: The instance of the test case class, used to access assertion methods and shared state.\n\n**Code Description**:  \nThis function is a unit test designed to ensure thread safety in the usage of greenlet objects. It begins by initializing a shared dictionary data, an error variable, and two threading.Event objects: created_event and done_event. The inner function foo is defined to create a new greenlet instance (with a no-op lambda as its run function) and store it in the data dictionary. After creating the greenlet, foo signals the main thread by setting created_event and then waits for done_event to be set before finishing.\n\nA new thread is started to execute foo. The main thread waits for the greenlet to be created by waiting on created_event. Once the greenlet is available, the main thread attempts to switch to the greenlet object created in the other thread. This operation is expected to raise a greenlet.error, as greenlets are not designed to be switched across threads. If the exception is raised, it is captured in the error variable. The test then asserts that error is not None, confirming that the expected exception was raised. Finally, done_event is set to allow the worker thread to finish, and the main thread waits for it to join.\n\n**Note**:  \n- This test ensures that greenlet objects cannot be switched from a thread different from the one in which they were created, enforcing thread safety.\n- The test relies on proper synchronization between threads using threading.Event to avoid race conditions.\n- It is important to ensure that the greenlet.error is raised as expected; otherwise, the test will fail, indicating a potential issue with greenlet's thread safety enforcement."
                },
                {
                    "method_name": "foo",
                    "source_code": "def foo():\n    data['g'] = greenlet(lambda: None)\n    created_event.set()\n    done_event.wait()",
                    "first_doc": "**foo**: The function of foo is to create a new greenlet, signal its creation, and then wait for a completion event.\n\n**parameters**: The parameters of this Function.\n· None\n\n**Code Description**:  \nThe foo function performs three main actions:\n1. It creates a new greenlet object that wraps a no-operation lambda function (lambda: None) and assigns this greenlet to the key 'g' in the shared data dictionary.\n2. It signals that the greenlet has been created by setting the created_event, which is likely an instance of threading.Event or a similar synchronization primitive.\n3. It then waits for the done_event to be set, effectively pausing execution until another thread or process signals that it is safe to proceed.\n\nThis function is typically used in a multi-threaded context where coordination between threads is required, especially for testing greenlet behavior across threads.\n\n**Note**:  \n- The function assumes that data, greenlet, created_event, and done_event are accessible in its scope and properly initialized before foo is called.\n- Proper synchronization is necessary to avoid deadlocks or race conditions when using created_event and done_event.\n- The greenlet created does not perform any action, as its target function is a no-op."
                },
                {
                    "method_name": "test_exc_state",
                    "source_code": "def test_exc_state(self):\n    def f():\n        try:\n            raise ValueError('fun')\n        except:\n            exc_info = sys.exc_info()\n            greenlet(h).switch()\n            self.assertEqual(exc_info, sys.exc_info())\n\n    def h():\n        self.assertEqual(sys.exc_info(), (None, None, None))\n\n    greenlet(f).switch()",
                    "first_doc": "**test_exc_state**: The function of test_exc_state is to verify that the Python exception state (as returned by sys.exc_info()) is correctly managed and isolated across greenlet context switches.\n\n**parameters**: The parameters of this Function.\n· self: The instance of the test class, used to access assertion methods.\n\n**Code Description**:  \nThis function defines a test case that checks the behavior of exception state handling when switching between greenlets. It contains two inner functions, f and h. The function f raises and catches a ValueError, capturing the current exception state using sys.exc_info(). It then switches execution to another greenlet running function h. Inside h, it asserts that sys.exc_info() returns (None, None, None), confirming that no exception is active in this greenlet context. After returning from h, f asserts that the exception state is restored to its original value, ensuring that the exception context is preserved across greenlet switches. The test is initiated by switching to a greenlet running f.\n\n**Note**:  \n- This test assumes that sys.exc_info() is properly isolated between greenlets, which is essential for correct exception handling in concurrent greenlet-based code.\n- The test uses self.assertEqual for assertions, indicating that it is intended to be run within a unittest.TestCase subclass.\n- Proper management of exception state is critical to avoid leaking exceptions between greenlet contexts, which could lead to incorrect program behavior."
                },
                {
                    "method_name": "f",
                    "source_code": "def f():\n    try:\n        raise ValueError('fun')\n    except:\n        exc_info = sys.exc_info()\n        greenlet(h).switch()\n        self.assertEqual(exc_info, sys.exc_info())",
                    "first_doc": "**f**: The function of f is to test that the exception state is properly isolated across greenlet context switches.\n\n**parameters**: The parameters of this Function.\n· None\n\n**Code Description**:  \nThis function is designed to verify that exception state does not leak between greenlet contexts. It begins by deliberately raising a ValueError exception and immediately catching it within a try-except block. Inside the except block, it captures the current exception state using sys.exc_info(), which returns a tuple containing information about the exception that was just caught.\n\nAfter capturing the exception state, the function initiates a context switch to another greenlet, which runs the function h. The function h asserts that there is no active exception in its own context by checking that sys.exc_info() returns (None, None, None). This confirms that the exception state from the parent greenlet (where f was running) does not propagate into the new greenlet.\n\nOnce the execution returns from the greenlet switch, the function f asserts that its own exception state (as captured before the switch) remains unchanged. This ensures that the original greenlet retains its exception context independently of the greenlet it switched to.\n\n**Note**:  \nThis function is specifically intended for use in tests that validate the isolation of exception states between greenlet contexts. It should be used in environments where greenlet-based context switching is supported and where it is important to confirm that exception handling remains local to each greenlet. If the exception state is not properly isolated, the assertions in this function will fail, indicating a problem with greenlet exception handling."
                },
                {
                    "method_name": "h",
                    "source_code": "def h():\n    self.assertEqual(sys.exc_info(), (None, None, None))",
                    "first_doc": "**h**: The function of h is to assert that there is no active exception in the current execution context.\n\n**parameters**: The parameters of this Function.\n· None\n\n**Code Description**:  \nThis function checks the current exception state by calling sys.exc_info() and asserts that it returns a tuple of (None, None, None), which indicates that no exception is currently being handled in this context. The function is used in conjunction with greenlet-based context switching. Specifically, it is called from within another function, f, which raises and catches an exception, then switches execution to h via a greenlet. The purpose of h is to verify that, after switching to a new greenlet, the exception state does not leak from the parent greenlet. This ensures that exception handling remains isolated between greenlet contexts.\n\n**Note**:  \nThis function should only be used in a context where it is expected that no exception is being handled. It is particularly relevant in tests that verify the isolation of exception state across greenlet context switches. If called when an exception is active, the assertion will fail."
                },
                {
                    "method_name": "test_instance_dict",
                    "source_code": "def test_instance_dict(self):\n    def f():\n        greenlet.getcurrent().test = 42\n    def deldict(g):\n        del g.__dict__\n    def setdict(g, value):\n        g.__dict__ = value\n    g = greenlet(f)\n    self.assertEqual(g.__dict__, {})\n    g.switch()\n    self.assertEqual(g.test, 42)\n    self.assertEqual(g.__dict__, {'test': 42})\n    g.__dict__ = g.__dict__\n    self.assertEqual(g.__dict__, {'test': 42})\n    self.assertRaises(TypeError, deldict, g)\n    self.assertRaises(TypeError, setdict, g, 42)",
                    "first_doc": "**test_instance_dict**: The function of test_instance_dict is to verify the behavior and restrictions of the __dict__ attribute on greenlet instances.\n\n**parameters**: The parameters of this Function.\n· self: The test case instance, typically provided by the unittest framework.\n\n**Code Description**:  \nThis function tests several aspects of the __dict__ attribute on greenlet objects:\n\n- It defines a function f that sets an attribute test with the value 42 on the current greenlet.\n- It defines two helper functions:\n  - deldict(g): Attempts to delete the __dict__ attribute of a greenlet instance g.\n  - setdict(g, value): Attempts to assign a new value to the __dict__ attribute of a greenlet instance g.\n- A greenlet object g is created with f as its run function.\n- It asserts that the __dict__ of a newly created greenlet is an empty dictionary.\n- After switching to the greenlet (executing f), it asserts that the test attribute has been set to 42 and that the __dict__ now contains {'test': 42}.\n- It reassigns g.__dict__ to itself and checks that the contents remain unchanged, ensuring that self-assignment does not alter the dictionary.\n- It asserts that attempting to delete the __dict__ attribute raises a TypeError.\n- It asserts that attempting to assign a non-dictionary value (42) to __dict__ also raises a TypeError.\n\n**Note**:  \n- The __dict__ attribute of greenlet instances behaves like a standard Python object’s __dict__, allowing dynamic attribute assignment.\n- Deleting or assigning a non-dictionary value to __dict__ is not permitted and will raise a TypeError.\n- This test ensures that greenlet’s __dict__ attribute maintains expected Python object semantics and enforces type safety."
                },
                {
                    "method_name": "f",
                    "source_code": "def f():\n    greenlet.getcurrent().test = 42",
                    "first_doc": "**f**: The function of f is to assign the value 42 to the test attribute of the current greenlet object.\n\n**parameters**: The parameters of this Function.\n· None\n\n**Code Description**:  \nThis function accesses the currently running greenlet by calling greenlet.getcurrent(). It then sets an attribute named test on this greenlet object and assigns it the integer value 42. This demonstrates that greenlet instances can have arbitrary attributes attached to them, similar to standard Python objects. The function does not take any arguments and does not return any value.\n\n**Note**:  \n- This function requires that the greenlet module is available and imported in the environment where it is used.\n- The attribute test will only be set on the current greenlet instance, and will not affect other greenlet objects.\n- If called outside of a greenlet context, greenlet.getcurrent() will refer to the main greenlet.\n- This function is typically used to test or demonstrate the ability to attach custom attributes to greenlet instances."
                },
                {
                    "method_name": "deldict",
                    "source_code": "def deldict(g):\n    del g.__dict__",
                    "first_doc": "**deldict**: The function of deldict is to delete the __dict__ attribute of the given object g.\n\n**parameters**: The parameters of this Function.\n· g: The object whose __dict__ attribute will be deleted.\n\n**Code Description**:  \nThis function takes a single argument, g, and deletes its __dict__ attribute using the del statement. The __dict__ attribute is a special attribute in Python that stores an object's writable attributes. By removing __dict__, the function effectively removes the ability to access or modify the instance attributes of g through the standard dictionary interface. This operation is only valid for objects that have a __dict__ attribute, typically user-defined class instances. Attempting to delete __dict__ from objects that do not support it will result in an AttributeError.\n\n**Note**:  \n- Use this function only with objects that have a __dict__ attribute.\n- Deleting __dict__ is an advanced operation and may break the normal behavior of the object, especially if further attribute access or assignment is attempted.\n- After __dict__ is deleted, any attempt to access or set instance attributes on g may raise errors or cause unexpected behavior.\n- This function should be used with caution, primarily in testing or special scenarios where manipulation of the object's attribute storage is required."
                },
                {
                    "method_name": "setdict",
                    "source_code": "def setdict(g, value):\n    g.__dict__ = value",
                    "first_doc": "**setdict**: The function of setdict is to assign a new dictionary to the __dict__ attribute of a given object g.\n\n**parameters**: The parameters of this Function.\n· g: The target object whose __dict__ attribute will be set.\n· value: The new dictionary that will replace the current __dict__ of the object g.\n\n**Code Description**:  \nThis function directly sets the __dict__ attribute of the object g to the provided value. The __dict__ attribute in Python is a built-in attribute that stores an object’s writable attributes. By assigning value to g.__dict__, all existing attributes of g are replaced with those in the new dictionary value. This operation effectively overwrites the current state of g’s attributes with the contents of value, which must be a valid dictionary.\n\n**Note**:  \n- The value parameter must be a dictionary; otherwise, a TypeError will be raised.\n- Not all objects in Python have a writable __dict__ attribute. Attempting to set __dict__ on objects without this attribute (such as built-in types or objects with __slots__) will result in an AttributeError.\n- Overwriting __dict__ will remove all existing attributes of g that were previously stored in its __dict__, potentially affecting the object’s behavior. Use this function with caution to avoid unintended side effects."
                },
                {
                    "method_name": "test_threaded_reparent",
                    "source_code": "def test_threaded_reparent(self):\n    data = {}\n    created_event = threading.Event()\n    done_event = threading.Event()\n\n    def foo():\n        data['g'] = greenlet(lambda: None)\n        created_event.set()\n        done_event.wait()\n\n    def blank():\n        greenlet.getcurrent().parent.switch()\n\n    def setparent(g, value):\n        g.parent = value\n\n    thread = threading.Thread(target=foo)\n    thread.start()\n    created_event.wait()\n    g = greenlet(blank)\n    g.switch()\n    self.assertRaises(ValueError, setparent, g, data['g'])\n    done_event.set()\n    thread.join()",
                    "first_doc": "**test_threaded_reparent**: The function of test_threaded_reparent is to verify that attempting to set the parent of a greenlet to a greenlet created in a different thread raises a ValueError.\n\n**parameters**: The parameters of this Function.\n· self: The instance of the test case class, used to access assertion methods.\n\n**Code Description**:  \nThis function is a unit test designed to check the thread-safety and parent assignment rules of greenlets. It uses two threading.Event objects, created_event and done_event, to synchronize actions between the main thread and a worker thread.\n\n1. A dictionary named data is initialized to store references to greenlets created in the worker thread.\n2. The foo function, intended to run in a separate thread, creates a new greenlet (with a no-op lambda as its run function) and stores it in data['g']. It then signals the main thread by setting created_event and waits for done_event before finishing.\n3. The blank function is defined to immediately switch back to its parent greenlet.\n4. The setparent function is a helper that assigns a new parent to a given greenlet.\n5. A new thread is started to run foo. The main thread waits until the worker thread signals that the greenlet has been created.\n6. In the main thread, another greenlet is created with blank as its run function. This greenlet is switched to, which immediately returns control to its parent.\n7. The test then attempts to set the parent of this main-thread greenlet to the greenlet created in the worker thread using setparent. It asserts that this operation raises a ValueError, as greenlets from different threads cannot be reparented.\n8. Finally, done_event is set to allow the worker thread to finish, and the main thread waits for the worker thread to join.\n\n**Note**:  \n- This test ensures that greenlets cannot be reparented across thread boundaries, which is a restriction in the greenlet implementation to maintain thread safety.\n- The function uses synchronization primitives to avoid race conditions between threads.\n- The test relies on the correct implementation of greenlet's parent assignment and exception raising behavior when thread boundaries are crossed."
                },
                {
                    "method_name": "foo",
                    "source_code": "def foo():\n    data['g'] = greenlet(lambda: None)\n    created_event.set()\n    done_event.wait()",
                    "first_doc": "**foo**: The function of foo is to create a new greenlet, store it in a shared data dictionary, signal that the greenlet has been created, and then wait for a completion event.\n\n**parameters**: The parameters of this Function.\n· None\n\n**Code Description**:  \nThis function performs a sequence of operations involving greenlet creation and thread synchronization. First, it creates a new greenlet object with a no-operation lambda function as its target. This greenlet is then stored in the data dictionary under the key 'g'. After storing the greenlet, the function sets the created_event, which is typically used to notify other threads that the greenlet has been created and is available. Finally, the function waits for the done_event to be set, effectively pausing execution until another thread signals that it is safe to proceed or finish. This pattern is commonly used in multithreaded test scenarios to coordinate actions between threads.\n\n**Note**:  \n- The function relies on the existence of the data dictionary, created_event, and done_event objects, which must be properly initialized and accessible in the enclosing scope.\n- The function does not return any value.\n- Proper synchronization is required to avoid deadlocks or race conditions when using this function in a multithreaded environment."
                },
                {
                    "method_name": "blank",
                    "source_code": "def blank():\n    greenlet.getcurrent().parent.switch()",
                    "first_doc": "**blank**: The function of blank is to immediately switch execution from the current greenlet back to its parent greenlet.\n\n**parameters**: The parameters of this Function.\n· None\n\n**Code Description**:  \nThis function uses the greenlet library to manage coroutine-like lightweight threads called greenlets. When blank is called, it retrieves the currently running greenlet using greenlet.getcurrent(). It then accesses the parent attribute of this greenlet, which refers to the greenlet that spawned or resumed the current one. The function then calls switch() on the parent greenlet, causing the current greenlet to yield control and transfer execution back to its parent. No arguments are passed during the switch, and no further code is executed within blank after the switch occurs.\n\n**Note**:  \n- This function assumes that it is called within the context of a greenlet and that the parent greenlet exists and is able to resume execution.\n- If called from the main greenlet (which has no parent), this will raise an AttributeError.\n- The function does not return any value or perform any operations other than switching context."
                },
                {
                    "method_name": "setparent",
                    "source_code": "def setparent(g, value):\n    g.parent = value",
                    "first_doc": "**setparent**: The function of setparent is to assign a new parent to a given greenlet object.\n\n**parameters**: The parameters of this Function.\n· g: The greenlet object whose parent is to be set.\n· value: The new parent greenlet to be assigned to g.\n\n**Code Description**:  \nThis function directly sets the parent attribute of the greenlet object g to the specified value. In the context of greenlet-based concurrency, the parent attribute determines the greenlet to which control will be transferred when the current greenlet finishes execution or yields. By changing the parent, setparent allows dynamic reconfiguration of the greenlet execution hierarchy, which can be useful in advanced concurrency scenarios or testing environments where the parent-child relationships between greenlets need to be manipulated.\n\n**Note**:  \nCare should be taken when modifying the parent attribute of a greenlet, as improper use may lead to unexpected control flow or errors in greenlet scheduling. This function assumes that the provided g is a valid greenlet object and that value is a suitable greenlet to act as its parent."
                },
                {
                    "method_name": "test_deepcopy",
                    "source_code": "def test_deepcopy(self):\n    import copy\n    self.assertRaises(TypeError, copy.copy, greenlet())\n    self.assertRaises(TypeError, copy.deepcopy, greenlet())",
                    "first_doc": "**test_deepcopy**: The function of test_deepcopy is to verify that greenlet objects cannot be shallow-copied or deep-copied using the copy module.\n\n**parameters**: The parameters of this Function.\n· self: The instance of the test case class GreenletTests, used to access assertion methods.\n\n**Code Description**:  \nThis function tests the behavior of the greenlet object when subjected to Python's copy and deepcopy operations. It imports the copy module and then uses the assertRaises method to ensure that attempting to perform either a shallow copy (copy.copy) or a deep copy (copy.deepcopy) on a greenlet instance raises a TypeError. This confirms that greenlet objects are not copyable, which is important for maintaining the integrity and expected behavior of greenlet-based concurrency.\n\n**Note**:  \n- This test ensures that greenlet objects cannot be duplicated using standard copying mechanisms, which is a necessary restriction due to their internal state and execution context.\n- The function relies on the unittest framework's assertRaises method to check for the correct exception type.\n- Attempting to copy or deepcopy a greenlet object in user code will result in a TypeError, as validated by this test."
                },
                {
                    "method_name": "test_parent_restored_on_kill",
                    "source_code": "def test_parent_restored_on_kill(self):\n    hub = greenlet(lambda: None)\n    main = greenlet.getcurrent()\n    result = []\n    def worker():\n        try:\n            # Wait to be killed\n            main.switch()\n        except greenlet.GreenletExit:\n            # Resurrect and switch to parent\n            result.append(greenlet.getcurrent().parent)\n            result.append(greenlet.getcurrent())\n            hub.switch()\n    g = greenlet(worker, parent=hub)\n    g.switch()\n    del g\n    self.assertTrue(result)\n    self.assertEqual(result[0], main)\n    self.assertEqual(result[1].parent, hub)",
                    "first_doc": "**test_parent_restored_on_kill**: The function of test_parent_restored_on_kill is to verify that the parent attribute of a greenlet is correctly restored when the greenlet is killed and control is switched.\n\n**parameters**: The parameters of this Function.\n· self: The instance of the test case class, used to access assertion methods and maintain test context.\n\n**Code Description**:  \nThis function is a unit test designed to check the behavior of greenlet parent restoration upon termination. It begins by creating a hub greenlet with a no-op lambda function and retrieves the current greenlet (main). An empty list, result, is initialized to collect test outcomes.\n\nA worker function is defined, which attempts to switch control back to the main greenlet and waits to be killed. When the worker greenlet is killed (raising greenlet.GreenletExit), it appends its current parent and itself to the result list, then switches to the hub greenlet.\n\nA new greenlet g is created with the worker function as its run target and the hub as its parent. The test switches into g, then deletes the reference to g, which triggers its cleanup and the GreenletExit exception in worker. The test then asserts that the result list is not empty, that the first element in result is the main greenlet (verifying the parent restoration), and that the parent of the second element in result is the hub greenlet.\n\n**Note**:  \n- This test ensures that the greenlet's parent attribute is correctly managed during greenlet termination and resurrection.\n- The test relies on the correct behavior of greenlet switching and exception handling.\n- The deletion of g is necessary to trigger the GreenletExit and test the restoration logic.\n- The assertions confirm both the restoration of the parent and the correct parent-child relationship after the greenlet is killed."
                },
                {
                    "method_name": "worker",
                    "source_code": "def worker():\n    try:\n        # Wait to be killed\n        main.switch()\n    except greenlet.GreenletExit:\n        # Resurrect and switch to parent\n        result.append(greenlet.getcurrent().parent)\n        result.append(greenlet.getcurrent())\n        hub.switch()",
                    "first_doc": "**worker**: The function of worker is to demonstrate the behavior of a greenlet when it is killed, specifically handling the GreenletExit exception and switching control back to the parent greenlet and the hub.\n\n**parameters**: The parameters of this Function.\n· None\n\n**Code Description**:  \nThe worker function is designed to be run as a greenlet. It initially yields control to the main greenlet by calling main.switch(), effectively pausing its execution and waiting to be resumed or killed. If the worker greenlet is killed, a GreenletExit exception is raised. The function catches this exception and, in the exception handler, appends two items to the result list: the parent of the current greenlet (obtained via greenlet.getcurrent().parent) and the current greenlet itself (greenlet.getcurrent()). After recording this information, the function switches execution to the hub greenlet by calling hub.switch(). This sequence ensures that the parent relationship and the current greenlet state are captured at the moment of termination, and that control flow is explicitly managed after the greenlet is killed.\n\n**Note**:  \n- This function assumes that the variables main, result, hub, and greenlet are defined in the enclosing scope.\n- The function is intended to be used within a greenlet-based concurrency context, such as in gevent or similar libraries.\n- The function does not accept any arguments and relies on external variables for its operation.\n- Proper setup of the greenlet environment and the result list is required for correct functioning."
                },
                {
                    "method_name": "test_parent_return_failure",
                    "source_code": "def test_parent_return_failure(self):\n    # No run causes AttributeError on switch\n    g1 = greenlet()\n    # Greenlet that implicitly switches to parent\n    g2 = greenlet(lambda: None, parent=g1)\n    # AttributeError should propagate to us, no fatal errors\n    self.assertRaises(AttributeError, g2.switch)",
                    "first_doc": "**test_parent_return_failure**: The function of test_parent_return_failure is to verify that an AttributeError is correctly raised when attempting to switch to a greenlet whose parent has not been run.\n\n**parameters**: The parameters of this Function.\n· self: Refers to the instance of the test case class, allowing access to assertion methods.\n\n**Code Description**:  \nThis test checks the behavior of greenlet objects when a switch is attempted to a greenlet whose parent has not yet been executed. First, a greenlet instance g1 is created without running it. Then, a second greenlet g2 is created with a simple lambda function as its run target and g1 set as its parent. Since g1 has not been run, its internal state is not properly initialized. When g2 attempts to switch, it implicitly tries to switch to its parent (g1), which leads to an AttributeError because the parent greenlet is not in a runnable state. The test asserts that this AttributeError is raised and that no fatal errors occur during this process.\n\n**Note**:  \n- This test is designed to ensure that the greenlet library handles improper parent switching gracefully by raising an AttributeError.\n- It is important that the parent greenlet is properly initialized before switching to a child greenlet that may implicitly switch back to its parent.\n- The test does not execute any code within the greenlets; it only checks the error propagation mechanism.\n\n**Output Example**:  \nThe test passes if an AttributeError is raised when g2.switch() is called. There is no return value; the test framework will report success if the exception is raised as expected. If no exception or a different exception is raised, the test will fail."
                },
                {
                    "method_name": "test_throw_exception_not_lost",
                    "source_code": "def test_throw_exception_not_lost(self):\n    class mygreenlet(greenlet):\n        def __getattribute__(self, name):\n            try:\n                raise Exception()\n            except:\n                pass\n            return greenlet.__getattribute__(self, name)\n    g = mygreenlet(lambda: None)\n    self.assertRaises(SomeError, g.throw, SomeError())",
                    "first_doc": "**test_throw_exception_not_lost**: The function of test_throw_exception_not_lost is to verify that exceptions thrown into a greenlet are not lost, even when attribute access on the greenlet raises and handles its own exceptions internally.\n\n**parameters**: The parameters of this Function.\n· self: The test case instance, providing access to assertion methods and test context.\n\n**Code Description**:  \nThis test method defines a custom greenlet subclass, `mygreenlet`, which overrides the `__getattribute__` method. In this override, every attribute access on a `mygreenlet` instance will intentionally raise and immediately catch a generic `Exception`, before delegating to the base greenlet's attribute access. This setup simulates a scenario where attribute access on a greenlet could potentially interfere with exception propagation.\n\nAn instance of `mygreenlet` is created with a trivial lambda function as its run target. The test then uses `self.assertRaises` to ensure that when `SomeError` is thrown into the greenlet using `g.throw(SomeError())`, the exception is properly raised and not lost or swallowed due to the overridden attribute access logic.\n\nThe test relies on the custom exception class `SomeError`, which is specifically designed for use in greenlet-related tests. By throwing `SomeError` into the greenlet and asserting that it is raised, the test confirms that the greenlet's exception handling mechanism works correctly, even in the presence of potentially disruptive attribute access patterns.\n\n**Note**:  \n- This test is specifically designed to catch subtle bugs where exceptions might be lost due to internal exception handling in overridden methods like `__getattribute__`.\n- The custom exception `SomeError` is used solely for testing purposes and should not be used in production code.\n- The test does not return a value; it passes if the exception is correctly raised, and fails otherwise.\n\n**Output Example**:  \nThere is no direct return value from this test. If the test passes, it means that `SomeError` was correctly raised when thrown into the greenlet. If the exception is lost or not raised, the test framework will report a failure. For example, in a test runner output:\n\n```\n.\n----------------------------------------------------------------------\nRan 1 test in 0.001s\n\nOK\n```\n\nIf the exception was lost:\n```\nF\n======================================================================\nFAIL: test_throw_exception_not_lost (tests.test_greenlet.GreenletTests)\n----------------------------------------------------------------------\nAssertionError: SomeError not raised\n```"
                }
            ]
        },
        {
            "type": "class",
            "name": "mygreenlet",
            "methods": [
                {
                    "method_name": "__getattribute__",
                    "source_code": "def __getattribute__(self, name):\n    try:\n        raise Exception()\n    except:\n        pass\n    return greenlet.__getattribute__(self, name)",
                    "first_doc": "**__getattribute__**: The function of __getattribute__ is to retrieve the value of a named attribute from the mygreenlet object.\n\n**parameters**: The parameters of this Function.\n· self: The instance of the mygreenlet class from which the attribute is being accessed.\n· name: The string name of the attribute to retrieve.\n\n**Code Description**:  \nThis method overrides the default attribute access behavior for the mygreenlet object. When an attribute is accessed, the method first attempts to raise and immediately catch an Exception. This try-except block does not perform any operation with the exception; it simply raises and catches it, effectively making it a no-op in terms of logic. After this, the method delegates the actual attribute retrieval to the base greenlet class by calling greenlet.__getattribute__(self, name). This ensures that attribute access works as it would in the base class, with the only addition being the silent raising and catching of an Exception before the attribute is fetched.\n\n**Note**:  \n- The try-except block that raises and catches an Exception has no effect on the returned value or the attribute access, but it may impact performance or be used for testing exception handling behavior.\n- This method does not suppress or alter any exceptions that may arise from the actual attribute access itself; it only handles the artificially raised Exception.\n- The method should be used with caution in production code due to the unnecessary exception handling, which can degrade performance.\n\n**Output Example**:  \nIf the attribute name is \"parent\" and the mygreenlet object has a parent attribute, the return value will be the value of that attribute, as provided by the base greenlet class. For example:\n<greenlet.greenlet object at 0x7f8c1a2e4c70>"
                }
            ]
        },
        {
            "type": "class",
            "name": "convoluted",
            "methods": [
                {
                    "method_name": "__init__",
                    "source_code": "def __init__(self):\n    greenlet.__init__(self)\n    self.count = 0",
                    "first_doc": "**__init__**: The function of __init__ is to initialize a new instance of the class, setting up its base state and preparing it for use.\n\n**parameters**: The parameters of this Function.\n· (none): This constructor does not take any parameters.\n\n**Code Description**:  \nThis __init__ method serves as the constructor for the class. It first calls the __init__ method of the greenlet base class, ensuring that all necessary initialization for greenlet functionality is performed. After the base class is initialized, it sets an instance variable, self.count, to 0. This variable is likely intended to keep track of a count or number of occurrences related to the instance's operation. By initializing self.count to 0, the class ensures a consistent starting state for each new instance.\n\n**Note**:  \n- This constructor must be called when creating a new instance of the class to ensure proper setup.\n- The method does not accept any arguments.\n- The self.count attribute is initialized to 0 and can be used or modified by other methods within the class as needed.\n- Proper initialization of the greenlet base class is crucial for the correct functioning of greenlet-based concurrency."
                },
                {
                    "method_name": "__getattribute__",
                    "source_code": "def __getattribute__(self, name):\n    if name == 'run' and self.count == 0:\n        self.count = 1\n        self.switch(43)\n    return greenlet.__getattribute__(self, name)",
                    "first_doc": "**__getattribute__**: The function of __getattribute__ is to customize attribute access for the object, specifically intercepting access to the 'run' attribute to perform additional logic before delegating to the base greenlet's attribute access.\n\n**parameters**: The parameters of this Function.\n· self: The instance of the convoluted class.\n· name: The name of the attribute being accessed as a string.\n\n**Code Description**:  \nThis method overrides the standard attribute access mechanism for the object. When any attribute is accessed, __getattribute__ is invoked. If the attribute name being accessed is 'run' and the instance variable self.count is 0, the method sets self.count to 1 and immediately calls self.switch(43). This likely initiates a context switch in the greenlet with the value 43. After this conditional logic, the method delegates the attribute access to the base greenlet class by calling greenlet.__getattribute__(self, name), ensuring standard attribute retrieval for all attributes, including 'run' after the first access.\n\n**Note**:  \n- This method will only trigger the self.switch(43) call the first time the 'run' attribute is accessed (when self.count is 0). Subsequent accesses to 'run' will not trigger the switch, as self.count will have been set to 1.\n- Directly manipulating attribute access in this way can have side effects, especially if other code expects standard attribute access behavior.\n- The method assumes that self.count exists and is an integer; if not, an AttributeError may occur.\n- The use of greenlet.__getattribute__ ensures that the greenlet base class's attribute access logic is preserved.\n\n**Output Example**:  \nIf an instance obj of this class is created with obj.count == 0, then accessing obj.run will:\n- Set obj.count to 1,\n- Call obj.switch(43),\n- Return the 'run' attribute from the greenlet base class.\n\nFor example:\nresult = obj.run\n# This will trigger the switch(43) call and then return the 'run' attribute."
                },
                {
                    "method_name": "run",
                    "source_code": "def run(self, value):\n    while True:\n        self.parent.switch(value)",
                    "first_doc": "**run**: The function of run is to repeatedly switch execution back to the parent greenlet, passing a specified value each time.\n\n**parameters**: The parameters of this Function.\n· value: The value that will be passed to the parent greenlet during each switch.\n\n**Code Description**:  \nThis function enters an infinite loop, and in each iteration, it calls self.parent.switch(value). This operation transfers control from the current greenlet to its parent greenlet, along with the provided value. The loop ensures that as soon as control returns to this greenlet, it immediately switches back to the parent again, continuously passing the same value. This behavior effectively prevents the current greenlet from making any progress beyond this point, as it never exits the loop or performs any other operations except switching to the parent.\n\n**Note**:  \n- This function will never return or exit on its own due to the infinite loop.\n- It relies on the existence of a valid parent greenlet; if self.parent is not set or is invalid, this may result in an error.\n- The value parameter is sent to the parent greenlet each time the switch occurs, so the parent should be prepared to handle repeated incoming values.\n- Care should be taken to avoid unintentional infinite switching, which can lead to stack overflows or unresponsive behavior if not managed properly."
                }
            ]
        },
        {
            "type": "class",
            "name": "convoluted",
            "methods": [
                {
                    "method_name": "__getattribute__",
                    "source_code": "def __getattribute__(self, name):\n    if name == 'run':\n        self.parent = another[0]\n    return greenlet.__getattribute__(self, name)",
                    "first_doc": "**__getattribute__**: The function of __getattribute__ is to intercept attribute access on the object and perform custom logic when the 'run' attribute is accessed.\n\n**parameters**: The parameters of this Function.\n· self: The instance of the object on which the attribute is being accessed.\n· name: The name of the attribute being accessed as a string.\n\n**Code Description**:  \nThis method overrides the default attribute access behavior for the object. When any attribute is accessed, the method checks if the attribute name is 'run'. If so, it sets the object's parent attribute to another[0], which implies that another is a list or similar sequence containing at least one element. After this conditional logic, the method delegates the actual attribute retrieval to the base greenlet class by calling greenlet.__getattribute__(self, name). This ensures that standard attribute access is preserved, except for the side effect when 'run' is accessed.\n\n**Note**:  \n- This method introduces a side effect when accessing the 'run' attribute, as it changes the parent attribute of the object. This can affect the behavior of the greenlet, especially in concurrent or asynchronous contexts.\n- It is important that another[0] is defined and accessible in the current scope; otherwise, a NameError or IndexError may occur.\n- The method does not restrict or modify access to any attribute other than 'run'.\n\n**Output Example**:  \nIf obj is an instance of this class, calling obj.run will set obj.parent to another[0] and then return the value of obj.run as defined in the greenlet base class. For example:\n\nresult = obj.run\n# This will set obj.parent = another[0] before returning obj.run"
                }
            ]
        },
        {
            "type": "class",
            "name": "finalized",
            "methods": [
                {
                    "method_name": "__del__",
                    "source_code": "def __del__(self):\n    # happens while in green_updatecurrent() in main greenlet\n    # should be very careful not to accidentally call it again\n    # at the same time we must make sure another thread executes\n    lock2.release()\n    lock1.acquire()",
                    "first_doc": "**__del__**: The function of __del__ is to handle cleanup actions when the object is being destroyed, specifically managing thread synchronization using locks.\n\n**parameters**: The parameters of this Function.\n· self: Refers to the instance of the class whose destructor is being called.\n\n**Code Description**:  \nThis method is a destructor that is automatically invoked when the object is about to be garbage collected. Its primary purpose is to manage thread synchronization by interacting with two lock objects, lock2 and lock1. Upon invocation, it releases lock2 and then acquires lock1. This sequence ensures that another thread, which may be waiting on these locks, can proceed safely. The comments indicate that this method is called during the execution of green_updatecurrent() in the main greenlet, and caution is advised to avoid re-entrancy or concurrent execution of this destructor.\n\n**Note**:  \n- This method should not be called explicitly; it is intended to be triggered by Python's garbage collection mechanism.\n- Care must be taken to avoid situations where __del__ could be called multiple times concurrently, as this could lead to race conditions or deadlocks.\n- The correct functioning of this method depends on the proper initialization and state of lock1 and lock2.\n- Improper use of thread synchronization primitives in destructors can lead to hard-to-debug concurrency issues."
                },
                {
                    "method_name": "another_thread",
                    "source_code": "def another_thread():\n    lock1.acquire() # wait for gc\n    greenlet.getcurrent() # update ts_current\n    lock2.release() # release gc",
                    "first_doc": "**another_thread**: The function of another_thread is to synchronize with other threads using locks and update the current greenlet context within a separate thread.\n\n**parameters**: The parameters of this Function.\n· none\n\n**Code Description**:  \nThe another_thread function is designed to be executed in a separate thread as part of a test involving greenlets and thread synchronization. It begins by acquiring lock1, which causes the thread to wait until another part of the program releases this lock, typically to coordinate with garbage collection or other thread operations. Once lock1 is acquired, the function calls greenlet.getcurrent(), which updates the thread-local storage to reflect the current greenlet context for this thread. This ensures that the greenlet system is aware of the currently executing greenlet in this thread. After updating the greenlet context, the function releases lock2, signaling to other threads or test logic that it has completed its critical section and that the next stage of the test or synchronization can proceed.\n\n**Note**:  \n- This function assumes that lock1 and lock2 are properly initialized threading locks and are accessible in the scope where another_thread is defined.\n- The function does not accept any parameters and relies on external synchronization primitives and the greenlet module.\n- Proper usage requires that lock1 is held by another thread before another_thread is started, to ensure correct synchronization.\n- This function is intended for use in a multithreaded test environment and is not suitable for general-purpose use without appropriate context and synchronization setup."
                }
            ]
        },
        {
            "type": "class",
            "name": "gc_callback",
            "methods": [
                {
                    "method_name": "__del__",
                    "source_code": "def __del__(self):\n    lock1.release()\n    lock2.acquire()\n    recycled[0] = True",
                    "first_doc": "**__del__**: The function of __del__ is to perform cleanup actions when the object is about to be destroyed by the Python garbage collector.\n\n**parameters**: The parameters of this Function.\n· self: Refers to the instance of the class for which this destructor is defined.\n\n**Code Description**:  \nThis method is a destructor, which is automatically called when the object is about to be garbage collected. In this implementation, the method performs three actions in sequence:\n1. It releases lock1 by calling lock1.release(). This action signals that a resource or critical section previously locked by this thread or process is now available.\n2. It acquires lock2 by calling lock2.acquire(). This causes the current thread to block until lock2 is available, ensuring synchronization with other threads or processes that may be waiting on this lock.\n3. It sets the first element of the recycled list to True (recycled[0] = True), which likely serves as a flag to indicate that the object has been successfully recycled or cleaned up.\n\nThese actions are typically used in multithreaded test scenarios to coordinate the timing of object destruction and resource management between threads.\n\n**Note**:  \n- The __del__ method should be used with caution, as its execution timing is determined by the Python garbage collector and may not be predictable.\n- If lock1 or lock2 are not properly initialized or are in an inconsistent state at the time of object destruction, this method could raise exceptions or cause deadlocks.\n- Modifying shared data structures (such as recycled) in a destructor may have concurrency implications and should be carefully managed to avoid race conditions."
                }
            ]
        },
        {
            "type": "class",
            "name": "garbage",
            "methods": [
                {
                    "method_name": "__init__",
                    "source_code": "def __init__(self):\n    self.cycle = self\n    self.callback = gc_callback()",
                    "first_doc": "**__init__**: The function of __init__ is to initialize an instance by setting up a self-referential cycle and assigning a gc_callback instance to an attribute for garbage collection synchronization.\n\n**parameters**: The parameters of this Function.\n· self: The instance of the class being initialized.\n\n**Code Description**:  \nThis constructor method initializes two attributes for the instance:\n\n- self.cycle is set to reference the instance itself, creating a self-referential cycle. This is often used to deliberately create a reference cycle, which is relevant for testing garbage collection behavior, especially in scenarios where cyclic references are involved.\n- self.callback is assigned a new instance of gc_callback. The gc_callback class is designed to perform specific synchronization actions when it is garbage collected, such as releasing and acquiring locks and updating a status flag. By assigning an instance of gc_callback to self.callback, the object ensures that these actions will be triggered when the parent object (and thus its callback attribute) becomes unreachable and is collected by the garbage collector.\n\nThis setup is particularly useful in testing or managing resource cleanup and synchronization in multi-threaded environments, where it is important to verify that finalization logic is executed correctly even in the presence of reference cycles.\n\n**Note**:  \n- The creation of a self-referential cycle (self.cycle = self) means that the object will not be immediately collected by reference counting alone; it will require the cyclic garbage collector to detect and collect it.\n- The correct functioning of the gc_callback instance depends on the presence and proper initialization of synchronization primitives (lock1, lock2) and the recycled list in the surrounding scope.\n- Care must be taken when using finalizers (__del__ methods) and locks together, as improper use can lead to deadlocks or unpredictable behavior during garbage collection."
                }
            ]
        },
        {
            "type": "class",
            "name": "mytuple",
            "methods": [
                {
                    "method_name": "__len__",
                    "source_code": "def __len__(self):\n    greenlet.getcurrent().switch()\n    return tuple.__len__(self)",
                    "first_doc": "**__len__**: The function of __len__ is to return the number of elements in the mytuple instance.\n\n**parameters**: The parameters of this Function.\n· self: The instance of the mytuple subclass whose length is being queried.\n\n**Code Description**:  \nThis method overrides the standard __len__ method for a tuple subclass named mytuple. When __len__ is called, it first switches execution to another greenlet using greenlet.getcurrent().switch(). This means that the current greenlet yields control, and execution resumes in another greenlet context. After the switch, the method returns the length of the tuple by invoking the base tuple class's __len__ method on self. This ensures that the length calculation is consistent with the built-in tuple type, but only after a greenlet context switch has occurred.\n\n**Note**:  \n- The method introduces a context switch using greenlet before returning the length, which may affect program flow and should be used with care in concurrent or asynchronous environments.\n- This behavior is non-standard for __len__ methods and may lead to unexpected results if consumers of the class are unaware of the greenlet switch.\n- The method does not accept any arguments other than self.\n\n**Output Example**:  \nIf mytuple contains three elements, calling len(instance_of_mytuple) will return 3, but only after a greenlet context switch has occurred. For example:\n3"
                }
            ]
        },
        {
            "type": "class",
            "name": "BadSubclass",
            "methods": []
        },
        {
            "type": "class",
            "name": "GoodSubclass",
            "methods": [
                {
                    "method_name": "run",
                    "source_code": "def run(self):\n    pass",
                    "first_doc": "**run**: The function of run is to serve as a placeholder method for execution logic in the GoodSubclass class.\n\n**parameters**: The parameters of this Function.\n· self: Refers to the instance of the GoodSubclass on which this method is called.\n\n**Code Description**:  \nThis method is defined within the GoodSubclass class, which is a subclass used in the context of testing abstract subclasses of greenlets. The run method is implemented with a pass statement, meaning it does not perform any operations or contain any logic. Its presence fulfills the requirement that subclasses of certain abstract base classes must implement a run method, even if the method body is empty. This is commonly used in test scenarios to verify subclassing behavior or to act as a stub for further extension.\n\n**Note**:  \n- The run method does not execute any code or return any value.\n- This method is intended to satisfy interface or abstract base class requirements and may be overridden in subclasses to provide actual functionality.\n- When using this class in tests or as a base for further development, additional logic should be implemented in the run method as needed."
                }
            ]
        }
    ],
    "tests/test_gc.py": [
        {
            "type": "class",
            "name": "GCTests",
            "methods": [
                {
                    "method_name": "test_dead_circular_ref",
                    "source_code": "def test_dead_circular_ref(self):\n    o = weakref.ref(greenlet.greenlet(greenlet.getcurrent).switch())\n    gc.collect()\n    self.assertTrue(o() is None)\n    self.assertFalse(gc.garbage, gc.garbage)",
                    "first_doc": "**test_dead_circular_ref**: The function of test_dead_circular_ref is to verify that dead circular references involving greenlets are properly collected by the garbage collector and do not remain in gc.garbage.\n\n**parameters**: The parameters of this Function.\n· self: The instance of the test case class, used to access assertion methods.\n\n**Code Description**:  \nThis function is a unit test designed to ensure that circular references created by greenlets do not result in uncollectable garbage. It first creates a greenlet object that references the current greenlet and immediately switches to it. A weak reference to the resulting object is stored in o. The garbage collector is then explicitly invoked using gc.collect(). The test asserts that the weak reference o is now dead (i.e., o() returns None), confirming that the greenlet object has been collected. Finally, it asserts that the gc.garbage list is empty, ensuring that no uncollectable objects remain after garbage collection.\n\n**Note**:  \nThis test is important for confirming that the integration of greenlets with Python's garbage collector does not leave behind uncollectable circular references. It assumes that gc.garbage is empty before the test runs and that the environment supports weak references and greenlets."
                },
                {
                    "method_name": "test_circular_greenlet",
                    "source_code": "def test_circular_greenlet(self):\n    class circular_greenlet(greenlet.greenlet):\n        pass\n    o = circular_greenlet()\n    o.self = o\n    o = weakref.ref(o)\n    gc.collect()\n    self.assertTrue(o() is None)\n    self.assertFalse(gc.garbage, gc.garbage)",
                    "first_doc": "**test_circular_greenlet**: The function of test_circular_greenlet is to verify that a greenlet object with a circular reference is properly garbage collected and does not end up in the gc.garbage list.\n\n**parameters**: The parameters of this Function.\n· self: The instance of the test case class, used to access assertion methods.\n\n**Code Description**:  \nThis function defines a test case that checks the garbage collection behavior of a custom greenlet object with a circular reference. Inside the function, a subclass of greenlet.greenlet named circular_greenlet is defined. An instance of this subclass, o, is created. A circular reference is introduced by assigning o.self = o, making the object reference itself.\n\nThe strong reference to o is then replaced by a weak reference using weakref.ref(o). This means that the only remaining reference to the object is weak, and it should be eligible for garbage collection. The garbage collector is explicitly invoked using gc.collect() to force collection of unreachable objects.\n\nAfter garbage collection, the test asserts that the weak reference o() returns None, confirming that the object has been collected. It also asserts that gc.garbage is empty, ensuring that the object was not placed in the garbage list due to uncollectable circular references.\n\n**Note**:  \n- This test ensures that greenlet objects with circular references are properly collected and do not cause memory leaks.\n- The test relies on the correct functioning of Python's garbage collector and weak reference mechanisms.\n- The gc.garbage list is checked to confirm that no uncollectable objects remain after collection, which is important for applications that need to avoid memory leaks due to reference cycles."
                }
            ]
        },
        {
            "type": "class",
            "name": "circular_greenlet",
            "methods": []
        },
        {
            "type": "class",
            "name": "inactive_greenlet",
            "methods": [
                {
                    "method_name": "__init__",
                    "source_code": "def __init__(self):\n    greenlet.greenlet.__init__(self, run=self.run)",
                    "first_doc": "**__init__**: The function of __init__ is to initialize an instance of the inactive_greenlet class and properly set up its execution entry point.\n\n**parameters**: The parameters of this Function.\n· self: Refers to the instance of the inactive_greenlet class being created.\n\n**Code Description**:  \nThis method serves as the constructor for the inactive_greenlet class, which is a subclass of greenlet.greenlet. During initialization, it explicitly calls the parent greenlet.greenlet's __init__ method, passing run=self.run as an argument. This ensures that when the greenlet is activated, its execution will begin at the run method defined within the inactive_greenlet class. The run method, as implemented, is an empty method that fulfills the requirement for a greenlet entry point but does not perform any operations. By setting run=self.run during initialization, the class guarantees that the greenlet infrastructure is correctly established and ready for activation, even though no specific logic will be executed when the greenlet runs.\n\n**Note**:  \n- The __init__ method must be called to properly configure the greenlet's execution target.\n- The run method is required by the greenlet interface and is set as the entry point, but it does not contain any logic in this implementation.\n- This setup is essential for creating a valid, though inactive, greenlet instance."
                },
                {
                    "method_name": "run",
                    "source_code": "def run(self):\n    pass",
                    "first_doc": "**run**: The function of run is to serve as the entry point for the greenlet's execution.\n\n**parameters**: The parameters of this Function.\n· self: Refers to the instance of the inactive_greenlet class.\n\n**Code Description**:  \nThis method is defined as the run function for the inactive_greenlet class, which is a subclass of greenlet.greenlet. The run method is intended to be the main execution body for the greenlet when it is started. In this implementation, the run method is currently empty and does not perform any operations. The method is set as the target for the greenlet's execution in the class's __init__ method, where greenlet.greenlet is initialized with run=self.run. This means that when the greenlet is activated, it will execute the run method. The presence of this method ensures that the greenlet has a valid entry point, even though no specific logic is provided in this case.\n\n**Note**:  \n- The run method must be present to comply with the greenlet interface, even if it does not contain any logic.\n- If custom behavior is needed when the greenlet is run, this method should be implemented accordingly.\n- As currently implemented, running this greenlet will have no effect, as the method body is empty."
                }
            ]
        },
        {
            "type": "class",
            "name": "object_with_finalizer",
            "methods": [
                {
                    "method_name": "__del__",
                    "source_code": "def __del__(self):\n    pass",
                    "first_doc": "**__del__**: The function of __del__ is to define a destructor method that is called when an instance of the class is about to be destroyed.\n\n**parameters**: The parameters of this Function.\n· self: Refers to the instance of the class whose destructor is being invoked.\n\n**Code Description**:  \nThis __del__ method is a special method in Python, known as a destructor. It is automatically invoked when an object is about to be garbage collected, that is, when there are no more references to the object. In this implementation, the method body contains only a pass statement, which means that no specific cleanup or finalization actions are performed when the object is destroyed. The method exists to explicitly define the destructor, but it does not alter the object's destruction behavior.\n\n**Note**:  \n- The presence of an empty __del__ method does not affect the default destruction process of the object.\n- If custom cleanup or resource release is required upon object deletion, the logic should be implemented within this method.\n- Relying on __del__ for critical resource management is generally discouraged, as the timing of its invocation is determined by Python’s garbage collector and is not guaranteed to be immediate or predictable."
                }
            ]
        }
    ],
    "tests/__init__.py": [],
    "tests/test_weakref.py": [
        {
            "type": "class",
            "name": "WeakRefTests",
            "methods": [
                {
                    "method_name": "test_dead_weakref",
                    "source_code": "def test_dead_weakref(self):\n    def _dead_greenlet():\n        g = greenlet.greenlet(lambda: None)\n        g.switch()\n        return g\n    o = weakref.ref(_dead_greenlet())\n    gc.collect()\n    self.assertEqual(o(), None)",
                    "first_doc": "**test_dead_weakref**: The function of test_dead_weakref is to verify that a weak reference to a dead greenlet object returns None after garbage collection.\n\n**parameters**: The parameters of this Function.\n· self: The instance of the test case class, used to access assertion methods.\n\n**Code Description**:  \nThis function defines a test case to ensure that weak references behave correctly when the referenced object, specifically a greenlet, has been destroyed. It defines an inner function, _dead_greenlet, which creates a greenlet object, switches to it (thus running its target lambda, which does nothing), and returns the greenlet instance. After calling _dead_greenlet, a weak reference to the returned greenlet object is created using weakref.ref. Garbage collection is then explicitly triggered using gc.collect() to ensure that any unreachable objects are cleaned up. Finally, the test asserts that calling the weak reference returns None, confirming that the greenlet object has been properly collected and the weak reference no longer points to a live object.\n\n**Note**:  \n- This test assumes that the greenlet module is available and that greenlet objects can be weakly referenced.\n- Explicit garbage collection is necessary to ensure the greenlet object is destroyed before checking the weak reference.\n- The test is designed to be run within a unittest framework, utilizing self.assertEqual for assertions.\n\n**Output Example**:  \nThere is no direct return value from this function. If the test passes, it means that o() (the weak reference) returns None after garbage collection. If the test fails, an AssertionError will be raised."
                },
                {
                    "method_name": "_dead_greenlet",
                    "source_code": "def _dead_greenlet():\n    g = greenlet.greenlet(lambda: None)\n    g.switch()\n    return g",
                    "first_doc": "**_dead_greenlet**: The function of _dead_greenlet is to create and return a greenlet object that has already finished execution (i.e., a dead greenlet).\n\n**parameters**: The parameters of this Function.\n· This function does not accept any parameters.\n\n**Code Description**:  \n_dead_greenlet creates a new greenlet object using greenlet.greenlet, passing a lambda function that does nothing (lambda: None) as its target. It then immediately switches to this greenlet using g.switch(), which causes the lambda function to execute and complete instantly. After this switch, the greenlet has finished its execution and is considered \"dead.\" The function then returns this dead greenlet object. This utility is useful in tests or scenarios where a reference to a dead greenlet is required, such as verifying weak reference behavior or cleanup logic.\n\n**Note**:  \n- The returned greenlet object is guaranteed to be dead, meaning it cannot be resumed or switched to again.\n- This function assumes that the greenlet module is available and properly imported.\n- The function does not take any arguments and always returns a new dead greenlet instance.\n\n**Output Example**:  \n<greenlet.greenlet object at 0x7f9e4c3d3e80 (dead)>  \nThe actual memory address will vary, but the returned object will always be a dead greenlet."
                },
                {
                    "method_name": "test_inactive_weakref",
                    "source_code": "def test_inactive_weakref(self):\n    o = weakref.ref(greenlet.greenlet())\n    gc.collect()\n    self.assertEqual(o(), None)",
                    "first_doc": "**test_inactive_weakref**: The function of test_inactive_weakref is to verify that a weak reference to a greenlet object becomes inactive (returns None) after the object has been garbage collected.\n\n**parameters**: The parameters of this Function.\n· self: The instance of the test case class, used to access test methods and assertions.\n\n**Code Description**:  \nThis function creates a weak reference to a newly instantiated greenlet object using weakref.ref. Since the greenlet object is not assigned to any variable other than the weak reference, it becomes unreachable immediately after creation. The function then explicitly triggers garbage collection using gc.collect() to ensure that any unreachable objects are collected. Finally, it asserts that calling the weak reference returns None, confirming that the original greenlet object has been collected and the weak reference is now inactive.\n\n**Note**:  \n- This test ensures that weak references to greenlet objects behave as expected when the referenced object is no longer strongly referenced and has been garbage collected.\n- The test relies on the behavior of Python's garbage collector and the weakref module.\n- It is important that no other references to the greenlet object exist at the time of garbage collection, otherwise the weak reference would remain active."
                },
                {
                    "method_name": "test_dealloc_weakref",
                    "source_code": "def test_dealloc_weakref(self):\n    seen = []\n    def worker():\n        try:\n            greenlet.getcurrent().parent.switch()\n        finally:\n            seen.append(g())\n    g = greenlet.greenlet(worker)\n    g.switch()\n    g2 = greenlet.greenlet(lambda: None, g)\n    g = weakref.ref(g2)\n    g2 = None\n    self.assertEqual(seen, [None])",
                    "first_doc": "**test_dealloc_weakref**: The function of test_dealloc_weakref is to verify that a weak reference to a greenlet object is properly cleared when the greenlet is deallocated.\n\n**parameters**: The parameters of this Function.\n· self: Refers to the instance of the test case class, allowing access to assertion methods.\n\n**Code Description**:  \nThis function tests the behavior of weak references in conjunction with greenlet objects. It begins by defining a list named seen to collect results. Inside the function, a worker function is defined, which, when executed as a greenlet, switches control to its parent greenlet. In the finally block of worker, it appends the result of calling the weak reference g() to the seen list.\n\nA greenlet object g is created with worker as its target function. The greenlet is started by calling g.switch(), which executes the worker function up to the point where it switches to its parent. Next, a second greenlet g2 is created with a no-op lambda function as its target and g as its parent. A weak reference to g2 is then created and assigned to g, and the strong reference to g2 is removed by setting g2 to None.\n\nAt this point, since there are no more strong references to the second greenlet, it is eligible for garbage collection, and the weak reference should return None. The test asserts that the seen list contains [None], confirming that the weak reference was cleared as expected when the greenlet was deallocated.\n\n**Note**:  \n- This test ensures that weak references to greenlet objects behave correctly and are cleared upon deallocation.\n- The use of finally in the worker function guarantees that the weak reference is checked regardless of how the greenlet exits.\n- The test relies on the garbage collector to clean up the greenlet object after all strong references are removed."
                },
                {
                    "method_name": "worker",
                    "source_code": "def worker():\n    try:\n        greenlet.getcurrent().parent.switch()\n    finally:\n        seen.append(g())",
                    "first_doc": "**worker**: The function of worker is to yield control to its parent greenlet and then append the result of calling g() to the seen list upon completion.\n\n**parameters**: The parameters of this Function.\n· This function does not take any parameters.\n\n**Code Description**:  \nThe worker function is designed to be executed within a greenlet context. When called, it attempts to switch execution back to its parent greenlet using greenlet.getcurrent().parent.switch(). This effectively suspends the current greenlet and resumes execution in the parent greenlet. The try-finally construct ensures that, regardless of how the switch operation completes (whether normally or due to an exception), the finally block will always execute. In the finally block, the function appends the result of calling g() to the seen list. This guarantees that the seen list is updated with the output of g() when the worker function finishes its execution.\n\n**Note**:  \n- The function assumes that g is a callable object and seen is a mutable sequence (such as a list) that are accessible in the enclosing scope.\n- This function is intended to be used with the greenlet library, and proper greenlet context management is required for correct operation.\n- The function does not handle exceptions explicitly; any exceptions raised during the switch will propagate after the finally block is executed."
                }
            ]
        }
    ],
    "tests/test_version.py": [
        {
            "type": "class",
            "name": "VersionTests",
            "methods": [
                {
                    "method_name": "test_version",
                    "source_code": "def test_version(self):\n    upfile = lambda p: os.path.join(os.path.dirname(__file__), \"..\", p)\n    hversion, = re.findall('GREENLET_VERSION \"(.*)\"', readfile(upfile(\"greenlet.h\")))\n    sversion = readclose(os.popen(\"%s %s --version\" % (sys.executable, upfile(\"setup.py\")))).strip()\n    self.assertFalse(sversion != hversion)\n    self.assertFalse(sversion != greenlet.__version__)",
                    "first_doc": "**test_version**: The function of test_version is to verify that the version information reported by the greenlet package is consistent across its header file, setup script, and the greenlet module itself.\n\n**parameters**: The parameters of this Function.\n· self: The test case instance (typically provided by the test framework).\n\n**Code Description**:  \nThis function is a unit test designed to ensure version consistency within the greenlet package. It performs the following steps:\n\n1. It defines a helper lambda function, upfile, which constructs a path relative to the current file's directory. This is used to locate files such as \"greenlet.h\" and \"setup.py\" in the parent directory.\n\n2. It reads the contents of the \"greenlet.h\" header file using the readfile function, which safely opens and reads the file, ensuring it is closed afterward. A regular expression is then used to extract the version string defined as GREENLET_VERSION in the header file.\n\n3. It executes the setup.py script with the --version argument using the current Python interpreter (sys.executable). The output of this command is read and closed using the readclose function, which ensures the process output is fully read and the underlying resource is released. The resulting string is stripped of leading and trailing whitespace to obtain the version as reported by setup.py.\n\n4. It asserts that the version string obtained from setup.py matches the version extracted from the header file. This is done by checking that sversion != hversion is False, i.e., sversion equals hversion.\n\n5. It asserts that the version string from setup.py also matches the __version__ attribute of the greenlet module, again ensuring consistency across all sources.\n\nThe function relies on the readfile and readclose utility functions to handle file and process output reading safely and efficiently. This guarantees that all file and process resources are properly managed and closed after use.\n\n**Note**:  \n- This test assumes that the \"greenlet.h\" header file and \"setup.py\" script are located one directory above the test file.\n- The test requires that the greenlet module is importable and that setup.py supports the --version argument.\n- Any inconsistency in version information between the header file, setup script, and module will cause the test to fail, highlighting potential packaging or release issues.\n- The test uses assertFalse with inequality checks to ensure strict equality between version strings."
                }
            ]
        }
    ],
    "tests/test_generator_nested.py": [
        {
            "type": "class",
            "name": "genlet",
            "methods": [
                {
                    "method_name": "__init__",
                    "source_code": "def __init__(self, *args, **kwds):\n    self.args = args\n    self.kwds = kwds\n    self.child = None",
                    "first_doc": "**__init__**: The function of __init__ is to initialize an instance by storing positional and keyword arguments and setting up an initial child attribute.\n\n**parameters**: The parameters of this Function.\n· args: A variable-length tuple containing all positional arguments passed during instantiation.\n· kwds: A variable-length dictionary containing all keyword arguments passed during instantiation.\n\n**Code Description**:  \nThis method initializes the object by capturing any positional arguments in the args attribute and any keyword arguments in the kwds attribute. Both attributes are stored as instance variables, allowing them to be accessed by other methods or components of the class. Additionally, the child attribute is set to None during initialization, indicating that no child object or reference is associated with the instance at creation. This setup provides a flexible structure for handling dynamic arguments and managing hierarchical or nested relationships through the child attribute.\n\n**Note**:  \n- The method does not perform any validation or processing of the input arguments; it simply stores them as provided.\n- The child attribute is initialized to None and should be explicitly set later if a child relationship is required.\n- This constructor supports any number of positional and keyword arguments, making the class highly adaptable for various use cases."
                },
                {
                    "method_name": "run",
                    "source_code": "def run(self):\n    fn, = self.fn\n    fn(*self.args, **self.kwds)",
                    "first_doc": "**run**: The function of run is to execute a stored function with its associated arguments and keyword arguments.\n\n**parameters**: The parameters of this Function.\n· self: Refers to the instance of the class containing this method. It provides access to the instance attributes used in the method.\n\n**Code Description**:  \nThis method retrieves a function object from the instance attribute self.fn, which is expected to be an iterable containing a single function. It then calls this function, passing in the positional arguments stored in self.args and the keyword arguments stored in self.kwds. The method does not return any value; it simply executes the function with the provided arguments.\n\n**Note**:  \n- The self.fn attribute must be an iterable containing exactly one function object; otherwise, unpacking will fail.\n- The self.args attribute should be a tuple of positional arguments, and self.kwds should be a dictionary of keyword arguments.\n- This method assumes that the function and its arguments have been properly set up before run is called.\n- No error handling is implemented within this method, so any exceptions raised by the function call will propagate to the caller."
                },
                {
                    "method_name": "__iter__",
                    "source_code": "def __iter__(self):\n    return self",
                    "first_doc": "**__iter__**: The function of __iter__ is to return the iterator object itself, enabling iteration over the object.\n\n**parameters**: The parameters of this Function.\n· self: Refers to the instance of the class in which this method is defined.\n\n**Code Description**:  \nThis method implements the iterator protocol by returning self. This means that the object is designed to be its own iterator. When an iteration context (such as a for loop) is used on an instance of this class, the __iter__ method is called, and the object itself is returned as the iterator. For the object to be a fully functional iterator, it must also implement the __next__ method, which is not shown here. This pattern is common when the object maintains its own state for iteration.\n\n**Note**:  \n- This method alone does not make the object iterable in a meaningful way; the class must also define a __next__ method to provide values during iteration.\n- If __next__ is not implemented, attempting to iterate over the object will result in a TypeError.\n- This method does not accept any arguments other than self.\n\n**Output Example**:  \nIf an instance of the class is called my_iterable, then iter(my_iterable) or using it in a for loop will return the my_iterable object itself as the iterator. For example:\n\n```\niterator = iter(my_iterable)\nprint(iterator is my_iterable)  # Output: True\n```"
                },
                {
                    "method_name": "set_child",
                    "source_code": "def set_child(self, child):\n    self.child = child",
                    "first_doc": "**set_child**: The function of set_child is to assign a given value to the child attribute of the current object.\n\n**parameters**: The parameters of this Function.\n· child: The value to be assigned to the child attribute of the object.\n\n**Code Description**:  \nThis function takes a single argument, child, and sets the object's child attribute to the provided value. It directly assigns the input parameter to the instance variable self.child, effectively updating or initializing the child reference for the object. This method is typically used to establish or modify a relationship between the current object and another object or value, which is stored in the child attribute.\n\n**Note**:  \n- The function does not perform any type checking or validation on the child parameter; it will accept any value passed to it.\n- Using this method will overwrite any existing value stored in the child attribute.\n- It is important to ensure that the value assigned to child is appropriate for the intended use of the object."
                },
                {
                    "method_name": "__next__",
                    "source_code": "def __next__(self):\n    if self.child:\n        child = self.child\n        while child.child:\n            tmp = child\n            child = child.child\n            tmp.child = None\n\n        result = child.switch()\n    else:\n        self.parent = greenlet.getcurrent()\n        result = self.switch()\n\n    if self:\n        return result\n    else:\n        raise StopIteration",
                    "first_doc": "**__next__**: The function of __next__ is to advance the generator to its next value, handling nested generator states and yielding control appropriately.\n\n**parameters**: The parameters of this Function.\n· self: Refers to the current instance of the generator-like object.\n\n**Code Description**:  \nThis method implements the iteration protocol for a generator-like object that supports nesting via child generators. When called, it checks if the current object has a child generator (`self.child`). If a child exists, it traverses down the chain of child generators until it reaches the deepest one (the one without a further child). During this traversal, it disconnects each parent from its child by setting `tmp.child = None`, effectively flattening the chain at that point.\n\nOnce the deepest child is found, it resumes execution of that child by calling its `switch()` method, which is expected to yield the next value. If there is no child, the method sets the current greenlet as the parent (`self.parent = greenlet.getcurrent()`) and resumes execution of the current generator using `self.switch()`.\n\nAfter resuming execution, if the generator is still active (`if self:`), it returns the result obtained from the switch. If the generator has been exhausted, it raises a `StopIteration` exception to signal the end of iteration, as required by the iterator protocol.\n\n**Note**:  \n- This method assumes that the object is using greenlets for context switching and that each generator-like object may have a parent and child relationship.\n- The method modifies the child chain by setting `child.child = None` during traversal, which may affect subsequent iterations or references to child generators.\n- The `switch()` method must be implemented and is expected to handle the actual execution and value yielding.\n- Proper exception handling for `StopIteration` is implemented to comply with Python's iterator protocol.\n\n**Output Example**:  \nIf the generator yields the value 42 on its next execution, calling `next(obj)` (where `obj` is an instance of this generator-like class) would return:\n42\n\nIf the generator is exhausted, calling `next(obj)` would raise:\nStopIteration"
                }
            ]
        },
        {
            "type": "class",
            "name": "Genlet",
            "methods": []
        },
        {
            "type": "class",
            "name": "NestedGeneratorTests",
            "methods": [
                {
                    "method_name": "test_layered_genlets",
                    "source_code": "def test_layered_genlets(self):\n    seen = []\n    for ii in gr2(5, seen):\n        seen.append(ii)\n    self.assertEqual(seen, [1, 1, 2, 4, 3, 9, 4, 16])",
                    "first_doc": "**test_layered_genlets**: The function of test_layered_genlets is to verify that the gr2 function correctly collects and appends values yielded by a nested generator structure into a list.\n\n**parameters**: The parameters of this Function.\n· self: The instance of the test case class, providing access to assertion methods and test context.\n\n**Code Description**:  \nThis test method is designed to validate the behavior of the gr2 function within a nested generator context. It initializes an empty list named seen and then iterates over the output of gr2(5, seen). For each value produced by gr2, it appends the value to the seen list. After the iteration, the test asserts that the seen list matches the expected sequence [1, 1, 2, 4, 3, 9, 4, 16].\n\nThe gr2 function, which is called within this test, internally invokes gr1, a generator that yields both a number and its square for each integer in the range from 1 up to (but not including) 5. gr2 collects these yielded values and appends them to the seen list. The test ensures that the sequence of values collected reflects the intended nested generator logic, where each integer and its square are yielded in order.\n\nThis test case serves as a verification that the layered generator and collection mechanism, as implemented in gr2 (and by extension gr1), operates correctly and that the integration between these components produces the expected output.\n\n**Note**:  \n- The test assumes that gr2 and its underlying generator gr1 are functioning as specified, particularly in their use of the genlet coroutine system.\n- The seen list must be mutable, as it is modified in place by gr2.\n- The test relies on the specific order and content of values yielded by gr1 and collected by gr2.\n- This test is intended for use within an automated testing framework, utilizing self.assertEqual for result validation."
                },
                {
                    "method_name": "test_permutations",
                    "source_code": "def test_permutations(self):\n    gen_perms = perms(list(range(4)))\n    permutations = list(gen_perms)\n    self.assertEqual(len(permutations), 4 * 3 * 2 * 1)\n    self.assertTrue([0, 1, 2, 3] in permutations)\n    self.assertTrue([3, 2, 1, 0] in permutations)\n    res = []\n    for ii in zip(perms(list(range(4))), perms(list(range(3)))):\n        res.append(ii)\n    self.assertEqual(\n        res,\n        [([0, 1, 2, 3], [0, 1, 2]), ([0, 1, 3, 2], [0, 2, 1]),\n         ([0, 2, 1, 3], [1, 0, 2]), ([0, 2, 3, 1], [1, 2, 0]),\n         ([0, 3, 1, 2], [2, 0, 1]), ([0, 3, 2, 1], [2, 1, 0])])",
                    "first_doc": "**test_permutations**: The function of test_permutations is to verify the correctness and behavior of the perms generator function, specifically for generating permutations of lists and handling nested generator scenarios.\n\n**parameters**: The parameters of this Function.\n· self: The instance of the test case class, providing access to assertion methods.\n\n**Code Description**:  \nThis function serves as a unit test to ensure that the perms function, which generates all possible permutations of a given list, operates as expected. The test proceeds in several steps:\n\n1. It first generates all permutations of the list [0, 1, 2, 3] using perms and collects them into a list named permutations.\n2. It asserts that the total number of generated permutations is 24, which matches the factorial of 4 (4! = 24), confirming that all possible orderings are produced.\n3. It checks that both the original list [0, 1, 2, 3] and its reverse [3, 2, 1, 0] are present in the generated permutations, ensuring that the function covers the full permutation space.\n4. The test then examines the behavior of perms when used in a nested context by zipping the output of perms(list(range(4))) and perms(list(range(3))). It collects the resulting pairs into a list called res.\n5. It asserts that res matches the expected sequence of paired permutations, verifying that perms can be used in parallel and that the zipped output aligns with the expected order.\n\nThe function relies on the perms generator, which uses a custom Yield mechanism within a genlet-based coroutine system to produce permutations. This test confirms that perms integrates correctly in both simple and nested generator scenarios.\n\n**Note**:  \n- This test assumes that the perms function is used within a genlet coroutine context, as required by its implementation.\n- The test validates both the completeness and correctness of the generated permutations, as well as the interoperability of multiple perms generators when used together.\n- The function is intended for use within an automated test suite and depends on the assertion methods provided by the test framework."
                },
                {
                    "method_name": "test_genlet_simple",
                    "source_code": "def test_genlet_simple(self):\n    for g in [g1, g2, g3]:\n        seen = []\n        for k in range(3):\n            for j in g(5, seen):\n                seen.append(j)\n        self.assertEqual(seen, 3 * [1, 0, 2, 1, 3, 2, 4, 3, 5, 4])",
                    "first_doc": "**test_genlet_simple**: The function of test_genlet_simple is to verify that the generator-like functions g1, g2, and g3 correctly produce a specific sequence of values and side effects when used in a nested iteration context.\n\n**parameters**: The parameters of this Function.\n· self: The instance of the test case class NestedGeneratorTests.\n\n**Code Description**:  \nThis function is a unit test designed to validate the behavior of three generator-like functions: g1, g2, and g3. It iterates over each of these functions in turn, applying the same test logic to each.\n\nFor each generator function g in the list [g1, g2, g3], the following steps are performed:\n1. An empty list named seen is initialized to record the side effects and yielded values.\n2. A loop runs three times (for k in range(3)), representing three independent invocations of the generator function.\n3. In each iteration of the outer loop, the generator function g is called with arguments 5 and seen. The function is expected to yield a sequence of values.\n4. For each value j yielded by the generator, the value is appended to the seen list.\n\nAfter all iterations, the test asserts that the final contents of the seen list match the expected sequence: three repetitions of [1, 0, 2, 1, 3, 2, 4, 3, 5, 4]. This sequence is constructed as follows:\n- Each call to g (whether g1, g2, or g3) with n=5 appends the values 1 through 5 to seen (as a side effect) and yields the values 0 through 4.\n- The test appends both the side effect values (from the generator function) and the yielded values to the same seen list, resulting in an interleaved pattern.\n- This process is repeated three times, so the final seen list contains three concatenated copies of the pattern.\n\nThe test ensures that all three generator-like functions (g1, g2, g3) behave identically in this context, both in terms of their yielded values and their side effects on the seen list. The use of assertEqual guarantees that any deviation from the expected behavior will cause the test to fail, providing a robust check of the generator implementations.\n\n**Note**:  \n- The test relies on the in-place modification of the seen list by the generator functions; callers must ensure that seen is properly initialized before each use.\n- The generator functions g1, g2, and g3 must be compatible with the iteration and side effect pattern expected by the test.\n- The test assumes that the generator functions are correctly implemented to yield values and update the seen list as described in their respective documentation.\n- This test is intended to be run within a test framework that provides the assertEqual method, such as unittest."
                },
                {
                    "method_name": "test_genlet_bad",
                    "source_code": "def test_genlet_bad(self):\n    try:\n        Yield(10)\n    except RuntimeError:\n        pass",
                    "first_doc": "**test_genlet_bad**: The function of test_genlet_bad is to verify that calling the Yield function outside of a genlet coroutine context correctly raises a RuntimeError.\n\n**parameters**: The parameters of this Function.\n· self: The instance of the test case class (used for test method context).\n\n**Code Description**:  \nThis function serves as a unit test to ensure the robustness of the Yield function's error handling. It attempts to invoke Yield(10) directly, without being inside a genlet coroutine. According to the design of Yield, this usage is invalid and should result in a RuntimeError, as Yield is only permitted within a genlet-based coroutine context. The test captures this exception using a try-except block and suppresses it, confirming that the error is raised as expected. This behavior enforces the constraint that Yield cannot be used arbitrarily and must be called within the proper coroutine environment, thereby maintaining the integrity of the coroutine system.\n\n**Note**:  \n- This test is essential for validating that improper usage of Yield is detected and handled by raising a RuntimeError.\n- The function does not perform any assertions or output; it simply passes if the exception is raised, and would fail (by propagating the exception) if not.\n- It is important for maintaining the correct usage patterns of the genlet coroutine system, preventing misuse of Yield outside its intended context."
                },
                {
                    "method_name": "test_nested_genlets",
                    "source_code": "def test_nested_genlets(self):\n    seen = []\n    for ii in ax(5):\n        seen.append(ii)",
                    "first_doc": "**test_nested_genlets**: The function of test_nested_genlets is to verify the behavior of the ax generator function when iterating over a fixed range and collecting its output.\n\n**parameters**: The parameters of this Function.\n· self: Refers to the instance of the test class NestedGeneratorTests, allowing access to its attributes and methods.\n\n**Code Description**:  \nThis function initializes an empty list named seen. It then iterates over the result of calling ax(5), appending each yielded value to the seen list. The purpose is to collect all outputs produced by the ax generator when provided with the argument 5. The function does not perform any assertions or checks within its body, focusing solely on the process of iteration and collection.\n\n**Note**:  \n- The function assumes that ax is a valid generator function available in the current scope and that it accepts a single integer argument.\n- No validation or assertion is performed on the collected results within this function.\n- The function is likely intended as part of a larger test suite, where the correctness of ax’s output may be verified elsewhere."
                }
            ]
        }
    ],
    "tests/test_stack_saved.py": [
        {
            "type": "class",
            "name": "Test",
            "methods": [
                {
                    "method_name": "test_stack_saved",
                    "source_code": "def test_stack_saved(self):\n    main = greenlet.getcurrent()\n    self.assertEqual(main._stack_saved, 0)\n\n    def func():\n        main.switch(main._stack_saved)\n\n    g = greenlet.greenlet(func)\n    x = g.switch()\n    assert x > 0, x\n    assert g._stack_saved > 0, g._stack_saved\n    g.switch()\n    assert g._stack_saved == 0, g._stack_saved",
                    "first_doc": "**test_stack_saved**: The function of test_stack_saved is to verify the correct behavior of the _stack_saved attribute in greenlet objects during context switching.\n\n**parameters**: The parameters of this Function.\n· self: The test case instance, typically provided by the unittest framework.\n\n**Code Description**:  \nThis function is a unit test that checks the internal _stack_saved attribute of greenlet objects to ensure it behaves as expected during greenlet context switches. The test starts by obtaining the current greenlet (main) and asserts that its _stack_saved attribute is initially 0, indicating no stack is saved.\n\nA nested function func is defined, which, when executed, switches back to the main greenlet and passes main._stack_saved as an argument. A new greenlet g is then created with func as its target. When g.switch() is called, execution transfers to func, which immediately switches back to main, passing the current value of main._stack_saved.\n\nThe test asserts that the value returned (x) is greater than 0, confirming that the stack was saved during the switch. It also asserts that g._stack_saved is greater than 0 after the first switch, indicating that the greenlet g has saved its stack. After switching back to g a second time, the test asserts that g._stack_saved returns to 0, confirming that the stack is no longer saved once the greenlet completes.\n\n**Note**:  \n- This test relies on the internal attribute _stack_saved, which is specific to the greenlet implementation and may not be part of the public API.  \n- The test is designed to ensure proper stack management in greenlet context switches, which is critical for correct coroutine behavior.  \n- Direct access to internal attributes like _stack_saved should be done with caution, as their behavior may change between greenlet versions.  \n- The test assumes that greenlet and its attributes are available and properly imported."
                },
                {
                    "method_name": "func",
                    "source_code": "def func():\n    main.switch(main._stack_saved)",
                    "first_doc": "**func**: The function of func is to switch the execution context to the stack saved in main._stack_saved.\n\n**parameters**: The parameters of this Function.\n· None\n\n**Code Description**:  \nThis function, func, performs a context switch by invoking main.switch with main._stack_saved as its argument. The main.switch method is responsible for transferring execution to a previously saved stack or context, which is referenced by main._stack_saved. This operation is typically used in coroutine, greenlet, or stack management frameworks to resume execution from a specific saved point in the program. The function does not accept any parameters and does not return any value; its sole purpose is to trigger the context switch.\n\n**Note**:  \n- Ensure that main._stack_saved contains a valid and properly initialized stack or context before calling this function; otherwise, the switch operation may fail or cause unexpected behavior.\n- This function is intended for use in environments where manual context or stack switching is supported and required.\n- Improper use may disrupt the normal flow of execution, so it should be used with caution and understanding of the underlying context management system."
                }
            ]
        }
    ],
    "tests/test_generator.py": [
        {
            "type": "class",
            "name": "genlet",
            "methods": [
                {
                    "method_name": "__init__",
                    "source_code": "def __init__(self, *args, **kwds):\n    self.args = args\n    self.kwds = kwds",
                    "first_doc": "**__init__**: The function of __init__ is to initialize an instance by storing positional and keyword arguments provided during object creation.\n\n**parameters**: The parameters of this Function.\n· args: A variable-length tuple containing all positional arguments passed to the instance.\n· kwds: A variable-length dictionary containing all keyword arguments passed to the instance.\n\n**Code Description**:  \nThis constructor method captures any positional arguments (*args) and keyword arguments (**kwds) supplied when an object is instantiated. It assigns the tuple of positional arguments to the instance variable self.args and the dictionary of keyword arguments to self.kwds. This allows the instance to retain and later access all arguments provided at initialization, regardless of their number or names.\n\n**Note**:  \nAll arguments passed during object creation are stored as-is without any processing or validation. Access them via the instance variables self.args and self.kwds as needed in other methods."
                },
                {
                    "method_name": "run",
                    "source_code": "def run(self):\n    fn, = self.fn\n    fn(*self.args, **self.kwds)",
                    "first_doc": "**run**: The function of run is to execute a stored function with its associated arguments and keyword arguments.\n\n**parameters**: The parameters of this Function.\n· self: Refers to the instance of the class containing this method. It provides access to the instance variables fn, args, and kwds.\n\n**Code Description**:  \nThe run method retrieves a single function object from the instance variable self.fn, which is expected to be an iterable containing exactly one function. It then calls this function, passing in the positional arguments stored in self.args and the keyword arguments stored in self.kwds. The method does not return any value; it simply executes the function with the provided arguments.\n\n**Note**:  \n- The self.fn attribute must be an iterable (such as a tuple or list) containing exactly one function object; otherwise, unpacking will fail.\n- The self.args attribute should be a tuple or list of positional arguments to be passed to the function.\n- The self.kwds attribute should be a dictionary of keyword arguments to be passed to the function.\n- This method assumes that the function and its arguments are correctly set up before run is called. Any errors in the function or arguments will result in a runtime exception during execution."
                },
                {
                    "method_name": "__iter__",
                    "source_code": "def __iter__(self):\n    return self",
                    "first_doc": "**__iter__**: The function of __iter__ is to return the iterator object itself, enabling iteration over the object.\n\n**parameters**: The parameters of this Function.\n· self: Refers to the instance of the class in which this method is defined.\n\n**Code Description**:  \nThis method implements the iterator protocol by returning self. By defining __iter__ in this way, the object becomes its own iterator. This is a common pattern for iterator classes in Python, where the object maintains its own iteration state and provides both __iter__ and __next__ methods. When an iteration context (such as a for loop) requests an iterator from the object, __iter__ is called and the object itself is returned, allowing iteration to proceed using the object's __next__ method.\n\n**Note**:  \n- For this pattern to work correctly, the class must also implement the __next__ method, which is responsible for returning the next item in the sequence and raising StopIteration when the iteration is complete.\n- This method does not accept any arguments other than self.\n- Using this method alone does not provide iteration capability unless __next__ is also defined.\n\n**Output Example**:  \nIf an instance of the class is used in a for loop or passed to the iter() function, the instance itself will be returned as the iterator:\n\n```\nit = iter(obj)  # it is obj itself\n```\nThis allows the object to be used directly in iteration contexts."
                },
                {
                    "method_name": "__next__",
                    "source_code": "def __next__(self):\n    self.parent = greenlet.getcurrent()\n    result = self.switch()\n    if self:\n        return result\n    else:\n        raise StopIteration",
                    "first_doc": "**__next__**: The function of __next__ is to advance the generator to its next value, returning the result or raising StopIteration when the generator is exhausted.\n\n**parameters**: The parameters of this Function.\n· self: Refers to the current instance of the generator-like object.\n\n**Code Description**:  \nThis method implements the iterator protocol's __next__ method, allowing the object to be used in iteration contexts such as for-loops. When called, it first sets the parent attribute of the object to the currently running greenlet using greenlet.getcurrent(). It then resumes execution of the greenlet by calling self.switch(), capturing the result. If the generator is still active (i.e., self evaluates to True), it returns the result obtained from the switch. If the generator has completed its execution (i.e., self evaluates to False), it raises a StopIteration exception to signal that there are no further values to yield.\n\n**Note**:  \n- This method relies on the greenlet library for cooperative multitasking and context switching.\n- The object must be a valid greenlet instance or compatible with greenlet's interface.\n- Raising StopIteration is the standard way to signal the end of iteration in Python.\n\n**Output Example**:  \nIf the generator yields the value 42 on the next switch, calling next(obj) (where obj is an instance implementing this __next__ method) would return:\n42\n\nIf the generator is exhausted, calling next(obj) would raise:\nStopIteration"
                }
            ]
        },
        {
            "type": "class",
            "name": "generator",
            "methods": []
        },
        {
            "type": "class",
            "name": "GeneratorTests",
            "methods": [
                {
                    "method_name": "test_generator",
                    "source_code": "def test_generator(self):\n    seen = []\n\n    def g(n):\n        for i in range(n):\n            seen.append(i)\n            Yield(i)\n    g = generator(g)\n    for k in range(3):\n        for j in g(5):\n            seen.append(j)\n    self.assertEqual(seen, 3 * [0, 0, 1, 1, 2, 2, 3, 3, 4, 4])",
                    "first_doc": "**test_generator**: The function of test_generator is to verify the correct behavior of a generator-like construct created using the generator function, ensuring that it yields values as expected and supports repeated iteration.\n\n**parameters**: The parameters of this Function.\n· self: The instance of the test case class, used to access assertion methods and maintain test context.\n\n**Code Description**:  \nThis function defines a test case for generator functionality. It first initializes an empty list named seen to record the sequence of values processed during the test. Inside test_generator, a local function g(n) is defined, which iterates from 0 to n-1. For each iteration, it appends the current index i to the seen list and yields the value i using Yield(i).\n\nThe function g is then wrapped using the generator function, which transforms it into a generator-like class compatible with the genlet protocol. This allows g to be used in a for-loop, yielding values as specified by the Yield statements in its body.\n\nThe test then executes a nested loop: the outer loop runs three times, and the inner loop iterates over the values produced by g(5). For each yielded value j, it appends j to the seen list. This results in the seen list collecting both the indices from the original function and the yielded values, for each of the three outer iterations.\n\nFinally, the test asserts that the seen list matches the expected sequence: three repetitions of the pattern [0, 0, 1, 1, 2, 2, 3, 3, 4, 4]. This pattern confirms that for each call to the generator, both the index and the yielded value are recorded in the correct order, and that the generator can be iterated multiple times with consistent results.\n\nThe relationship with its callee, generator, is central: generator is responsible for wrapping the function g so that it behaves like a generator, supporting iteration and yielding values as defined by the Yield statements. The test ensures that this wrapping works as intended and that the generator protocol is correctly implemented.\n\n**Note**:  \n- The test relies on the correct implementation of the generator function and the Yield mechanism.\n- The seen list is used to track both the values processed inside the generator function and those yielded to the outer loop, ensuring comprehensive verification.\n- The test expects that the generator can be reused multiple times, producing the same sequence of values on each iteration."
                },
                {
                    "method_name": "g",
                    "source_code": "def g(n):\n    for i in range(n):\n        seen.append(i)\n        Yield(i)",
                    "first_doc": "**g**: The function of g is to yield a sequence of integer values from 0 up to n-1, one at a time, within a genlet-based coroutine context.\n\n**parameters**: The parameters of this Function.\n· n: The number of integer values to yield; determines the range of values produced by the function.\n\n**Code Description**:  \nThe function g is designed to operate within a genlet-based coroutine environment. It iterates from 0 to n-1 using a for loop. During each iteration, it performs two actions:\n\n1. It appends the current integer i to a list named seen. This allows for tracking or recording each value that has been yielded.\n2. It calls the Yield function with the current value i. The Yield function is responsible for transferring control and the value i from the current genlet coroutine back to its parent context. This mechanism enables the function g to produce values one at a time, mimicking the behavior of a generator.\n\nThe use of Yield ensures that each value is yielded cooperatively, allowing the caller to receive each value in sequence and resume the coroutine as needed. This approach is specifically tailored for genlet-based coroutines, which use greenlet for lightweight cooperative multitasking.\n\n**Note**:  \n- The function g must be called within a genlet context; otherwise, the Yield function will raise a RuntimeError.\n- The function is not compatible with standard Python generators or other coroutine frameworks; it is specifically designed for use with genlet and greenlet.\n- The seen list must be defined and accessible in the scope where g is used, as the function appends to this list during each iteration.\n- Proper understanding of genlet-based coroutine control flow is required to use this function effectively."
                }
            ]
        }
    ],
    "tests/test_throw.py": [
        {
            "type": "class",
            "name": "ThrowTests",
            "methods": [
                {
                    "method_name": "test_class",
                    "source_code": "def test_class(self):\n    def f():\n        try:\n            switch(\"ok\")\n        except RuntimeError:\n            switch(\"ok\")\n            return\n        switch(\"fail\")\n    g = greenlet(f)\n    res = g.switch()\n    self.assertEqual(res, \"ok\")\n    res = g.throw(RuntimeError)\n    self.assertEqual(res, \"ok\")",
                    "first_doc": "**test_class**: The function of test_class is to verify the behavior of greenlet's throw method when handling exceptions and context switching.\n\n**parameters**: The parameters of this Function.\n· self: The instance of the test case class, used to access assertion methods.\n\n**Code Description**:  \nThis function defines a test case for greenlet exception handling. Inside test_class, a nested function f is defined. The function f attempts to switch the greenlet with the value \"ok\". If a RuntimeError is raised during this process, it catches the exception, switches the greenlet again with \"ok\", and returns. If no exception occurs, it switches the greenlet with \"fail\".\n\nA greenlet object g is created with f as its run function. The test proceeds as follows:\n1. The greenlet is started with g.switch(), and the result is expected to be \"ok\". This is verified with an assertion.\n2. The greenlet is then resumed by throwing a RuntimeError exception into it using g.throw(RuntimeError). The result of this operation is also expected to be \"ok\", and this is checked with another assertion.\n\nThis test ensures that when an exception is thrown into a greenlet, the exception is properly handled by the try-except block inside the greenlet, and the greenlet can continue execution and return the expected value.\n\n**Note**:  \n- This test assumes that the greenlet and switch functions are properly imported and available in the test environment.\n- The test relies on the correct implementation of greenlet's throw and switch mechanisms.\n- The function is intended to be used within a test framework that provides self.assertEqual.\n\n**Output Example**:  \nThe function does not return a value but performs assertions. If the test passes, there will be no output. If the test fails, an assertion error will be raised, indicating that the actual result did not match the expected value \"ok\"."
                },
                {
                    "method_name": "f",
                    "source_code": "def f():\n    try:\n        switch(\"ok\")\n    except RuntimeError:\n        switch(\"ok\")\n        return\n    switch(\"fail\")",
                    "first_doc": "**f**: The function of f is to test the behavior of the switch function when a RuntimeError is raised and to control the flow of execution between greenlets based on the outcome.\n\n**parameters**: This function does not accept any parameters.\n\n**Code Description**:  \nThe function f is designed to interact with the greenlet-based context switching mechanism provided by the switch function. It attempts to call switch(\"ok\"), which transfers control to the parent greenlet and passes the string \"ok\" as an argument. If this operation raises a RuntimeError—typically indicating that the greenlet context is not properly established or there is no parent greenlet—the exception is caught, and switch(\"ok\") is called again within the except block. After this second call, the function returns immediately, preventing further execution. If no exception occurs during the initial switch(\"ok\") call, the function proceeds to call switch(\"fail\"), signaling a failure to the parent greenlet.\n\nThe relationship with its callee, switch, is central: f relies on switch to communicate status (\"ok\" or \"fail\") to the parent greenlet and to control the execution flow during testing. This pattern is commonly used in coroutine or greenlet-based test scenarios to verify correct exception handling and context switching.\n\n**Note**:  \n- This function assumes it is executed within a valid greenlet context with an accessible parent greenlet. If not, switch may raise a RuntimeError.\n- The function does not return a value to its caller; instead, it uses switch to transfer control and communicate status to the parent greenlet.\n- The parent greenlet should be prepared to handle the arguments (\"ok\" or \"fail\") received from switch.\n\n**Output Example**:  \nWhen f is called, it does not return a value directly. Instead, it transfers control to the parent greenlet with either \"ok\" or \"fail\" as the argument, depending on whether a RuntimeError was encountered during the initial switch. For example, the parent greenlet may receive \"ok\" if the first or second switch(\"ok\") call succeeds, or \"fail\" if no exception occurred and the final switch(\"fail\") is executed."
                },
                {
                    "method_name": "test_val",
                    "source_code": "def test_val(self):\n    def f():\n        try:\n            switch(\"ok\")\n        except RuntimeError:\n            val = sys.exc_info()[1]\n            if str(val) == \"ciao\":\n                switch(\"ok\")\n                return\n        switch(\"fail\")\n\n    g = greenlet(f)\n    res = g.switch()\n    self.assertEqual(res, \"ok\")\n    res = g.throw(RuntimeError(\"ciao\"))\n    self.assertEqual(res, \"ok\")\n\n    g = greenlet(f)\n    res = g.switch()\n    self.assertEqual(res, \"ok\")\n    res = g.throw(RuntimeError, \"ciao\")\n    self.assertEqual(res, \"ok\")",
                    "first_doc": "**test_val**: The function of test_val is to verify the correct handling and propagation of exceptions and their values when using greenlets, specifically testing the throw mechanism and exception value retrieval.\n\n**parameters**: The parameters of this Function.\n· self: The instance of the test case class, used to access assertion methods.\n\n**Code Description**:  \nThis function defines a test case for greenlet exception handling. Inside test_val, a nested function f is defined. The function f uses a try-except block to catch RuntimeError exceptions. When such an exception is caught, it retrieves the exception value using sys.exc_info()[1]. If the string representation of the exception value is \"ciao\", it switches the greenlet back with the value \"ok\" and returns. If the exception does not match, it switches with \"fail\".\n\nThe test then creates a greenlet g with f as its target. It switches to g, expecting \"ok\" as the result. It then throws a RuntimeError with the value \"ciao\" into the greenlet and asserts that the result is again \"ok\".\n\nThe process is repeated: a new greenlet is created, switched to, and then a RuntimeError is thrown into it, this time using the two-argument form (exception type and value separately). The test asserts that the result is \"ok\" in both cases.\n\nThis test ensures that:\n- The greenlet correctly receives and handles exceptions thrown into it.\n- The exception value is properly passed and can be inspected within the greenlet.\n- The switch and throw mechanisms work as expected with respect to exception propagation and value handling.\n\n**Note**:  \n- This test assumes that the greenlet and switch/throw mechanisms are properly implemented and available in the environment.\n- The sys module must be imported for sys.exc_info() to work.\n- The test is designed to be run within a unittest or similar test framework, as it uses self.assertEqual for assertions.\n\n**Output Example**:  \nThe function does not return a value directly; instead, it uses assertions to validate behavior. If all assertions pass, the test framework will report the test as successful. If any assertion fails, the test will be reported as failed, indicating an issue with exception handling in greenlets."
                },
                {
                    "method_name": "f",
                    "source_code": "def f():\n    try:\n        switch(\"ok\")\n    except RuntimeError:\n        val = sys.exc_info()[1]\n        if str(val) == \"ciao\":\n            switch(\"ok\")\n            return\n    switch(\"fail\")",
                    "first_doc": "**f**: The function of f is to coordinate control flow between greenlets, handling a specific RuntimeError and signaling success or failure to the parent greenlet.\n\n**parameters**: This function does not take any parameters.\n\n**Code Description**:  \nThe function f is designed to interact with the greenlet-based coroutine system using the switch function. It attempts to switch control to the parent greenlet by calling switch(\"ok\"). If this operation raises a RuntimeError, the function captures the exception and examines its message. If the exception message is exactly \"ciao\", it again switches control to the parent greenlet with the argument \"ok\" and then returns, indicating a successful handling of the specific error condition. If the exception message does not match \"ciao\", or if no exception occurs, the function proceeds to call switch(\"fail\"), signaling a failure to the parent greenlet.\n\nThe switch function is responsible for transferring execution and passing arguments to the parent greenlet. In this context, f uses switch to communicate the outcome of its execution (\"ok\" for success, \"fail\" for failure) to the parent greenlet, which can then process these signals accordingly.\n\n**Note**:  \n- This function must be executed within a greenlet context where a parent greenlet exists; otherwise, switch may raise a RuntimeError.\n- The function relies on the exact exception message \"ciao\" to determine a successful error handling path.\n- All communication of results is performed via the switch function, and the function itself does not return a value to its caller.\n\n**Output Example**:  \nIf the initial switch(\"ok\") call succeeds without raising an exception, the parent greenlet receives \"ok\".  \nIf a RuntimeError with the message \"ciao\" is raised, the parent greenlet also receives \"ok\".  \nIf any other RuntimeError is raised, or if no exception occurs but the logic falls through, the parent greenlet receives \"fail\".  \nThe function does not return any value directly; all output is communicated through the switch mechanism."
                },
                {
                    "method_name": "test_kill",
                    "source_code": "def test_kill(self):\n    def f():\n        switch(\"ok\")\n        switch(\"fail\")\n    g = greenlet(f)\n    res = g.switch()\n    self.assertEqual(res, \"ok\")\n    res = g.throw()\n    self.assertTrue(isinstance(res, greenlet.GreenletExit))\n    self.assertTrue(g.dead)\n    res = g.throw()    # immediately eaten by the already-dead greenlet\n    self.assertTrue(isinstance(res, greenlet.GreenletExit))",
                    "first_doc": "**test_kill**: The function of test_kill is to verify the behavior of killing a greenlet using the throw() method and to ensure that the greenlet handles GreenletExit exceptions correctly.\n\n**parameters**: The parameters of this Function.\n· self: The instance of the test case class, used to access assertion methods.\n\n**Code Description**:  \nThis function defines a test case for the behavior of greenlet termination using the throw() method. It first defines a local function f that performs two context switches, returning the values \"ok\" and \"fail\" respectively. A greenlet g is created with f as its run function. The test initiates the greenlet by calling g.switch(), which should return \"ok\" as the first yielded value from f. The test then calls g.throw(), which raises a GreenletExit exception inside the greenlet. The test asserts that the result of this throw is an instance of greenlet.GreenletExit and that the greenlet is marked as dead after the exception is thrown. The test further calls g.throw() again on the already-dead greenlet, and asserts that it immediately returns another instance of greenlet.GreenletExit, confirming that repeated throw calls on a dead greenlet are handled gracefully.\n\n**Note**:  \n- This test assumes the use of the greenlet library and its API, specifically the switch and throw methods.\n- The test checks both the correct propagation of GreenletExit and the proper dead state of the greenlet after termination.\n- Repeated calls to throw() on a dead greenlet should not raise errors but should consistently return GreenletExit, ensuring robustness in greenlet cleanup behavior."
                },
                {
                    "method_name": "f",
                    "source_code": "def f():\n    switch(\"ok\")\n    switch(\"fail\")",
                    "first_doc": "**f**: The function of f is to perform two consecutive context switches to the parent greenlet, passing the arguments \"ok\" and \"fail\" respectively.\n\n**parameters**: This function does not take any parameters.\n\n**Code Description**:  \nThe function f is designed to coordinate control flow between greenlets during testing. It achieves this by invoking the switch function twice in succession. The first call, switch(\"ok\"), transfers execution control from the current greenlet to its parent and passes the string \"ok\" as an argument. The second call, switch(\"fail\"), similarly transfers control and passes the string \"fail\". The switch function, as used here, is responsible for yielding execution to the parent greenlet and delivering the provided arguments. This pattern is typically used in coroutine-based test scenarios to signal specific states or events—such as success (\"ok\") or failure (\"fail\")—to the parent context, allowing the parent greenlet to handle these signals accordingly.\n\n**Note**:  \n- This function must be executed within a valid greenlet context where a parent greenlet exists; otherwise, a RuntimeError may occur.\n- The function does not return a value to its caller. Instead, it relies on the greenlet context switching mechanism to communicate with the parent greenlet.\n- The parent greenlet should be prepared to handle the arguments \"ok\" and \"fail\" as part of the test coordination process."
                },
                {
                    "method_name": "test_throw_goes_to_original_parent",
                    "source_code": "def test_throw_goes_to_original_parent(self):\n    main = greenlet.getcurrent()\n\n    def f1():\n        try:\n            main.switch(\"f1 ready to catch\")\n        except IndexError:\n            return \"caught\"\n        else:\n            return \"normal exit\"\n\n    def f2():\n        main.switch(\"from f2\")\n\n    g1 = greenlet(f1)\n    g2 = greenlet(f2, parent=g1)\n    self.assertRaises(IndexError, g2.throw, IndexError)\n    self.assertTrue(g2.dead)\n    self.assertTrue(g1.dead)\n\n    g1 = greenlet(f1)\n    g2 = greenlet(f2, parent=g1)\n    res = g1.switch()\n    self.assertEqual(res, \"f1 ready to catch\")\n    res = g2.throw(IndexError)\n    self.assertEqual(res, \"caught\")\n    self.assertTrue(g2.dead)\n    self.assertTrue(g1.dead)\n\n    g1 = greenlet(f1)\n    g2 = greenlet(f2, parent=g1)\n    res = g1.switch()\n    self.assertEqual(res, \"f1 ready to catch\")\n    res = g2.switch()\n    self.assertEqual(res, \"from f2\")\n    res = g2.throw(IndexError)\n    self.assertEqual(res, \"caught\")\n    self.assertTrue(g2.dead)\n    self.assertTrue(g1.dead)",
                    "first_doc": "**test_throw_goes_to_original_parent**: The function of test_throw_goes_to_original_parent is to verify that exceptions thrown into a greenlet are correctly propagated to the original parent greenlet, and that both the child and parent greenlets are properly terminated after exception handling.\n\n**parameters**: The parameters of this Function.\n· self: The test case instance, providing access to assertion methods.\n\n**Code Description**:  \nThis test method checks the behavior of exception propagation and greenlet termination in a parent-child greenlet relationship. It uses the greenlet library to create and manage lightweight coroutines.\n\n- The test defines two inner functions, f1 and f2:\n  - f1 attempts to catch an IndexError exception and returns \"caught\" if successful, or \"normal exit\" otherwise. It first yields control to the main greenlet.\n  - f2 simply yields control to the main greenlet with a specific message.\n- Three scenarios are tested:\n  1. A greenlet g2 is created with f2 as its run function and g1 (running f1) as its parent. An IndexError is thrown into g2 before it is started. The test asserts that an IndexError is raised, and both g1 and g2 are dead after the operation.\n  2. The greenlets are recreated. This time, g1 is started first, and then an IndexError is thrown into g2. The test asserts that f1 catches the exception and returns \"caught\", and both greenlets are dead.\n  3. The greenlets are recreated again. g1 is started, then g2 is switched to, and finally, an IndexError is thrown into g2. The test asserts that f1 catches the exception and returns \"caught\", and both greenlets are dead.\n- Throughout, the test uses assertion methods to ensure correct exception propagation, return values, and greenlet termination.\n\n**Note**:  \n- This test assumes the use of the greenlet library and its API for coroutine management.\n- The test ensures that exceptions thrown into a child greenlet are handled by the parent greenlet as expected.\n- Both the parent and child greenlets should be dead after the exception is handled, confirming proper cleanup.\n- The test uses assertRaises, assertTrue, and assertEqual to validate behavior.\n\n**Output Example**:  \nThere is no direct return value from this test function. Instead, it raises an AssertionError if any of the assertions fail. If all assertions pass, the test completes successfully with no output. For example, if run in a test suite, the output would indicate a passing test unless an assertion fails."
                },
                {
                    "method_name": "f1",
                    "source_code": "def f1():\n    try:\n        main.switch(\"f1 ready to catch\")\n    except IndexError:\n        return \"caught\"\n    else:\n        return \"normal exit\"",
                    "first_doc": "**f1**: The function of f1 is to attempt to switch execution using the main.switch method and handle an IndexError if it occurs.\n\n**parameters**: The parameters of this Function.\n· None\n\n**Code Description**:  \nThis function executes a try-except-else block. It calls main.switch with the argument \"f1 ready to catch\". If this call raises an IndexError, the function returns the string \"caught\". If no exception is raised, the function returns \"normal exit\". The function does not accept any parameters and is designed to handle only the IndexError exception specifically.\n\n**Note**:  \n- The function assumes that main.switch is defined elsewhere in the codebase and that it may potentially raise an IndexError.\n- Only IndexError exceptions are caught; any other exceptions will propagate up the call stack.\n- The function always returns a string, either \"caught\" or \"normal exit\".\n\n**Output Example**:  \n\"caught\"  \n\"normal exit\""
                },
                {
                    "method_name": "f2",
                    "source_code": "def f2():\n    main.switch(\"from f2\")",
                    "first_doc": "**f2**: The function of f2 is to invoke the switch method of the main object with the argument \"from f2\".\n\n**parameters**: The parameters of this Function.\n· None\n\n**Code Description**:  \nThe f2 function is a simple, parameterless function that calls the switch method on the main object, passing the string \"from f2\" as an argument. This action likely triggers a state change or context switch within the main object, using \"from f2\" as an identifier or message to indicate the source or reason for the switch. The function does not return any value and does not perform any other operations.\n\n**Note**:  \nEnsure that the main object is properly defined and accessible in the scope where f2 is called. The switch method of main should accept a single string argument. Calling this function without a valid main object or switch method will result in a runtime error."
                }
            ]
        }
    ],
    "tests/test_extension_interface.py": [
        {
            "type": "class",
            "name": "CAPITests",
            "methods": [
                {
                    "method_name": "test_switch",
                    "source_code": "def test_switch(self):\n    self.assertEqual(\n        50, _test_extension.test_switch(greenlet.greenlet(lambda: 50)))",
                    "first_doc": "**test_switch**: The function of test_switch is to verify that the _test_extension.test_switch function correctly switches execution to a greenlet and returns the expected value.\n\n**parameters**: The parameters of this Function.\n· self: Refers to the instance of the CAPITests test case class.\n\n**Code Description**:  \nThis function is a unit test designed to check the behavior of the test_switch function from the _test_extension module when used with a greenlet. It creates a new greenlet object that, when executed, returns the value 50. The test then calls _test_extension.test_switch with this greenlet as its argument and asserts that the result is equal to 50. This confirms that the extension function is able to switch execution to the provided greenlet and correctly retrieve its return value.\n\n**Note**:  \n- This test assumes that the _test_extension.test_switch function is implemented to accept a greenlet object and switch execution to it.\n- The test requires the greenlet module to be available and properly imported.\n- The test is intended to be run within a unittest framework and relies on the assertEqual method for validation."
                },
                {
                    "method_name": "test_switch_kwargs",
                    "source_code": "def test_switch_kwargs(self):\n    def foo(x, y):\n        return x * y\n    g = greenlet.greenlet(foo)\n    self.assertEqual(6, _test_extension.test_switch_kwargs(g, x=3, y=2))",
                    "first_doc": "**test_switch_kwargs**: The function of test_switch_kwargs is to verify that keyword arguments can be correctly passed through a greenlet switch using the _test_extension.test_switch_kwargs function.\n\n**parameters**: The parameters of this Function.\n· self: The instance of the test case class (CAPITests), used to access assertion methods.\n\n**Code Description**:  \nThis function defines an inner function foo that takes two arguments, x and y, and returns their product. It then creates a greenlet object g that wraps the foo function. The test calls _test_extension.test_switch_kwargs, passing the greenlet g and keyword arguments x=3 and y=2. The result of this call is asserted to be equal to 6, confirming that the keyword arguments are correctly passed through the greenlet switch and that the foo function executes as expected. This test ensures that the extension module's test_switch_kwargs function can handle switching to a greenlet with keyword arguments.\n\n**Note**:  \n- This test assumes that _test_extension.test_switch_kwargs is implemented to switch to the provided greenlet with the given keyword arguments.\n- The test relies on the correct behavior of both the greenlet library and the _test_extension module.\n- The test will fail if the keyword arguments are not properly forwarded or if the extension does not handle them correctly.\n\n**Output Example**:  \nThe assertion checks that the result is 6, which is the product of 3 and 2 as returned by foo. If the test passes, there is no output; if it fails, an AssertionError is raised."
                },
                {
                    "method_name": "foo",
                    "source_code": "def foo(x, y):\n    return x * y",
                    "first_doc": "**foo**: The function of foo is to return the product of two input values x and y.\n\n**parameters**: The parameters of this Function.\n· x: The first value to be multiplied.  \n· y: The second value to be multiplied.\n\n**Code Description**:  \nThis function takes two arguments, x and y, and returns the result of multiplying x by y. The multiplication operation is performed using the * operator, which works for numeric types such as integers and floats, as well as for types that support the multiplication operation (for example, multiplying a string by an integer in Python results in string repetition). The function does not perform any type checking or validation, so it assumes that the provided arguments are compatible with the multiplication operator.\n\n**Note**:  \n- Both x and y should be of types that support the * operator.  \n- If incompatible types are provided (e.g., multiplying a string by another string), a TypeError will be raised.\n- The function does not handle exceptions or perform input validation.\n\n**Output Example**:  \nIf called as foo(3, 4), the return value will be 12.  \nIf called as foo('a', 3), the return value will be 'aaa'."
                },
                {
                    "method_name": "test_setparent",
                    "source_code": "def test_setparent(self):\n    def foo():\n        def bar():\n            greenlet.getcurrent().parent.switch()\n\n            # This final switch should go back to the main greenlet, since\n            # the test_setparent() function in the C extension should have\n            # reparented this greenlet.\n            greenlet.getcurrent().parent.switch()\n            raise AssertionError(\"Should never have reached this code\")\n        child = greenlet.greenlet(bar)\n        child.switch()\n        greenlet.getcurrent().parent.switch(child)\n        greenlet.getcurrent().parent.throw(\n            AssertionError(\"Should never reach this code\"))\n    foo_child = greenlet.greenlet(foo).switch()\n    self.assertEqual(None, _test_extension.test_setparent(foo_child))",
                    "first_doc": "**test_setparent**: The function of test_setparent is to verify the correct behavior of greenlet parent switching and reparenting, particularly in conjunction with the C extension's test_setparent functionality.\n\n**parameters**: The parameters of this Function.\n· self: The test case instance, providing access to assertion methods and test context.\n\n**Code Description**:  \nThis function is a unit test designed to ensure that greenlet parent switching and reparenting operate as expected, especially when interacting with the C extension's test_setparent function. The test defines a nested function foo, which itself defines another nested function bar. The bar function performs two parent switches using greenlet.getcurrent().parent.switch(). The first switch transfers control to the parent greenlet, and the second switch is expected to return to the main greenlet, assuming the C extension has correctly reparented the greenlet. If execution continues past the second switch, an AssertionError is raised, indicating incorrect behavior.\n\nA greenlet is created with bar as its run function and is switched to, starting its execution. After the child greenlet yields control, the parent greenlet performs a switch to the child and then attempts to throw an AssertionError into the parent, which should not be reached if reparenting is correct.\n\nThe foo function is then run in its own greenlet, and the result is passed to _test_extension.test_setparent. The test asserts that the result of this call is None, confirming that the reparenting logic in the C extension worked as intended and that no unexpected code paths were executed.\n\n**Note**:  \n- This test assumes the presence of a C extension module _test_extension with a test_setparent function.\n- The test is specifically designed for environments where greenlet-based concurrency is used and may not be meaningful outside such contexts.\n- The test expects that improper parent switching or failure to reparent will result in an AssertionError, ensuring that only the correct control flow is allowed.\n- Proper exception handling and greenlet cleanup are implicitly tested by the structure of the function."
                },
                {
                    "method_name": "foo",
                    "source_code": "def foo():\n    def bar():\n        greenlet.getcurrent().parent.switch()\n\n        # This final switch should go back to the main greenlet, since\n        # the test_setparent() function in the C extension should have\n        # reparented this greenlet.\n        greenlet.getcurrent().parent.switch()\n        raise AssertionError(\"Should never have reached this code\")\n    child = greenlet.greenlet(bar)\n    child.switch()\n    greenlet.getcurrent().parent.switch(child)\n    greenlet.getcurrent().parent.throw(\n        AssertionError(\"Should never reach this code\"))",
                    "first_doc": "**foo**: The function of foo is to test the behavior of greenlet parent switching and exception handling in a greenlet context.\n\n**parameters**: The parameters of this Function.\n· None\n\n**Code Description**:  \nThis function defines a nested function bar, which is intended to be executed within a greenlet context. The bar function performs the following steps:\n\n1. It switches execution to its parent greenlet using greenlet.getcurrent().parent.switch().\n2. After returning from the first switch, it attempts another switch to its parent greenlet. According to the intended test scenario, by this point, the parent of the current greenlet should have been changed (reparented) by the test_setparent() function in the C extension.\n3. If execution continues past the second switch, an AssertionError is raised, indicating that this code path should not be reached.\n\nThe foo function then creates a new greenlet with bar as its run function and switches execution to it. After the child greenlet yields control back, foo switches to its own parent, passing the child greenlet as an argument. Finally, it throws an AssertionError into its parent greenlet if execution continues, indicating an unexpected code path.\n\nThis function is designed to verify that greenlet parent switching and exception propagation behave as expected, particularly in the context of C extension manipulation of greenlet parent relationships.\n\n**Note**:  \n- This function assumes that the greenlet C extension's test_setparent() function will reparent the current greenlet as expected.\n- The function is intended for use in a controlled test environment and will raise AssertionError if the greenlet control flow does not behave as expected.\n- It does not accept any parameters and is not intended for general-purpose use outside of greenlet parent/child relationship testing."
                },
                {
                    "method_name": "bar",
                    "source_code": "def bar():\n    greenlet.getcurrent().parent.switch()\n\n    # This final switch should go back to the main greenlet, since\n    # the test_setparent() function in the C extension should have\n    # reparented this greenlet.\n    greenlet.getcurrent().parent.switch()\n    raise AssertionError(\"Should never have reached this code\")",
                    "first_doc": "**bar**: The function of bar is to perform two consecutive context switches to the parent greenlet and raise an error if execution resumes in this function after the second switch.\n\n**parameters**: The parameters of this Function.\n· None\n\n**Code Description**:  \nThis function uses the greenlet library to manipulate greenlet execution flow. It first retrieves the current greenlet using greenlet.getcurrent() and switches execution to its parent greenlet by calling parent.switch(). After returning from the first switch, it performs a second switch to the parent greenlet. The expectation is that, due to external logic (specifically, the test_setparent() function in the C extension), the parent of the current greenlet will have been changed, and control should not return to this function after the second switch. If, however, execution does return to this function after the second switch, an AssertionError is raised with the message \"Should never have reached this code\", indicating an unexpected code path.\n\n**Note**:  \n- This function assumes that it is being used in a context where the parent greenlet may be dynamically changed by external logic, such as a C extension.\n- It does not accept any parameters.\n- The function will always raise an AssertionError if execution resumes after the second parent.switch(), which should not happen under correct usage.\n- Proper use of this function requires familiarity with the greenlet library and its context-switching semantics."
                },
                {
                    "method_name": "test_getcurrent",
                    "source_code": "def test_getcurrent(self):\n    _test_extension.test_getcurrent()",
                    "first_doc": "**test_getcurrent**: The function of test_getcurrent is to execute and verify the behavior of the getcurrent functionality provided by the _test_extension module.\n\n**parameters**: The parameters of this Function.\n· self: Refers to the instance of the CAPITests test case class in which this method is defined.\n\n**Code Description**:  \nThis method is a unit test designed to validate the getcurrent feature implemented in the _test_extension module. It does so by directly invoking the test_getcurrent function from _test_extension. The method does not contain any assertions or additional logic, indicating that the correctness of the test is determined by the behavior of _test_extension.test_getcurrent() itself. If the underlying function raises an exception or fails, the test will be marked as failed by the test runner. Otherwise, the test passes silently.\n\n**Note**:  \n- This test assumes that _test_extension.test_getcurrent() will raise an exception if the functionality is incorrect, and will complete without error if the functionality is correct.\n- There are no input parameters or return values for this test method.\n- Ensure that the _test_extension module is properly imported and available in the test environment before running this test.\n- This test is intended to be run as part of an automated test suite, typically using a test runner compatible with the test class structure."
                },
                {
                    "method_name": "test_new_greenlet",
                    "source_code": "def test_new_greenlet(self):\n    self.assertEqual(-15, _test_extension.test_new_greenlet(lambda: -15))",
                    "first_doc": "**test_new_greenlet**: The function of test_new_greenlet is to verify that the _test_extension.test_new_greenlet function correctly executes a provided lambda function in a new greenlet and returns its result.\n\n**parameters**: The parameters of this Function.\n· self: The instance of the CAPITests test case class.\n\n**Code Description**:  \nThis method is a unit test designed to check the behavior of the _test_extension.test_new_greenlet function. It calls _test_extension.test_new_greenlet with a lambda function that returns -15. The test then asserts that the value returned by _test_extension.test_new_greenlet is equal to -15. This ensures that the lambda function is executed in a new greenlet context and that its return value is properly propagated back to the caller.\n\n**Note**:  \nThis test assumes that _test_extension.test_new_greenlet is implemented to execute the given callable in a new greenlet and return its result. The test will fail if the greenlet mechanism does not correctly handle the execution or result propagation of the lambda function."
                },
                {
                    "method_name": "test_raise_greenlet_dead",
                    "source_code": "def test_raise_greenlet_dead(self):\n    self.assertRaises(\n        greenlet.GreenletExit, _test_extension.test_raise_dead_greenlet)",
                    "first_doc": "**test_raise_greenlet_dead**: The function of test_raise_greenlet_dead is to verify that raising an exception in a dead greenlet correctly results in a GreenletExit exception.\n\n**parameters**: The parameters of this Function.\n· self: Refers to the instance of the test case class CAPITests.\n\n**Code Description**:  \nThis function is a unit test designed to ensure the correct behavior of the greenlet extension when an exception is raised in a dead greenlet. It uses the assertRaises method from the unittest framework to check that invoking _test_extension.test_raise_dead_greenlet raises a greenlet.GreenletExit exception. This test is important for validating that the greenlet implementation adheres to expected exception handling semantics, specifically that attempting to raise an exception in a greenlet that has already finished execution (is \"dead\") should result in a GreenletExit being raised.\n\n**Note**:  \nThis test assumes that the _test_extension.test_raise_dead_greenlet function is implemented to attempt to raise an exception in a dead greenlet. It is important that the greenlet and _test_extension modules are properly imported and available in the test environment for this test to execute successfully."
                },
                {
                    "method_name": "test_raise_greenlet_error",
                    "source_code": "def test_raise_greenlet_error(self):\n    self.assertRaises(\n        greenlet.error, _test_extension.test_raise_greenlet_error)",
                    "first_doc": "**test_raise_greenlet_error**: The function of test_raise_greenlet_error is to verify that the _test_extension.test_raise_greenlet_error function correctly raises a greenlet.error exception.\n\n**parameters**: The parameters of this Function.\n· self: Refers to the instance of the CAPITests test case class.\n\n**Code Description**:  \nThis function is a unit test method designed to ensure that the _test_extension.test_raise_greenlet_error function raises the expected greenlet.error exception when called. It uses the assertRaises method from the unittest framework to check for this specific exception. If the exception is raised as expected, the test passes; otherwise, it fails. This test is important for validating the error handling behavior of the extension interface, specifically in scenarios where a greenlet-related error should be triggered.\n\n**Note**:  \nThis test assumes that _test_extension.test_raise_greenlet_error is implemented to raise a greenlet.error exception. If the implementation changes or the exception type differs, the test will fail. Ensure that the greenlet module and _test_extension are properly imported and available in the test environment."
                },
                {
                    "method_name": "test_throw",
                    "source_code": "def test_throw(self):\n    seen = []\n\n    def foo():\n        try:\n            greenlet.getcurrent().parent.switch()\n        except ValueError:\n            seen.append(sys.exc_info()[1])\n        except greenlet.GreenletExit:\n            raise AssertionError\n    g = greenlet.greenlet(foo)\n    g.switch()\n    _test_extension.test_throw(g)\n    self.assertEqual(len(seen), 1)\n    self.assertTrue(\n        isinstance(seen[0], ValueError),\n        \"ValueError was not raised in foo()\")\n    self.assertEqual(\n        str(seen[0]),\n        'take that sucka!',\n        \"message doesn't match\")",
                    "first_doc": "**test_throw**: The function of test_throw is to verify that a ValueError is correctly raised and handled when using the greenlet extension's test_throw functionality.\n\n**parameters**: The parameters of this Function.\n· self: Refers to the instance of the test case class (CAPITests), allowing access to assertion methods and test context.\n\n**Code Description**:  \nThis function is a unit test designed to check the behavior of exception propagation in greenlets, specifically when the test_throw method from the _test_extension module is used. The test defines an inner function foo, which attempts to switch control to its parent greenlet. If a ValueError is raised during this process, it is caught and appended to the seen list. If a greenlet.GreenletExit exception occurs, an AssertionError is raised, indicating an unexpected exit.\n\nA new greenlet is created with foo as its run function, and execution is started by calling g.switch(). The test then invokes _test_extension.test_throw(g), which is expected to trigger the ValueError in foo. After execution, the test asserts that exactly one exception was caught in seen, that the exception is an instance of ValueError, and that its message matches the expected string 'take that sucka!'.\n\n**Note**:  \n- This test assumes that _test_extension.test_throw(g) will cause a ValueError to be raised in the context of the greenlet g.\n- The test will fail if no exception or an unexpected exception is raised, or if the exception message does not match the expected value.\n- The use of sys.exc_info()[1] ensures that the actual exception instance is captured for precise verification.\n- The test is specific to the behavior of greenlet-based concurrency and the custom extension's exception handling."
                },
                {
                    "method_name": "foo",
                    "source_code": "def foo():\n    try:\n        greenlet.getcurrent().parent.switch()\n    except ValueError:\n        seen.append(sys.exc_info()[1])\n    except greenlet.GreenletExit:\n        raise AssertionError",
                    "first_doc": "**foo**: The function of foo is to attempt to switch execution to the parent greenlet and handle specific exceptions that may occur during this process.\n\n**parameters**: The parameters of this Function.\n· None\n\n**Code Description**:  \nThis function uses the greenlet library to manage coroutine-like execution flows. When called, foo attempts to switch execution to the parent greenlet using greenlet.getcurrent().parent.switch(). If this operation raises a ValueError, the function appends the current exception instance (retrieved via sys.exc_info()[1]) to a list named seen. If a greenlet.GreenletExit exception is raised during the switch, the function raises an AssertionError, indicating that such an exit is unexpected in this context. No value is returned from this function.\n\n**Note**:  \n- The function assumes that the variables greenlet, sys, and seen are available in the enclosing scope.\n- The function is intended for use within a greenlet-based concurrency context.\n- The function does not accept any parameters and does not return a value.\n- The handling of exceptions is specific: only ValueError and greenlet.GreenletExit are managed, with all other exceptions propagating normally."
                }
            ]
        }
    ],
    "doc/conf.py": [],
    "appveyor/run_pip.py": [],
    "benchmarks/chain.py": []
}